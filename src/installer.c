/* installer.c generated by valac 0.26.1, the Vala compiler
 * generated from installer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <JavaScriptCore/JavaScript.h>
#include <sys/wait.h>
#include <gee.h>
#include <glib/gstdio.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <unistd.h>
#include <locale.h>
#include <config.h>
#include <webkit/webkit.h>
#include <gdk/gdk.h>


#define TYPE_LOG (log_get_type ())
#define LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOG, Log))
#define LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOG, LogClass))
#define IS_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOG))
#define IS_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOG))
#define LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOG, LogClass))

typedef struct _Log Log;
typedef struct _LogClass LogClass;
typedef struct _LogPrivate LogPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_INSTALLATION (installation_get_type ())
#define INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLATION, Installation))
#define INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLATION, InstallationClass))
#define IS_INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLATION))
#define IS_INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLATION))
#define INSTALLATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLATION, InstallationClass))

typedef struct _Installation Installation;
typedef struct _InstallationClass InstallationClass;
typedef struct _InstallationPrivate InstallationPrivate;

#define INSTALLATION_TYPE_STEP (installation_step_get_type ())

#define INSTALLATION_TYPE_STATE (installation_state_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;

#define DEVICE_TYPE_PARTITION (device_partition_get_type ())
#define DEVICE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEVICE_TYPE_PARTITION, DevicePartition))
#define DEVICE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEVICE_TYPE_PARTITION, DevicePartitionClass))
#define DEVICE_IS_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEVICE_TYPE_PARTITION))
#define DEVICE_IS_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEVICE_TYPE_PARTITION))
#define DEVICE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEVICE_TYPE_PARTITION, DevicePartitionClass))

typedef struct _DevicePartition DevicePartition;
typedef struct _DevicePartitionClass DevicePartitionClass;

#define DEVICE_TYPE_PARTITION_TYPE (device_partition_type_get_type ())
#define _JSStringRelease0(var) ((var == NULL) ? NULL : (var = (JSStringRelease (var), NULL)))
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _JSClassRelease0(var) ((var == NULL) ? NULL : (var = (JSClassRelease (var), NULL)))

#define TYPE_INSTALLER (installer_get_type ())
#define INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLER, Installer))
#define INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLER, InstallerClass))
#define IS_INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLER))
#define IS_INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLER))
#define INSTALLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLER, InstallerClass))

typedef struct _Installer Installer;
typedef struct _InstallerClass InstallerClass;
typedef struct _InstallerPrivate InstallerPrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _Log {
	GObject parent_instance;
	LogPrivate * priv;
};

struct _LogClass {
	GObjectClass parent_class;
};

struct _LogPrivate {
	GDataOutputStream* stream;
};

struct _Installation {
	GObject parent_instance;
	InstallationPrivate * priv;
	gboolean separatedHome;
};

struct _InstallationClass {
	GObjectClass parent_class;
};

typedef enum  {
	INSTALLATION_STEP_IDLE,
	INSTALLATION_STEP_PARTITION,
	INSTALLATION_STEP_FS,
	INSTALLATION_STEP_MOUNT,
	INSTALLATION_STEP_MOUNTHOME,
	INSTALLATION_STEP_COPY,
	INSTALLATION_STEP_SETUP,
	INSTALLATION_STEP_GRUB,
	INSTALLATION_STEP_CLEANUP,
	INSTALLATION_STEP_DONE
} InstallationStep;

struct _InstallationPrivate {
	gint _partition;
	gint _device;
	gchar* _user_name;
	gchar* _password;
	gchar* _host_name;
	gchar* _full_name;
	gchar* _grub_device;
	gchar* _language;
	gchar* _region;
	gchar* _keyboard;
	gchar* _home;
	gchar* _root;
	gboolean _autologin;
	gboolean _advancedMode;
	gint _state;
	gint _progress;
	gchar* _description;
	gchar* _steps;
	guint64 installation_size;
	gchar* partition_path;
	gchar* device_path;
	InstallationStep step;
	InstallationStep last_step;
	GIOChannel* io_err;
	GIOChannel* io_out;
};

typedef enum  {
	INSTALLATION_STATE_NOT_STARTED,
	INSTALLATION_STATE_ON_GOING,
	INSTALLATION_STATE_ERROR,
	INSTALLATION_STATE_DONE
} InstallationState;

typedef enum  {
	DEVICE_ERROR_CANT_CREATE_PARTITION
} DeviceError;
#define DEVICE_ERROR device_error_quark ()
typedef enum  {
	DEVICE_PARTITION_TYPE_NORMAL,
	DEVICE_PARTITION_TYPE_LOGICAL,
	DEVICE_PARTITION_TYPE_EXTENDED,
	DEVICE_PARTITION_TYPE_FREESPACE,
	DEVICE_PARTITION_TYPE_METADATA,
	DEVICE_PARTITION_TYPE_PROTECTED,
	DEVICE_PARTITION_TYPE_INVALID
} DevicePartitionType;

struct _Installer {
	WebKitWebView parent_instance;
	InstallerPrivate * priv;
};

struct _InstallerClass {
	WebKitWebViewClass parent_class;
};

struct _InstallerPrivate {
	const gchar* debug;
};

struct _Block1Data {
	int _ref_count_;
	Installer* self;
	WebKitWebView* webview;
};


static gpointer log_parent_class = NULL;
static Log* log__instance;
static Log* log__instance = NULL;
static gpointer installation_parent_class = NULL;
static gpointer installer_parent_class = NULL;

GType log_get_type (void) G_GNUC_CONST;
#define LOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LOG, LogPrivate))
enum  {
	LOG_DUMMY_PROPERTY
};
Log* log_new (void);
Log* log_construct (GType object_type);
void log_log_without_newline (Log* self, const gchar* string);
void log_log (Log* self, const gchar* string);
Log* log_instance (void);
static void log_finalize (GObject* obj);
GType installation_get_type (void) G_GNUC_CONST;
static GType installation_step_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define INSTALLATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLATION, InstallationPrivate))
enum  {
	INSTALLATION_DUMMY_PROPERTY,
	INSTALLATION_PARTITION,
	INSTALLATION_DEVICE,
	INSTALLATION_USER_NAME,
	INSTALLATION_PASSWORD,
	INSTALLATION_HOST_NAME,
	INSTALLATION_FULL_NAME,
	INSTALLATION_GRUB_DEVICE,
	INSTALLATION_LANGUAGE,
	INSTALLATION_REGION,
	INSTALLATION_KEYBOARD,
	INSTALLATION_HOME,
	INSTALLATION_ROOT,
	INSTALLATION_AUTOLOGIN,
	INSTALLATION_ADVANCED_MODE,
	INSTALLATION_STATE,
	INSTALLATION_PROGRESS,
	INSTALLATION_DESCRIPTION,
	INSTALLATION_STEPS
};
GType installation_state_get_type (void) G_GNUC_CONST;
#define INSTALLATION_OneGig ((guint64) ((1024 * 1024) * 1024))
void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception);
Installation* installation_new_from_string (const gchar* uri);
Installation* installation_construct_from_string (GType object_type, const gchar* uri);
static void installation_set_progress (Installation* self, gint value);
void installation_set_state (Installation* self, gint value);
void installation_set_description (Installation* self, const gchar* value);
void installation_set_autologin (Installation* self, gboolean value);
void installation_set_device (Installation* self, gint value);
gint installation_get_device (Installation* self);
void installation_set_partition (Installation* self, gint value);
void installation_set_user_name (Installation* self, const gchar* value);
void installation_set_password (Installation* self, const gchar* value);
void installation_set_host_name (Installation* self, const gchar* value);
void installation_set_full_name (Installation* self, const gchar* value);
void installation_set_grub_device (Installation* self, const gchar* value);
void installation_set_language (Installation* self, const gchar* value);
void installation_set_region (Installation* self, const gchar* value);
void installation_set_keyboard (Installation* self, const gchar* value);
void installation_set_home (Installation* self, const gchar* value);
void installation_set_advancedMode (Installation* self, gboolean value);
void installation_set_steps (Installation* self, const gchar* value);
static void __lambda7_ (Installation* self);
static void installation_real_start (Installation* self);
static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self);
void installation_start (Installation* self);
static void installation_do_next_job (Installation* self);
static void installation_do_partition (Installation* self);
static void installation_do_fs (Installation* self);
static void installation_do_mount (Installation* self);
static void installation_do_mount_home (Installation* self);
static void installation_do_copy (Installation* self);
static void installation_do_setup (Installation* self);
static void installation_do_grub (Installation* self);
static void installation_do_cleanup (Installation* self);
static void installation_do_done (Installation* self);
gint installation_get_state (Installation* self);
static void installation_child_watch (Installation* self, GPid pid, gint status);
static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
static gint installation_run (Installation* self, gchar** command, int command_length1);
gboolean installation_get_advancedMode (Installation* self);
const gchar* installation_get_steps (Installation* self);
GType device_get_type (void) G_GNUC_CONST;
Device* device_new_from_name (const gchar* s);
Device* device_construct_from_name (GType object_type, const gchar* s);
GQuark device_error_quark (void);
gint device_create_partition (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, const gchar* type, const gchar* mount, GError** error);
void installation_set_root (Installation* self, const gchar* value);
gint device_delete_partition (Device* self, gint index, GError** error);
const gchar* installation_get_root (Installation* self);
const gchar* installation_get_home (Installation* self);
GeeArrayList* parted_get_devices (gboolean from_cache);
GType device_partition_get_type (void) G_GNUC_CONST;
GeeArrayList* device_get_partitions (Device* self);
gint installation_get_partition (Installation* self);
gchar* device_get_path (Device* self);
GType device_partition_type_get_type (void) G_GNUC_CONST;
DevicePartitionType device_partition_get_ptype (DevicePartition* self);
GeeArrayList* swap_collector_get_partitions (void);
guint64 device_partition_get_size (DevicePartition* self);
gint device_create_partition_simple (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, guint64 swap_size, GError** error);
guint64 device_partition_get_start (DevicePartition* self);
guint64 device_partition_get_end (DevicePartition* self);
gint device_partition_get_number (DevicePartition* self);
void utils_write_simple_file (const gchar* path, const gchar* content);
static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
const gchar* installation_get_user_name (Installation* self);
const gchar* installation_get_password (Installation* self);
gboolean installation_get_autologin (Installation* self);
const gchar* installation_get_full_name (Installation* self);
const gchar* installation_get_host_name (Installation* self);
void swap_collector_reset (void);
static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition);
static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix);
static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition);
static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self);
static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
const gchar* installation_get_description (Installation* self);
gint installation_get_progress (Installation* self);
void installation_setup_js_class (void* context);
Installation* installation_new (void);
Installation* installation_construct (GType object_type);
const gchar* installation_get_grub_device (Installation* self);
const gchar* installation_get_language (Installation* self);
const gchar* installation_get_region (Installation* self);
const gchar* installation_get_keyboard (Installation* self);
static void installation_finalize (GObject* obj);
static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType installer_get_type (void) G_GNUC_CONST;
#define INSTALLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLER, InstallerPrivate))
enum  {
	INSTALLER_DUMMY_PROPERTY
};
static gchar* installer_translate_uri (Installer* self, const gchar* old);
static gchar* installer_translate_install (Installer* self, const gchar* uri);
static gchar* installer_translate_theme (Installer* self, const gchar* old);
gchar* utils_get_icon_path (const gchar* name, gint size);
Installer* installer_new (void);
Installer* installer_construct (GType object_type);
static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView);
static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self);
static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response);
static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self);
static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context);
void utils_setup_js_class (void* context);
void parted_setup_js_class (void* context);
static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
void installer_start (Installer* self);
static void installer_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const JSStaticFunction INSTALLATION_js_funcs[7] = {{"shutdown", _installation_js_shutdown_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"reboot", _installation_js_reboot_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"translate", _installation_js_translate_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setLocale", _installation_js_set_locale_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setTimezone", _installation_js_set_timezone_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"getLocaleList", _installation_js_get_locale_list_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {NULL, NULL, 0}};
static const JSClassDefinition INSTALLATION_js_class = {0, kJSClassAttributeNone, "Installation", NULL, NULL, INSTALLATION_js_funcs, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, _installation_js_constructor_js_core_object_call_as_constructor_callback, NULL, NULL};

Log* log_construct (GType object_type) {
	Log * self = NULL;
	GError * _inner_error_ = NULL;
	self = (Log*) g_object_new (object_type, NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		GFileOutputStream* _tmp4_ = NULL;
		GFile* _tmp5_ = NULL;
		GFileOutputStream* _tmp6_ = NULL;
		GDataOutputStream* _tmp7_ = NULL;
		_tmp0_ = g_file_new_for_path ("/var/log/blankon-installer.log");
		file = _tmp0_;
		_tmp1_ = file;
		_tmp2_ = g_file_query_exists (_tmp1_, NULL);
		if (_tmp2_) {
			GFile* _tmp3_ = NULL;
			_tmp3_ = file;
			g_file_delete (_tmp3_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
		}
		_tmp5_ = file;
		_tmp6_ = g_file_create (_tmp5_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp4_ = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp7_ = g_data_output_stream_new ((GOutputStream*) _tmp4_);
		_g_object_unref0 (self->priv->stream);
		self->priv->stream = _tmp7_;
		_g_object_unref0 (_tmp4_);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp8_ = NULL;
		GError* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "%s\n", _tmp10_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Log* log_new (void) {
	return log_construct (TYPE_LOG);
}


void log_log_without_newline (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void log_log (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GDataOutputStream* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = self->priv->stream;
	g_data_output_stream_put_string (_tmp2_, "\n", NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Log* log_instance (void) {
	Log* result = NULL;
	Log* _tmp0_ = NULL;
	Log* _tmp2_ = NULL;
	Log* _tmp3_ = NULL;
	_tmp0_ = log__instance;
	if (_tmp0_ == NULL) {
		Log* _tmp1_ = NULL;
		_tmp1_ = log_new ();
		_g_object_unref0 (log__instance);
		log__instance = _tmp1_;
	}
	_tmp2_ = log__instance;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static void log_class_init (LogClass * klass) {
	log_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LogPrivate));
	G_OBJECT_CLASS (klass)->finalize = log_finalize;
}


static void log_instance_init (Log * self) {
	self->priv = LOG_GET_PRIVATE (self);
}


static void log_finalize (GObject* obj) {
	Log * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOG, Log);
	_g_object_unref0 (self->priv->stream);
	G_OBJECT_CLASS (log_parent_class)->finalize (obj);
}


GType log_get_type (void) {
	static volatile gsize log_type_id__volatile = 0;
	if (g_once_init_enter (&log_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) log_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Log), 0, (GInstanceInitFunc) log_instance_init, NULL };
		GType log_type_id;
		log_type_id = g_type_register_static (G_TYPE_OBJECT, "Log", &g_define_type_info, 0);
		g_once_init_leave (&log_type_id__volatile, log_type_id);
	}
	return log_type_id__volatile;
}


GType installation_state_get_type (void) {
	static volatile gsize installation_state_type_id__volatile = 0;
	if (g_once_init_enter (&installation_state_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STATE_NOT_STARTED, "INSTALLATION_STATE_NOT_STARTED", "not-started"}, {INSTALLATION_STATE_ON_GOING, "INSTALLATION_STATE_ON_GOING", "on-going"}, {INSTALLATION_STATE_ERROR, "INSTALLATION_STATE_ERROR", "error"}, {INSTALLATION_STATE_DONE, "INSTALLATION_STATE_DONE", "done"}, {0, NULL, NULL}};
		GType installation_state_type_id;
		installation_state_type_id = g_enum_register_static ("InstallationState", values);
		g_once_init_leave (&installation_state_type_id__volatile, installation_state_type_id);
	}
	return installation_state_type_id__volatile;
}


static GType installation_step_get_type (void) {
	static volatile gsize installation_step_type_id__volatile = 0;
	if (g_once_init_enter (&installation_step_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STEP_IDLE, "INSTALLATION_STEP_IDLE", "idle"}, {INSTALLATION_STEP_PARTITION, "INSTALLATION_STEP_PARTITION", "partition"}, {INSTALLATION_STEP_FS, "INSTALLATION_STEP_FS", "fs"}, {INSTALLATION_STEP_MOUNT, "INSTALLATION_STEP_MOUNT", "mount"}, {INSTALLATION_STEP_MOUNTHOME, "INSTALLATION_STEP_MOUNTHOME", "mounthome"}, {INSTALLATION_STEP_COPY, "INSTALLATION_STEP_COPY", "copy"}, {INSTALLATION_STEP_SETUP, "INSTALLATION_STEP_SETUP", "setup"}, {INSTALLATION_STEP_GRUB, "INSTALLATION_STEP_GRUB", "grub"}, {INSTALLATION_STEP_CLEANUP, "INSTALLATION_STEP_CLEANUP", "cleanup"}, {INSTALLATION_STEP_DONE, "INSTALLATION_STEP_DONE", "done"}, {0, NULL, NULL}};
		GType installation_step_type_id;
		installation_step_type_id = g_enum_register_static ("InstallationStep", values);
		g_once_init_leave (&installation_step_type_id__volatile, installation_step_type_id);
	}
	return installation_step_type_id__volatile;
}


static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_shutdown (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_reboot (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_translate (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_locale (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_timezone (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_locale_list (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_constructor (ctx, constructor, arguments, arguments_length1, exception);
	return result;
}


static void __lambda7_ (Installation* self) {
	installation_real_start (self);
}


static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self) {
	__lambda7_ ((Installation*) self);
}


static guint64 uint64_parse (const gchar* str) {
	guint64 result = 0ULL;
	const gchar* _tmp0_ = NULL;
	guint64 _tmp1_ = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoull (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


Installation* installation_construct_from_string (GType object_type, const gchar* uri) {
	Installation * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	self = (Installation*) g_object_new (object_type, NULL);
	installation_set_progress (self, 0);
	installation_set_state (self, (gint) INSTALLATION_STATE_NOT_STARTED);
	installation_set_description (self, "");
	installation_set_autologin (self, FALSE);
	_tmp0_ = uri;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "&", 0);
	{
		gchar** param_collection = NULL;
		gint param_collection_length1 = 0;
		gint _param_collection_size_ = 0;
		gint param_it = 0;
		param_collection = _tmp2_;
		param_collection_length1 = _vala_array_length (_tmp1_);
		for (param_it = 0; param_it < _vala_array_length (_tmp1_); param_it = param_it + 1) {
			gchar* _tmp3_ = NULL;
			gchar* param = NULL;
			_tmp3_ = g_strdup (param_collection[param_it]);
			param = _tmp3_;
			{
				gchar** entry = NULL;
				const gchar* _tmp4_ = NULL;
				gchar** _tmp5_ = NULL;
				gchar** _tmp6_ = NULL;
				gint entry_length1 = 0;
				gint _entry_size_ = 0;
				gchar** _tmp7_ = NULL;
				gint _tmp7__length1 = 0;
				_tmp4_ = param;
				_tmp6_ = _tmp5_ = g_strsplit (_tmp4_, "=", 0);
				entry = _tmp6_;
				entry_length1 = _vala_array_length (_tmp5_);
				_entry_size_ = entry_length1;
				_tmp7_ = entry;
				_tmp7__length1 = entry_length1;
				if (_tmp7__length1 == 2) {
					gchar** _tmp8_ = NULL;
					gint _tmp8__length1 = 0;
					const gchar* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					GQuark _tmp12_ = 0U;
					static GQuark _tmp11_label0 = 0;
					static GQuark _tmp11_label1 = 0;
					static GQuark _tmp11_label2 = 0;
					static GQuark _tmp11_label3 = 0;
					static GQuark _tmp11_label4 = 0;
					static GQuark _tmp11_label5 = 0;
					static GQuark _tmp11_label6 = 0;
					static GQuark _tmp11_label7 = 0;
					static GQuark _tmp11_label8 = 0;
					static GQuark _tmp11_label9 = 0;
					static GQuark _tmp11_label10 = 0;
					static GQuark _tmp11_label11 = 0;
					static GQuark _tmp11_label12 = 0;
					static GQuark _tmp11_label13 = 0;
					static GQuark _tmp11_label14 = 0;
					_tmp8_ = entry;
					_tmp8__length1 = entry_length1;
					_tmp9_ = _tmp8_[0];
					_tmp10_ = _tmp9_;
					_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
					if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("device")))) {
						switch (0) {
							default:
							{
								gchar** _tmp13_ = NULL;
								gint _tmp13__length1 = 0;
								const gchar* _tmp14_ = NULL;
								gint _tmp15_ = 0;
								Log* _tmp16_ = NULL;
								Log* _tmp17_ = NULL;
								gint _tmp18_ = 0;
								gchar* _tmp19_ = NULL;
								gchar* _tmp20_ = NULL;
								gchar* _tmp21_ = NULL;
								gchar* _tmp22_ = NULL;
								_tmp13_ = entry;
								_tmp13__length1 = entry_length1;
								_tmp14_ = _tmp13_[1];
								_tmp15_ = atoi (_tmp14_);
								installation_set_device (self, _tmp15_);
								_tmp16_ = log_instance ();
								_tmp17_ = _tmp16_;
								_tmp18_ = self->priv->_device;
								_tmp19_ = g_strdup_printf ("%i", _tmp18_);
								_tmp20_ = _tmp19_;
								_tmp21_ = g_strconcat ("Selected Drive : ", _tmp20_, NULL);
								_tmp22_ = _tmp21_;
								log_log (_tmp17_, _tmp22_);
								_g_free0 (_tmp22_);
								_g_free0 (_tmp20_);
								_g_object_unref0 (_tmp17_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("device_path")))) {
						switch (0) {
							default:
							{
								gchar** _tmp23_ = NULL;
								gint _tmp23__length1 = 0;
								const gchar* _tmp24_ = NULL;
								gchar* _tmp25_ = NULL;
								_tmp23_ = entry;
								_tmp23__length1 = entry_length1;
								_tmp24_ = _tmp23_[1];
								_tmp25_ = g_strdup (_tmp24_);
								_g_free0 (self->priv->device_path);
								self->priv->device_path = _tmp25_;
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("partition")))) {
						switch (0) {
							default:
							{
								gchar** _tmp26_ = NULL;
								gint _tmp26__length1 = 0;
								const gchar* _tmp27_ = NULL;
								gint _tmp28_ = 0;
								_tmp26_ = entry;
								_tmp26__length1 = entry_length1;
								_tmp27_ = _tmp26_[1];
								_tmp28_ = atoi (_tmp27_);
								installation_set_partition (self, _tmp28_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label3) ? _tmp11_label3 : (_tmp11_label3 = g_quark_from_static_string ("username")))) {
						switch (0) {
							default:
							{
								gchar** _tmp29_ = NULL;
								gint _tmp29__length1 = 0;
								const gchar* _tmp30_ = NULL;
								_tmp29_ = entry;
								_tmp29__length1 = entry_length1;
								_tmp30_ = _tmp29_[1];
								installation_set_user_name (self, _tmp30_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label4) ? _tmp11_label4 : (_tmp11_label4 = g_quark_from_static_string ("password")))) {
						switch (0) {
							default:
							{
								gchar** _tmp31_ = NULL;
								gint _tmp31__length1 = 0;
								const gchar* _tmp32_ = NULL;
								_tmp31_ = entry;
								_tmp31__length1 = entry_length1;
								_tmp32_ = _tmp31_[1];
								installation_set_password (self, _tmp32_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label5) ? _tmp11_label5 : (_tmp11_label5 = g_quark_from_static_string ("hostname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp33_ = NULL;
								gint _tmp33__length1 = 0;
								const gchar* _tmp34_ = NULL;
								_tmp33_ = entry;
								_tmp33__length1 = entry_length1;
								_tmp34_ = _tmp33_[1];
								installation_set_host_name (self, _tmp34_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label6) ? _tmp11_label6 : (_tmp11_label6 = g_quark_from_static_string ("fullname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp35_ = NULL;
								gint _tmp35__length1 = 0;
								const gchar* _tmp36_ = NULL;
								_tmp35_ = entry;
								_tmp35__length1 = entry_length1;
								_tmp36_ = _tmp35_[1];
								installation_set_full_name (self, _tmp36_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label7) ? _tmp11_label7 : (_tmp11_label7 = g_quark_from_static_string ("grubdevice")))) {
						switch (0) {
							default:
							{
								gchar** _tmp37_ = NULL;
								gint _tmp37__length1 = 0;
								const gchar* _tmp38_ = NULL;
								_tmp37_ = entry;
								_tmp37__length1 = entry_length1;
								_tmp38_ = _tmp37_[1];
								installation_set_grub_device (self, _tmp38_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label8) ? _tmp11_label8 : (_tmp11_label8 = g_quark_from_static_string ("language")))) {
						switch (0) {
							default:
							{
								gchar** _tmp39_ = NULL;
								gint _tmp39__length1 = 0;
								const gchar* _tmp40_ = NULL;
								_tmp39_ = entry;
								_tmp39__length1 = entry_length1;
								_tmp40_ = _tmp39_[1];
								installation_set_language (self, _tmp40_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label9) ? _tmp11_label9 : (_tmp11_label9 = g_quark_from_static_string ("region")))) {
						switch (0) {
							default:
							{
								gchar** _tmp41_ = NULL;
								gint _tmp41__length1 = 0;
								const gchar* _tmp42_ = NULL;
								_tmp41_ = entry;
								_tmp41__length1 = entry_length1;
								_tmp42_ = _tmp41_[1];
								installation_set_region (self, _tmp42_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label10) ? _tmp11_label10 : (_tmp11_label10 = g_quark_from_static_string ("keyboard")))) {
						switch (0) {
							default:
							{
								gchar** _tmp43_ = NULL;
								gint _tmp43__length1 = 0;
								const gchar* _tmp44_ = NULL;
								_tmp43_ = entry;
								_tmp43__length1 = entry_length1;
								_tmp44_ = _tmp43_[1];
								installation_set_keyboard (self, _tmp44_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label11) ? _tmp11_label11 : (_tmp11_label11 = g_quark_from_static_string ("autologin")))) {
						switch (0) {
							default:
							{
								gchar** _tmp45_ = NULL;
								gint _tmp45__length1 = 0;
								const gchar* _tmp46_ = NULL;
								_tmp45_ = entry;
								_tmp45__length1 = entry_length1;
								_tmp46_ = _tmp45_[1];
								installation_set_autologin (self, g_strcmp0 (_tmp46_, "true") == 0);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label12) ? _tmp11_label12 : (_tmp11_label12 = g_quark_from_static_string ("home")))) {
						switch (0) {
							default:
							{
								gchar** _tmp47_ = NULL;
								gint _tmp47__length1 = 0;
								const gchar* _tmp48_ = NULL;
								_tmp47_ = entry;
								_tmp47__length1 = entry_length1;
								_tmp48_ = _tmp47_[1];
								installation_set_home (self, _tmp48_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label13) ? _tmp11_label13 : (_tmp11_label13 = g_quark_from_static_string ("advancedMode")))) {
						switch (0) {
							default:
							{
								gchar** _tmp49_ = NULL;
								gint _tmp49__length1 = 0;
								const gchar* _tmp50_ = NULL;
								_tmp49_ = entry;
								_tmp49__length1 = entry_length1;
								_tmp50_ = _tmp49_[1];
								installation_set_advancedMode (self, g_strcmp0 (_tmp50_, "true") == 0);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label14) ? _tmp11_label14 : (_tmp11_label14 = g_quark_from_static_string ("steps")))) {
						switch (0) {
							default:
							{
								gchar** _tmp51_ = NULL;
								gint _tmp51__length1 = 0;
								const gchar* _tmp52_ = NULL;
								_tmp51_ = entry;
								_tmp51__length1 = entry_length1;
								_tmp52_ = _tmp51_[1];
								installation_set_steps (self, _tmp52_);
								break;
							}
						}
					}
				}
				entry = (_vala_array_free (entry, entry_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (param);
			}
		}
		param_collection = (_vala_array_free (param_collection, param_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	g_signal_connect_object (self, "installation-started", (GCallback) ___lambda7__installation_installation_started, self, 0);
	self->priv->installation_size = 4 * INSTALLATION_OneGig;
	{
		GFile* file = NULL;
		GFile* _tmp53_ = NULL;
		GFile* _tmp54_ = NULL;
		gboolean _tmp55_ = FALSE;
		_tmp53_ = g_file_new_for_path ("/live/image/.disk/installation_size");
		file = _tmp53_;
		_tmp54_ = file;
		_tmp55_ = g_file_query_exists (_tmp54_, NULL);
		if (_tmp55_) {
			GFileInputStream* _tmp56_ = NULL;
			GFile* _tmp57_ = NULL;
			GFileInputStream* _tmp58_ = NULL;
			GDataInputStream* dis = NULL;
			GDataInputStream* _tmp59_ = NULL;
			gsize l = 0UL;
			gchar* line = NULL;
			GDataInputStream* _tmp60_ = NULL;
			gsize _tmp61_ = 0UL;
			gchar* _tmp62_ = NULL;
			GDataInputStream* _tmp63_ = NULL;
			const gchar* _tmp64_ = NULL;
			_tmp57_ = file;
			_tmp58_ = g_file_read (_tmp57_, NULL, &_inner_error_);
			_tmp56_ = _tmp58_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp59_ = g_data_input_stream_new ((GInputStream*) _tmp56_);
			dis = _tmp59_;
			_tmp60_ = dis;
			_tmp62_ = g_data_input_stream_read_line (_tmp60_, &_tmp61_, NULL, &_inner_error_);
			l = _tmp61_;
			line = _tmp62_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp56_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp63_ = dis;
			g_input_stream_close ((GInputStream*) _tmp63_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp56_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp64_ = line;
			if (_tmp64_ != NULL) {
				const gchar* _tmp65_ = NULL;
				guint64 _tmp66_ = 0ULL;
				guint64 _tmp67_ = 0ULL;
				_tmp65_ = line;
				_tmp66_ = uint64_parse (_tmp65_);
				self->priv->installation_size = _tmp66_;
				_tmp67_ = self->priv->installation_size;
				if (_tmp67_ <= ((guint64) 0)) {
					self->priv->installation_size = 4 * INSTALLATION_OneGig;
				}
			}
			_g_free0 (line);
			_g_object_unref0 (dis);
			_g_object_unref0 (_tmp56_);
		}
		_g_object_unref0 (file);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp68_ = NULL;
		GError* _tmp69_ = NULL;
		const gchar* _tmp70_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp68_ = stderr;
		_tmp69_ = e;
		_tmp70_ = _tmp69_->message;
		fprintf (_tmp68_, "%s\n", _tmp70_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Installation* installation_new_from_string (const gchar* uri) {
	return installation_construct_from_string (TYPE_INSTALLATION, uri);
}


void installation_start (Installation* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "installation-started");
}


static void installation_real_start (Installation* self) {
	Log* _tmp0_ = NULL;
	Log* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = log_instance ();
	_tmp1_ = _tmp0_;
	log_log (_tmp1_, "START");
	_g_object_unref0 (_tmp1_);
	installation_set_state (self, (gint) INSTALLATION_STATE_ON_GOING);
	installation_do_next_job (self);
}


static void installation_do_next_job (Installation* self) {
	InstallationStep _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->last_step;
	switch (_tmp0_) {
		case INSTALLATION_STEP_IDLE:
		{
			Log* _tmp1_ = NULL;
			Log* _tmp2_ = NULL;
			installation_set_progress (self, 5);
			_tmp1_ = log_instance ();
			_tmp2_ = _tmp1_;
			log_log (_tmp2_, "PARTITION");
			_g_object_unref0 (_tmp2_);
			installation_do_partition (self);
			break;
		}
		case INSTALLATION_STEP_PARTITION:
		{
			Log* _tmp3_ = NULL;
			Log* _tmp4_ = NULL;
			installation_set_progress (self, 10);
			_tmp3_ = log_instance ();
			_tmp4_ = _tmp3_;
			log_log (_tmp4_, "FS");
			_g_object_unref0 (_tmp4_);
			installation_do_fs (self);
			break;
		}
		case INSTALLATION_STEP_FS:
		{
			Log* _tmp5_ = NULL;
			Log* _tmp6_ = NULL;
			_tmp5_ = log_instance ();
			_tmp6_ = _tmp5_;
			log_log (_tmp6_, "MOUNT");
			_g_object_unref0 (_tmp6_);
			installation_do_mount (self);
			break;
		}
		case INSTALLATION_STEP_MOUNT:
		{
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			log_log (_tmp8_, "MOUNTHOME");
			_g_object_unref0 (_tmp8_);
			installation_do_mount_home (self);
			break;
		}
		case INSTALLATION_STEP_MOUNTHOME:
		{
			Log* _tmp9_ = NULL;
			Log* _tmp10_ = NULL;
			installation_set_progress (self, 15);
			_tmp9_ = log_instance ();
			_tmp10_ = _tmp9_;
			log_log (_tmp10_, "COPY");
			_g_object_unref0 (_tmp10_);
			installation_do_copy (self);
			break;
		}
		case INSTALLATION_STEP_COPY:
		{
			Log* _tmp11_ = NULL;
			Log* _tmp12_ = NULL;
			installation_set_progress (self, 80);
			_tmp11_ = log_instance ();
			_tmp12_ = _tmp11_;
			log_log (_tmp12_, "SETUP");
			_g_object_unref0 (_tmp12_);
			installation_do_setup (self);
			break;
		}
		case INSTALLATION_STEP_SETUP:
		{
			Log* _tmp13_ = NULL;
			Log* _tmp14_ = NULL;
			installation_set_progress (self, 90);
			_tmp13_ = log_instance ();
			_tmp14_ = _tmp13_;
			log_log (_tmp14_, "GRUB");
			_g_object_unref0 (_tmp14_);
			installation_do_grub (self);
			break;
		}
		case INSTALLATION_STEP_GRUB:
		{
			Log* _tmp15_ = NULL;
			Log* _tmp16_ = NULL;
			_tmp15_ = log_instance ();
			_tmp16_ = _tmp15_;
			log_log (_tmp16_, "CLEANUP");
			_g_object_unref0 (_tmp16_);
			installation_do_cleanup (self);
			break;
		}
		case INSTALLATION_STEP_CLEANUP:
		{
			Log* _tmp17_ = NULL;
			Log* _tmp18_ = NULL;
			installation_set_progress (self, 100);
			_tmp17_ = log_instance ();
			_tmp18_ = _tmp17_;
			log_log (_tmp18_, "DONE");
			_g_object_unref0 (_tmp18_);
			installation_do_done (self);
			break;
		}
		case INSTALLATION_STEP_DONE:
		{
			gint _tmp19_ = 0;
			_tmp19_ = self->priv->_state;
			if (_tmp19_ != ((gint) INSTALLATION_STATE_ERROR)) {
				Log* _tmp20_ = NULL;
				Log* _tmp21_ = NULL;
				_tmp20_ = log_instance ();
				_tmp21_ = _tmp20_;
				log_log (_tmp21_, "ERROR");
				_g_object_unref0 (_tmp21_);
				installation_set_description (self, "Done");
			} else {
				Log* _tmp22_ = NULL;
				Log* _tmp23_ = NULL;
				_tmp22_ = log_instance ();
				_tmp23_ = _tmp22_;
				log_log (_tmp23_, "DONE");
				_g_object_unref0 (_tmp23_);
			}
			break;
		}
		default:
		break;
	}
}


static void installation_child_watch (Installation* self, GPid pid, gint status) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = status;
	_tmp2_ = WIFEXITED (_tmp1_);
	if (_tmp2_) {
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		_tmp3_ = status;
		_tmp4_ = WEXITSTATUS (_tmp3_);
		_tmp0_ = _tmp4_ == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp5_ = status;
		_tmp6_ = WEXITSTATUS (_tmp5_);
		if (_tmp6_ == 0) {
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			GPid _tmp9_ = 0;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			InstallationStep _tmp16_ = 0;
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			_tmp9_ = pid;
			_tmp10_ = g_strdup_printf ("%i", (gint) _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = g_strconcat ("Child ", _tmp11_, NULL);
			_tmp13_ = _tmp12_;
			_tmp14_ = g_strconcat (_tmp13_, " has finished it's task successfuly.", NULL);
			_tmp15_ = _tmp14_;
			log_log (_tmp8_, _tmp15_);
			_g_free0 (_tmp15_);
			_g_free0 (_tmp13_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp8_);
			_tmp16_ = self->priv->step;
			self->priv->last_step = _tmp16_;
			self->priv->step = INSTALLATION_STEP_IDLE;
		} else {
			Log* _tmp17_ = NULL;
			Log* _tmp18_ = NULL;
			GPid _tmp19_ = 0;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			gint _tmp26_ = 0;
			gint _tmp27_ = 0;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			_tmp17_ = log_instance ();
			_tmp18_ = _tmp17_;
			_tmp19_ = pid;
			_tmp20_ = g_strdup_printf ("%i", (gint) _tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat ("Child ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strconcat (_tmp23_, " has ended and return with ", NULL);
			_tmp25_ = _tmp24_;
			_tmp26_ = status;
			_tmp27_ = WEXITSTATUS (_tmp26_);
			_tmp28_ = g_strdup_printf ("%i", _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = g_strconcat (_tmp25_, _tmp29_, NULL);
			_tmp31_ = _tmp30_;
			log_log (_tmp18_, _tmp31_);
			_g_free0 (_tmp31_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp25_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
			_g_object_unref0 (_tmp18_);
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
		}
	} else {
		Log* _tmp32_ = NULL;
		Log* _tmp33_ = NULL;
		GPid _tmp34_ = 0;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		_tmp32_ = log_instance ();
		_tmp33_ = _tmp32_;
		_tmp34_ = pid;
		_tmp35_ = g_strdup_printf ("%i", (gint) _tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = g_strconcat ("Child ", _tmp36_, NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_strconcat (_tmp38_, " has ended and failed.", NULL);
		_tmp40_ = _tmp39_;
		log_log (_tmp33_, _tmp40_);
		_g_free0 (_tmp40_);
		_g_free0 (_tmp38_);
		_g_free0 (_tmp36_);
		_g_object_unref0 (_tmp33_);
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
	}
	installation_do_next_job (self);
}


static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gint pid = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	pid = 0;
	_tmp0_ = commands_to_run;
	_tmp0__length1 = commands_to_run_length1;
	_tmp1_ = installation_run (self, _tmp0_, _tmp0__length1);
	pid = _tmp1_;
	_tmp2_ = pid;
	if (_tmp2_ != 0) {
		InstallationStep _tmp3_ = 0;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = command_step;
		self->priv->step = _tmp3_;
		_tmp4_ = command_description;
		installation_set_description (self, _tmp4_);
	} else {
		const gchar* _tmp5_ = NULL;
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		_tmp5_ = error_description;
		installation_set_description (self, _tmp5_);
	}
}


static void installation_do_partition (Installation* self) {
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_advancedMode;
	if (_tmp0_ == TRUE) {
		gboolean can_continue = FALSE;
		Log* _tmp1_ = NULL;
		Log* _tmp2_ = NULL;
		Log* _tmp3_ = NULL;
		Log* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gchar** stepsArray = NULL;
		const gchar* _tmp6_ = NULL;
		gchar** _tmp7_ = NULL;
		gchar** _tmp8_ = NULL;
		gint stepsArray_length1 = 0;
		gint _stepsArray_size_ = 0;
		gchar** _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		const gchar* _tmp173_ = NULL;
		const gchar* _tmp174_ = NULL;
		gchar* _tmp175_ = NULL;
		Log* _tmp176_ = NULL;
		Log* _tmp177_ = NULL;
		const gchar* _tmp178_ = NULL;
		gchar* _tmp179_ = NULL;
		gchar* _tmp180_ = NULL;
		gchar* _tmp181_ = NULL;
		gchar* _tmp182_ = NULL;
		gboolean _tmp183_ = FALSE;
		installation_set_description (self, "Partitioning");
		self->priv->step = INSTALLATION_STEP_PARTITION;
		can_continue = FALSE;
		_tmp1_ = log_instance ();
		_tmp2_ = _tmp1_;
		log_log (_tmp2_, "Enter advanced partitioning ");
		_g_object_unref0 (_tmp2_);
		_tmp3_ = log_instance ();
		_tmp4_ = _tmp3_;
		_tmp5_ = self->priv->_steps;
		log_log (_tmp4_, _tmp5_);
		_g_object_unref0 (_tmp4_);
		_tmp6_ = self->priv->_steps;
		_tmp8_ = _tmp7_ = g_strsplit (_tmp6_, ",", 0);
		stepsArray = _tmp8_;
		stepsArray_length1 = _vala_array_length (_tmp7_);
		_stepsArray_size_ = stepsArray_length1;
		_tmp9_ = stepsArray;
		_tmp9__length1 = stepsArray_length1;
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
			s_collection = _tmp9_;
			s_collection_length1 = _tmp9__length1;
			for (s_it = 0; s_it < _tmp9__length1; s_it = s_it + 1) {
				gchar* _tmp10_ = NULL;
				gchar* s = NULL;
				_tmp10_ = g_strdup (s_collection[s_it]);
				s = _tmp10_;
				{
					gchar** splittedParams = NULL;
					const gchar* _tmp11_ = NULL;
					gchar** _tmp12_ = NULL;
					gchar** _tmp13_ = NULL;
					gint splittedParams_length1 = 0;
					gint _splittedParams_size_ = 0;
					Log* _tmp14_ = NULL;
					Log* _tmp15_ = NULL;
					gchar** _tmp16_ = NULL;
					gint _tmp16__length1 = 0;
					const gchar* _tmp17_ = NULL;
					gchar** _tmp18_ = NULL;
					gint _tmp18__length1 = 0;
					const gchar* _tmp19_ = NULL;
					const gchar* _tmp20_ = NULL;
					GQuark _tmp22_ = 0U;
					static GQuark _tmp21_label0 = 0;
					static GQuark _tmp21_label1 = 0;
					static GQuark _tmp21_label2 = 0;
					static GQuark _tmp21_label3 = 0;
					_tmp11_ = s;
					_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, ";", 0);
					splittedParams = _tmp13_;
					splittedParams_length1 = _vala_array_length (_tmp12_);
					_splittedParams_size_ = splittedParams_length1;
					_tmp14_ = log_instance ();
					_tmp15_ = _tmp14_;
					_tmp16_ = splittedParams;
					_tmp16__length1 = splittedParams_length1;
					_tmp17_ = _tmp16_[0];
					log_log (_tmp15_, _tmp17_);
					_g_object_unref0 (_tmp15_);
					_tmp18_ = splittedParams;
					_tmp18__length1 = splittedParams_length1;
					_tmp19_ = _tmp18_[0];
					_tmp20_ = _tmp19_;
					_tmp22_ = (NULL == _tmp20_) ? 0 : g_quark_from_string (_tmp20_);
					if (_tmp22_ == ((0 != _tmp21_label0) ? _tmp21_label0 : (_tmp21_label0 = g_quark_from_static_string ("create")))) {
						switch (0) {
							default:
							{
								Device* dev = NULL;
								const gchar* _tmp23_ = NULL;
								Device* _tmp24_ = NULL;
								gchar** range = NULL;
								gchar** _tmp25_ = NULL;
								gint _tmp25__length1 = 0;
								const gchar* _tmp26_ = NULL;
								gchar** _tmp27_ = NULL;
								gchar** _tmp28_ = NULL;
								gint range_length1 = 0;
								gint _range_size_ = 0;
								Log* _tmp29_ = NULL;
								Log* _tmp30_ = NULL;
								gchar** _tmp31_ = NULL;
								gint _tmp31__length1 = 0;
								const gchar* _tmp32_ = NULL;
								gchar* _tmp33_ = NULL;
								gchar* _tmp34_ = NULL;
								Log* _tmp35_ = NULL;
								Log* _tmp36_ = NULL;
								gchar** _tmp37_ = NULL;
								gint _tmp37__length1 = 0;
								const gchar* _tmp38_ = NULL;
								gchar* _tmp39_ = NULL;
								gchar* _tmp40_ = NULL;
								gchar* mount = NULL;
								gchar* _tmp41_ = NULL;
								gboolean _tmp42_ = FALSE;
								gchar** _tmp43_ = NULL;
								gint _tmp43__length1 = 0;
								const gchar* _tmp44_ = NULL;
								gint new_partition = 0;
								Device* _tmp50_ = NULL;
								gchar** _tmp51_ = NULL;
								gint _tmp51__length1 = 0;
								const gchar* _tmp52_ = NULL;
								guint64 _tmp53_ = 0ULL;
								gchar** _tmp54_ = NULL;
								gint _tmp54__length1 = 0;
								const gchar* _tmp55_ = NULL;
								guint64 _tmp56_ = 0ULL;
								gchar** _tmp57_ = NULL;
								gint _tmp57__length1 = 0;
								const gchar* _tmp58_ = NULL;
								gchar** _tmp59_ = NULL;
								gint _tmp59__length1 = 0;
								const gchar* _tmp60_ = NULL;
								const gchar* _tmp61_ = NULL;
								gint _tmp62_ = 0;
								gchar** _tmp63_ = NULL;
								gint _tmp63__length1 = 0;
								const gchar* _tmp64_ = NULL;
								Log* _tmp107_ = NULL;
								Log* _tmp108_ = NULL;
								gint _tmp109_ = 0;
								gchar* _tmp110_ = NULL;
								gchar* _tmp111_ = NULL;
								gchar* _tmp112_ = NULL;
								gchar* _tmp113_ = NULL;
								_tmp23_ = self->priv->device_path;
								_tmp24_ = device_new_from_name (_tmp23_);
								dev = _tmp24_;
								_tmp25_ = splittedParams;
								_tmp25__length1 = splittedParams_length1;
								_tmp26_ = _tmp25_[3];
								_tmp28_ = _tmp27_ = g_strsplit (_tmp26_, "-", 0);
								range = _tmp28_;
								range_length1 = _vala_array_length (_tmp27_);
								_range_size_ = range_length1;
								_tmp29_ = log_instance ();
								_tmp30_ = _tmp29_;
								_tmp31_ = range;
								_tmp31__length1 = range_length1;
								_tmp32_ = _tmp31_[0];
								_tmp33_ = g_strconcat ("range_start :", _tmp32_, NULL);
								_tmp34_ = _tmp33_;
								log_log (_tmp30_, _tmp34_);
								_g_free0 (_tmp34_);
								_g_object_unref0 (_tmp30_);
								_tmp35_ = log_instance ();
								_tmp36_ = _tmp35_;
								_tmp37_ = range;
								_tmp37__length1 = range_length1;
								_tmp38_ = _tmp37_[1];
								_tmp39_ = g_strconcat ("range_start :", _tmp38_, NULL);
								_tmp40_ = _tmp39_;
								log_log (_tmp36_, _tmp40_);
								_g_free0 (_tmp40_);
								_g_object_unref0 (_tmp36_);
								_tmp41_ = g_strdup ("none");
								mount = _tmp41_;
								_tmp43_ = splittedParams;
								_tmp43__length1 = splittedParams_length1;
								_tmp44_ = _tmp43_[4];
								if (g_strcmp0 (_tmp44_, "root") == 0) {
									_tmp42_ = TRUE;
								} else {
									gchar** _tmp45_ = NULL;
									gint _tmp45__length1 = 0;
									const gchar* _tmp46_ = NULL;
									_tmp45_ = splittedParams;
									_tmp45__length1 = splittedParams_length1;
									_tmp46_ = _tmp45_[4];
									_tmp42_ = g_strcmp0 (_tmp46_, "home") == 0;
								}
								if (_tmp42_) {
									gchar** _tmp47_ = NULL;
									gint _tmp47__length1 = 0;
									const gchar* _tmp48_ = NULL;
									gchar* _tmp49_ = NULL;
									_tmp47_ = splittedParams;
									_tmp47__length1 = splittedParams_length1;
									_tmp48_ = _tmp47_[4];
									_tmp49_ = g_strdup (_tmp48_);
									_g_free0 (mount);
									mount = _tmp49_;
								}
								_tmp50_ = dev;
								_tmp51_ = range;
								_tmp51__length1 = range_length1;
								_tmp52_ = _tmp51_[0];
								_tmp53_ = uint64_parse (_tmp52_);
								_tmp54_ = range;
								_tmp54__length1 = range_length1;
								_tmp55_ = _tmp54_[1];
								_tmp56_ = uint64_parse (_tmp55_);
								_tmp57_ = splittedParams;
								_tmp57__length1 = splittedParams_length1;
								_tmp58_ = _tmp57_[2];
								_tmp59_ = splittedParams;
								_tmp59__length1 = splittedParams_length1;
								_tmp60_ = _tmp59_[1];
								_tmp61_ = mount;
								_tmp62_ = device_create_partition (_tmp50_, _tmp53_, _tmp56_, _tmp58_, _tmp60_, _tmp61_, &_inner_error_);
								new_partition = _tmp62_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (mount);
									range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
									_g_object_unref0 (dev);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp63_ = splittedParams;
								_tmp63__length1 = splittedParams_length1;
								_tmp64_ = _tmp63_[4];
								if (g_strcmp0 (_tmp64_, "root") == 0) {
									Log* _tmp65_ = NULL;
									Log* _tmp66_ = NULL;
									gint _tmp67_ = 0;
									gchar* _tmp68_ = NULL;
									gchar* _tmp69_ = NULL;
									_tmp65_ = log_instance ();
									_tmp66_ = _tmp65_;
									log_log (_tmp66_, "root");
									_g_object_unref0 (_tmp66_);
									_tmp67_ = new_partition;
									_tmp68_ = g_strdup_printf ("%i", _tmp67_);
									_tmp69_ = _tmp68_;
									installation_set_root (self, _tmp69_);
									_g_free0 (_tmp69_);
								} else {
									gchar** _tmp70_ = NULL;
									gint _tmp70__length1 = 0;
									const gchar* _tmp71_ = NULL;
									_tmp70_ = splittedParams;
									_tmp70__length1 = splittedParams_length1;
									_tmp71_ = _tmp70_[4];
									if (g_strcmp0 (_tmp71_, "home") == 0) {
										Log* _tmp72_ = NULL;
										Log* _tmp73_ = NULL;
										gint _tmp74_ = 0;
										gchar* _tmp75_ = NULL;
										gchar* _tmp76_ = NULL;
										gchar** _tmp77_ = NULL;
										gint _tmp77__length1 = 0;
										const gchar* _tmp78_ = NULL;
										gchar* _tmp79_ = NULL;
										gchar* _tmp80_ = NULL;
										gchar* _tmp81_ = NULL;
										gchar* _tmp82_ = NULL;
										const gchar* _tmp83_ = NULL;
										gchar* _tmp84_ = NULL;
										gchar* _tmp85_ = NULL;
										gint _tmp86_ = 0;
										gchar* _tmp87_ = NULL;
										gchar* _tmp88_ = NULL;
										gchar* _tmp89_ = NULL;
										gchar* _tmp90_ = NULL;
										_tmp72_ = log_instance ();
										_tmp73_ = _tmp72_;
										log_log (_tmp73_, "home");
										_g_object_unref0 (_tmp73_);
										_tmp74_ = new_partition;
										_tmp75_ = g_strdup_printf ("%i", _tmp74_);
										_tmp76_ = _tmp75_;
										installation_set_home (self, _tmp76_);
										_g_free0 (_tmp76_);
										self->separatedHome = TRUE;
										_tmp77_ = splittedParams;
										_tmp77__length1 = splittedParams_length1;
										_tmp78_ = _tmp77_[2];
										_tmp79_ = g_strconcat ("/sbin/mkfs.", _tmp78_, NULL);
										_tmp80_ = _tmp79_;
										_tmp81_ = g_strconcat (_tmp80_, " -F ", NULL);
										_tmp82_ = _tmp81_;
										_tmp83_ = self->priv->device_path;
										_tmp84_ = g_strconcat (_tmp82_, _tmp83_, NULL);
										_tmp85_ = _tmp84_;
										_tmp86_ = new_partition;
										_tmp87_ = g_strdup_printf ("%i", _tmp86_);
										_tmp88_ = _tmp87_;
										_tmp89_ = g_strconcat (_tmp85_, _tmp88_, NULL);
										_tmp90_ = _tmp89_;
										g_spawn_command_line_sync (_tmp90_, NULL, NULL, NULL, &_inner_error_);
										_g_free0 (_tmp90_);
										_g_free0 (_tmp88_);
										_g_free0 (_tmp85_);
										_g_free0 (_tmp82_);
										_g_free0 (_tmp80_);
										if (G_UNLIKELY (_inner_error_ != NULL)) {
											_g_free0 (mount);
											range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
											_g_object_unref0 (dev);
											splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (s);
											stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return;
										}
									} else {
										Log* _tmp91_ = NULL;
										Log* _tmp92_ = NULL;
										gchar** _tmp93_ = NULL;
										gint _tmp93__length1 = 0;
										const gchar* _tmp94_ = NULL;
										gchar* _tmp95_ = NULL;
										gchar* _tmp96_ = NULL;
										gchar* _tmp97_ = NULL;
										gchar* _tmp98_ = NULL;
										const gchar* _tmp99_ = NULL;
										gchar* _tmp100_ = NULL;
										gchar* _tmp101_ = NULL;
										gint _tmp102_ = 0;
										gchar* _tmp103_ = NULL;
										gchar* _tmp104_ = NULL;
										gchar* _tmp105_ = NULL;
										gchar* _tmp106_ = NULL;
										_tmp91_ = log_instance ();
										_tmp92_ = _tmp91_;
										log_log (_tmp92_, "neither root or home");
										_g_object_unref0 (_tmp92_);
										_tmp93_ = splittedParams;
										_tmp93__length1 = splittedParams_length1;
										_tmp94_ = _tmp93_[2];
										_tmp95_ = g_strconcat ("/sbin/mkfs.", _tmp94_, NULL);
										_tmp96_ = _tmp95_;
										_tmp97_ = g_strconcat (_tmp96_, " -F ", NULL);
										_tmp98_ = _tmp97_;
										_tmp99_ = self->priv->device_path;
										_tmp100_ = g_strconcat (_tmp98_, _tmp99_, NULL);
										_tmp101_ = _tmp100_;
										_tmp102_ = new_partition;
										_tmp103_ = g_strdup_printf ("%i", _tmp102_);
										_tmp104_ = _tmp103_;
										_tmp105_ = g_strconcat (_tmp101_, _tmp104_, NULL);
										_tmp106_ = _tmp105_;
										g_spawn_command_line_sync (_tmp106_, NULL, NULL, NULL, &_inner_error_);
										_g_free0 (_tmp106_);
										_g_free0 (_tmp104_);
										_g_free0 (_tmp101_);
										_g_free0 (_tmp98_);
										_g_free0 (_tmp96_);
										if (G_UNLIKELY (_inner_error_ != NULL)) {
											_g_free0 (mount);
											range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
											_g_object_unref0 (dev);
											splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (s);
											stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return;
										}
									}
								}
								_tmp107_ = log_instance ();
								_tmp108_ = _tmp107_;
								_tmp109_ = new_partition;
								_tmp110_ = g_strdup_printf ("%i", _tmp109_);
								_tmp111_ = _tmp110_;
								_tmp112_ = g_strconcat ("newly created ", _tmp111_, NULL);
								_tmp113_ = _tmp112_;
								log_log (_tmp108_, _tmp113_);
								_g_free0 (_tmp113_);
								_g_free0 (_tmp111_);
								_g_object_unref0 (_tmp108_);
								_g_free0 (mount);
								range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
								_g_object_unref0 (dev);
								break;
							}
						}
					} else if (_tmp22_ == ((0 != _tmp21_label1) ? _tmp21_label1 : (_tmp21_label1 = g_quark_from_static_string ("format")))) {
						switch (0) {
							default:
							{
								gchar* id = NULL;
								gchar** _tmp114_ = NULL;
								gint _tmp114__length1 = 0;
								const gchar* _tmp115_ = NULL;
								gchar* _tmp116_ = NULL;
								gchar** _tmp117_ = NULL;
								gint _tmp117__length1 = 0;
								const gchar* _tmp118_ = NULL;
								gchar* _tmp119_ = NULL;
								gchar* _tmp120_ = NULL;
								gchar* _tmp121_ = NULL;
								gchar* _tmp122_ = NULL;
								const gchar* _tmp123_ = NULL;
								gchar* _tmp124_ = NULL;
								gchar* _tmp125_ = NULL;
								gchar** _tmp126_ = NULL;
								gint _tmp126__length1 = 0;
								const gchar* _tmp127_ = NULL;
								gchar* _tmp128_ = NULL;
								gchar* _tmp129_ = NULL;
								Log* _tmp130_ = NULL;
								Log* _tmp131_ = NULL;
								gchar** _tmp132_ = NULL;
								gint _tmp132__length1 = 0;
								const gchar* _tmp133_ = NULL;
								gchar* _tmp134_ = NULL;
								gchar* _tmp135_ = NULL;
								gchar** _tmp136_ = NULL;
								gint _tmp136__length1 = 0;
								const gchar* _tmp137_ = NULL;
								_tmp114_ = splittedParams;
								_tmp114__length1 = splittedParams_length1;
								_tmp115_ = _tmp114_[1];
								_tmp116_ = g_strdup (_tmp115_);
								id = _tmp116_;
								_tmp117_ = splittedParams;
								_tmp117__length1 = splittedParams_length1;
								_tmp118_ = _tmp117_[2];
								_tmp119_ = g_strconcat ("/sbin/mkfs.", _tmp118_, NULL);
								_tmp120_ = _tmp119_;
								_tmp121_ = g_strconcat (_tmp120_, " -F ", NULL);
								_tmp122_ = _tmp121_;
								_tmp123_ = self->priv->device_path;
								_tmp124_ = g_strconcat (_tmp122_, _tmp123_, NULL);
								_tmp125_ = _tmp124_;
								_tmp126_ = splittedParams;
								_tmp126__length1 = splittedParams_length1;
								_tmp127_ = _tmp126_[1];
								_tmp128_ = g_strconcat (_tmp125_, _tmp127_, NULL);
								_tmp129_ = _tmp128_;
								g_spawn_command_line_sync (_tmp129_, NULL, NULL, NULL, &_inner_error_);
								_g_free0 (_tmp129_);
								_g_free0 (_tmp125_);
								_g_free0 (_tmp122_);
								_g_free0 (_tmp120_);
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (id);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp130_ = log_instance ();
								_tmp131_ = _tmp130_;
								_tmp132_ = splittedParams;
								_tmp132__length1 = splittedParams_length1;
								_tmp133_ = _tmp132_[1];
								_tmp134_ = g_strconcat ("should format partition ", _tmp133_, NULL);
								_tmp135_ = _tmp134_;
								log_log (_tmp131_, _tmp135_);
								_g_free0 (_tmp135_);
								_g_object_unref0 (_tmp131_);
								_tmp136_ = splittedParams;
								_tmp136__length1 = splittedParams_length1;
								_tmp137_ = _tmp136_[3];
								if (g_strcmp0 (_tmp137_, "root") == 0) {
									Log* _tmp138_ = NULL;
									Log* _tmp139_ = NULL;
									gchar** _tmp140_ = NULL;
									gint _tmp140__length1 = 0;
									const gchar* _tmp141_ = NULL;
									_tmp138_ = log_instance ();
									_tmp139_ = _tmp138_;
									log_log (_tmp139_, "root");
									_g_object_unref0 (_tmp139_);
									_tmp140_ = splittedParams;
									_tmp140__length1 = splittedParams_length1;
									_tmp141_ = _tmp140_[1];
									installation_set_root (self, _tmp141_);
								} else {
									gchar** _tmp142_ = NULL;
									gint _tmp142__length1 = 0;
									const gchar* _tmp143_ = NULL;
									_tmp142_ = splittedParams;
									_tmp142__length1 = splittedParams_length1;
									_tmp143_ = _tmp142_[3];
									if (g_strcmp0 (_tmp143_, "home") == 0) {
										gchar** _tmp144_ = NULL;
										gint _tmp144__length1 = 0;
										const gchar* _tmp145_ = NULL;
										_tmp144_ = splittedParams;
										_tmp144__length1 = splittedParams_length1;
										_tmp145_ = _tmp144_[1];
										installation_set_home (self, _tmp145_);
										self->separatedHome = TRUE;
									}
								}
								_g_free0 (id);
								break;
							}
						}
					} else if (_tmp22_ == ((0 != _tmp21_label2) ? _tmp21_label2 : (_tmp21_label2 = g_quark_from_static_string ("delete")))) {
						switch (0) {
							default:
							{
								Device* dev = NULL;
								const gchar* _tmp146_ = NULL;
								Device* _tmp147_ = NULL;
								gchar* id = NULL;
								gchar** _tmp148_ = NULL;
								gint _tmp148__length1 = 0;
								const gchar* _tmp149_ = NULL;
								gchar* _tmp150_ = NULL;
								Log* _tmp151_ = NULL;
								Log* _tmp152_ = NULL;
								gchar** _tmp153_ = NULL;
								gint _tmp153__length1 = 0;
								const gchar* _tmp154_ = NULL;
								gchar* _tmp155_ = NULL;
								gchar* _tmp156_ = NULL;
								gint _result_ = 0;
								Device* _tmp157_ = NULL;
								gchar** _tmp158_ = NULL;
								gint _tmp158__length1 = 0;
								const gchar* _tmp159_ = NULL;
								gint _tmp160_ = 0;
								gint _tmp161_ = 0;
								Log* _tmp162_ = NULL;
								Log* _tmp163_ = NULL;
								gint _tmp164_ = 0;
								gchar* _tmp165_ = NULL;
								gchar* _tmp166_ = NULL;
								gchar* _tmp167_ = NULL;
								gchar* _tmp168_ = NULL;
								gchar* _tmp169_ = NULL;
								gchar* _tmp170_ = NULL;
								_tmp146_ = self->priv->device_path;
								_tmp147_ = device_new_from_name (_tmp146_);
								dev = _tmp147_;
								_tmp148_ = splittedParams;
								_tmp148__length1 = splittedParams_length1;
								_tmp149_ = _tmp148_[1];
								_tmp150_ = g_strdup (_tmp149_);
								id = _tmp150_;
								_tmp151_ = log_instance ();
								_tmp152_ = _tmp151_;
								_tmp153_ = splittedParams;
								_tmp153__length1 = splittedParams_length1;
								_tmp154_ = _tmp153_[1];
								_tmp155_ = g_strconcat ("should delete partition ", _tmp154_, NULL);
								_tmp156_ = _tmp155_;
								log_log (_tmp152_, _tmp156_);
								_g_free0 (_tmp156_);
								_g_object_unref0 (_tmp152_);
								_tmp157_ = dev;
								_tmp158_ = splittedParams;
								_tmp158__length1 = splittedParams_length1;
								_tmp159_ = _tmp158_[1];
								_tmp160_ = atoi (_tmp159_);
								_tmp161_ = device_delete_partition (_tmp157_, _tmp160_, &_inner_error_);
								_result_ = _tmp161_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (id);
									_g_object_unref0 (dev);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp162_ = log_instance ();
								_tmp163_ = _tmp162_;
								_tmp164_ = _result_;
								_tmp165_ = g_strdup_printf ("%i", _tmp164_);
								_tmp166_ = _tmp165_;
								_tmp167_ = g_strconcat ("\nDeleted :", _tmp166_, NULL);
								_tmp168_ = _tmp167_;
								_tmp169_ = g_strconcat (_tmp168_, "\n", NULL);
								_tmp170_ = _tmp169_;
								log_log (_tmp163_, _tmp170_);
								_g_free0 (_tmp170_);
								_g_free0 (_tmp168_);
								_g_free0 (_tmp166_);
								_g_object_unref0 (_tmp163_);
								_g_free0 (id);
								_g_object_unref0 (dev);
								break;
							}
						}
					} else if (_tmp22_ == ((0 != _tmp21_label3) ? _tmp21_label3 : (_tmp21_label3 = g_quark_from_static_string ("home")))) {
						switch (0) {
							default:
							{
								gchar** _tmp171_ = NULL;
								gint _tmp171__length1 = 0;
								const gchar* _tmp172_ = NULL;
								_tmp171_ = splittedParams;
								_tmp171__length1 = splittedParams_length1;
								_tmp172_ = _tmp171_[1];
								installation_set_home (self, _tmp172_);
								self->separatedHome = TRUE;
								break;
							}
						}
					}
					splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (s);
				}
			}
		}
		_tmp173_ = self->priv->device_path;
		_tmp174_ = self->priv->_root;
		_tmp175_ = g_strconcat (_tmp173_, _tmp174_, NULL);
		_g_free0 (self->priv->partition_path);
		self->priv->partition_path = _tmp175_;
		_tmp176_ = log_instance ();
		_tmp177_ = _tmp176_;
		_tmp178_ = self->priv->partition_path;
		_tmp179_ = g_strconcat ("\nTarget :", _tmp178_, NULL);
		_tmp180_ = _tmp179_;
		_tmp181_ = g_strconcat (_tmp180_, "\n", NULL);
		_tmp182_ = _tmp181_;
		log_log (_tmp177_, _tmp182_);
		_g_free0 (_tmp182_);
		_g_free0 (_tmp180_);
		_g_object_unref0 (_tmp177_);
		_tmp183_ = self->separatedHome;
		if (_tmp183_ == TRUE) {
			const gchar* _tmp184_ = NULL;
			const gchar* _tmp185_ = NULL;
			gchar* _tmp186_ = NULL;
			gchar* _tmp187_ = NULL;
			Log* _tmp188_ = NULL;
			Log* _tmp189_ = NULL;
			const gchar* _tmp190_ = NULL;
			gchar* _tmp191_ = NULL;
			gchar* _tmp192_ = NULL;
			gchar* _tmp193_ = NULL;
			gchar* _tmp194_ = NULL;
			_tmp184_ = self->priv->device_path;
			_tmp185_ = self->priv->_home;
			_tmp186_ = g_strconcat (_tmp184_, _tmp185_, NULL);
			_tmp187_ = _tmp186_;
			installation_set_home (self, _tmp187_);
			_g_free0 (_tmp187_);
			_tmp188_ = log_instance ();
			_tmp189_ = _tmp188_;
			_tmp190_ = self->priv->_home;
			_tmp191_ = g_strconcat ("\nHome :", _tmp190_, NULL);
			_tmp192_ = _tmp191_;
			_tmp193_ = g_strconcat (_tmp192_, "\n", NULL);
			_tmp194_ = _tmp193_;
			log_log (_tmp189_, _tmp194_);
			_g_free0 (_tmp194_);
			_g_free0 (_tmp192_);
			_g_object_unref0 (_tmp189_);
		}
		self->priv->last_step = INSTALLATION_STEP_PARTITION;
		installation_do_next_job (self);
		stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
	} else {
		GeeArrayList* d = NULL;
		GeeArrayList* _tmp195_ = NULL;
		gboolean inconsistent = FALSE;
		gboolean _tmp196_ = FALSE;
		GeeArrayList* _tmp197_ = NULL;
		gboolean _tmp219_ = FALSE;
		GeeArrayList* partitions = NULL;
		GeeArrayList* _tmp220_ = NULL;
		gint _tmp221_ = 0;
		gpointer _tmp222_ = NULL;
		Device* _tmp223_ = NULL;
		GeeArrayList* _tmp224_ = NULL;
		GeeArrayList* _tmp225_ = NULL;
		GeeArrayList* _tmp226_ = NULL;
		GeeArrayList* _tmp227_ = NULL;
		GeeArrayList* _tmp228_ = NULL;
		gint _tmp229_ = 0;
		gpointer _tmp230_ = NULL;
		Device* _tmp231_ = NULL;
		gchar* _tmp232_ = NULL;
		Log* _tmp233_ = NULL;
		Log* _tmp234_ = NULL;
		GeeArrayList* _tmp235_ = NULL;
		gint _tmp236_ = 0;
		gpointer _tmp237_ = NULL;
		DevicePartition* _tmp238_ = NULL;
		DevicePartitionType _tmp239_ = 0;
		DevicePartitionType _tmp240_ = 0;
		gboolean _tmp241_ = FALSE;
		_tmp195_ = parted_get_devices (TRUE);
		d = _tmp195_;
		inconsistent = FALSE;
		_tmp197_ = d;
		if (_tmp197_ != NULL) {
			gint _tmp198_ = 0;
			GeeArrayList* _tmp199_ = NULL;
			gint _tmp200_ = 0;
			gint _tmp201_ = 0;
			_tmp198_ = self->priv->_device;
			_tmp199_ = d;
			_tmp200_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp199_);
			_tmp201_ = _tmp200_;
			_tmp196_ = _tmp198_ > _tmp201_;
		} else {
			_tmp196_ = FALSE;
		}
		if (_tmp196_) {
			inconsistent = TRUE;
		} else {
			gboolean _tmp202_ = FALSE;
			GeeArrayList* _tmp203_ = NULL;
			gint _tmp204_ = 0;
			gpointer _tmp205_ = NULL;
			Device* _tmp206_ = NULL;
			GeeArrayList* _tmp207_ = NULL;
			GeeArrayList* _tmp208_ = NULL;
			gboolean _tmp209_ = FALSE;
			_tmp203_ = d;
			_tmp204_ = self->priv->_device;
			_tmp205_ = gee_abstract_list_get ((GeeAbstractList*) _tmp203_, _tmp204_);
			_tmp206_ = (Device*) _tmp205_;
			_tmp207_ = device_get_partitions (_tmp206_);
			_tmp208_ = _tmp207_;
			_tmp209_ = _tmp208_ != NULL;
			_g_object_unref0 (_tmp206_);
			if (_tmp209_) {
				gint _tmp210_ = 0;
				GeeArrayList* _tmp211_ = NULL;
				gint _tmp212_ = 0;
				gpointer _tmp213_ = NULL;
				Device* _tmp214_ = NULL;
				GeeArrayList* _tmp215_ = NULL;
				GeeArrayList* _tmp216_ = NULL;
				gint _tmp217_ = 0;
				gint _tmp218_ = 0;
				_tmp210_ = self->priv->_partition;
				_tmp211_ = d;
				_tmp212_ = self->priv->_device;
				_tmp213_ = gee_abstract_list_get ((GeeAbstractList*) _tmp211_, _tmp212_);
				_tmp214_ = (Device*) _tmp213_;
				_tmp215_ = device_get_partitions (_tmp214_);
				_tmp216_ = _tmp215_;
				_tmp217_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp216_);
				_tmp218_ = _tmp217_;
				_tmp202_ = _tmp210_ > _tmp218_;
				_g_object_unref0 (_tmp214_);
			} else {
				_tmp202_ = FALSE;
			}
			if (_tmp202_) {
				inconsistent = TRUE;
			}
		}
		_tmp219_ = inconsistent;
		if (_tmp219_) {
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			installation_set_description (self, "Inconsistent partition record");
			_g_object_unref0 (d);
			return;
		}
		_tmp220_ = d;
		_tmp221_ = self->priv->_device;
		_tmp222_ = gee_abstract_list_get ((GeeAbstractList*) _tmp220_, _tmp221_);
		_tmp223_ = (Device*) _tmp222_;
		_tmp224_ = device_get_partitions (_tmp223_);
		_tmp225_ = _tmp224_;
		_tmp226_ = _g_object_ref0 (_tmp225_);
		_tmp227_ = _tmp226_;
		_g_object_unref0 (_tmp223_);
		partitions = _tmp227_;
		_tmp228_ = d;
		_tmp229_ = self->priv->_device;
		_tmp230_ = gee_abstract_list_get ((GeeAbstractList*) _tmp228_, _tmp229_);
		_tmp231_ = (Device*) _tmp230_;
		_tmp232_ = device_get_path (_tmp231_);
		_g_free0 (self->priv->device_path);
		self->priv->device_path = _tmp232_;
		_g_object_unref0 (_tmp231_);
		installation_set_description (self, "Partitioning");
		self->priv->step = INSTALLATION_STEP_PARTITION;
		_tmp233_ = log_instance ();
		_tmp234_ = _tmp233_;
		log_log (_tmp234_, "Enter simple partitioning");
		_g_object_unref0 (_tmp234_);
		_tmp235_ = partitions;
		_tmp236_ = self->priv->_partition;
		_tmp237_ = gee_abstract_list_get ((GeeAbstractList*) _tmp235_, _tmp236_);
		_tmp238_ = (DevicePartition*) _tmp237_;
		_tmp239_ = device_partition_get_ptype (_tmp238_);
		_tmp240_ = _tmp239_;
		_tmp241_ = _tmp240_ == DEVICE_PARTITION_TYPE_FREESPACE;
		_g_object_unref0 (_tmp238_);
		if (_tmp241_) {
			Device* device = NULL;
			const gchar* _tmp242_ = NULL;
			Device* _tmp243_ = NULL;
			gboolean can_continue = FALSE;
			gint new_partition = 0;
			gboolean _tmp293_ = FALSE;
			GeeArrayList* _tmp294_ = NULL;
			GeeArrayList* _tmp295_ = NULL;
			const gchar* _tmp296_ = NULL;
			gint _tmp297_ = 0;
			gchar* _tmp298_ = NULL;
			gchar* _tmp299_ = NULL;
			gchar* _tmp300_ = NULL;
			_tmp242_ = self->priv->device_path;
			_tmp243_ = device_new_from_name (_tmp242_);
			device = _tmp243_;
			can_continue = FALSE;
			new_partition = -1;
			{
				guint64 swap_size = 0ULL;
				GeeArrayList* _tmp244_ = NULL;
				GeeArrayList* _tmp245_ = NULL;
				gboolean _tmp246_ = FALSE;
				gboolean _tmp247_ = FALSE;
				gboolean _tmp248_ = FALSE;
				gint _tmp264_ = 0;
				Device* _tmp265_ = NULL;
				GeeArrayList* _tmp266_ = NULL;
				gint _tmp267_ = 0;
				gpointer _tmp268_ = NULL;
				DevicePartition* _tmp269_ = NULL;
				guint64 _tmp270_ = 0ULL;
				guint64 _tmp271_ = 0ULL;
				GeeArrayList* _tmp272_ = NULL;
				gint _tmp273_ = 0;
				gpointer _tmp274_ = NULL;
				DevicePartition* _tmp275_ = NULL;
				guint64 _tmp276_ = 0ULL;
				guint64 _tmp277_ = 0ULL;
				guint64 _tmp278_ = 0ULL;
				gint _tmp279_ = 0;
				gint _tmp280_ = 0;
				Log* _tmp281_ = NULL;
				Log* _tmp282_ = NULL;
				gint _tmp283_ = 0;
				gchar* _tmp284_ = NULL;
				gchar* _tmp285_ = NULL;
				gchar* _tmp286_ = NULL;
				gchar* _tmp287_ = NULL;
				gint _tmp288_ = 0;
				swap_size = (guint64) 0;
				_tmp244_ = swap_collector_get_partitions ();
				_tmp245_ = _tmp244_;
				_tmp246_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp245_);
				_tmp247_ = _tmp246_;
				_tmp248_ = _tmp247_;
				_g_object_unref0 (_tmp245_);
				if (_tmp248_) {
					GeeArrayList* _tmp249_ = NULL;
					gint _tmp250_ = 0;
					gpointer _tmp251_ = NULL;
					DevicePartition* _tmp252_ = NULL;
					guint64 _tmp253_ = 0ULL;
					guint64 _tmp254_ = 0ULL;
					guint64 _tmp255_ = 0ULL;
					gboolean _tmp256_ = FALSE;
					_tmp249_ = partitions;
					_tmp250_ = self->priv->_partition;
					_tmp251_ = gee_abstract_list_get ((GeeAbstractList*) _tmp249_, _tmp250_);
					_tmp252_ = (DevicePartition*) _tmp251_;
					_tmp253_ = device_partition_get_size (_tmp252_);
					_tmp254_ = _tmp253_;
					_tmp255_ = self->priv->installation_size;
					_tmp256_ = (_tmp254_ - INSTALLATION_OneGig) > _tmp255_;
					_g_object_unref0 (_tmp252_);
					if (_tmp256_) {
						Log* _tmp257_ = NULL;
						Log* _tmp258_ = NULL;
						guint64 _tmp259_ = 0ULL;
						gchar* _tmp260_ = NULL;
						gchar* _tmp261_ = NULL;
						gchar* _tmp262_ = NULL;
						gchar* _tmp263_ = NULL;
						swap_size = INSTALLATION_OneGig;
						_tmp257_ = log_instance ();
						_tmp258_ = _tmp257_;
						_tmp259_ = swap_size;
						_tmp260_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp259_);
						_tmp261_ = _tmp260_;
						_tmp262_ = g_strconcat ("No swap detected, creating swap along with partition creation, swap si" \
"ze = ", _tmp261_, NULL);
						_tmp263_ = _tmp262_;
						log_log (_tmp258_, _tmp263_);
						_g_free0 (_tmp263_);
						_g_free0 (_tmp261_);
						_g_object_unref0 (_tmp258_);
					}
				}
				swap_size = INSTALLATION_OneGig;
				_tmp265_ = device;
				_tmp266_ = partitions;
				_tmp267_ = self->priv->_partition;
				_tmp268_ = gee_abstract_list_get ((GeeAbstractList*) _tmp266_, _tmp267_);
				_tmp269_ = (DevicePartition*) _tmp268_;
				_tmp270_ = device_partition_get_start (_tmp269_);
				_tmp271_ = _tmp270_;
				_tmp272_ = partitions;
				_tmp273_ = self->priv->_partition;
				_tmp274_ = gee_abstract_list_get ((GeeAbstractList*) _tmp272_, _tmp273_);
				_tmp275_ = (DevicePartition*) _tmp274_;
				_tmp276_ = device_partition_get_end (_tmp275_);
				_tmp277_ = _tmp276_;
				_tmp278_ = swap_size;
				_tmp279_ = device_create_partition_simple (_tmp265_, _tmp271_, _tmp277_, "ext4", _tmp278_, &_inner_error_);
				_tmp280_ = _tmp279_;
				_g_object_unref0 (_tmp275_);
				_g_object_unref0 (_tmp269_);
				_tmp264_ = _tmp280_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == DEVICE_ERROR) {
						goto __catch2_device_error;
					}
					_g_object_unref0 (device);
					_g_object_unref0 (partitions);
					_g_object_unref0 (d);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				new_partition = _tmp264_;
				_tmp281_ = log_instance ();
				_tmp282_ = _tmp281_;
				_tmp283_ = new_partition;
				_tmp284_ = g_strdup_printf ("%i", _tmp283_);
				_tmp285_ = _tmp284_;
				_tmp286_ = g_strconcat ("Partition creation returns new partition ID: ", _tmp285_, NULL);
				_tmp287_ = _tmp286_;
				log_log (_tmp282_, _tmp287_);
				_g_free0 (_tmp287_);
				_g_free0 (_tmp285_);
				_g_object_unref0 (_tmp282_);
				_tmp288_ = new_partition;
				if (_tmp288_ != (-1)) {
					can_continue = TRUE;
				}
			}
			goto __finally2;
			__catch2_device_error:
			{
				GError* e = NULL;
				Log* _tmp289_ = NULL;
				Log* _tmp290_ = NULL;
				GError* _tmp291_ = NULL;
				const gchar* _tmp292_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp289_ = log_instance ();
				_tmp290_ = _tmp289_;
				_tmp291_ = e;
				_tmp292_ = _tmp291_->message;
				log_log_without_newline (_tmp290_, _tmp292_);
				_g_object_unref0 (_tmp290_);
				_g_error_free0 (e);
			}
			__finally2:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (device);
				_g_object_unref0 (partitions);
				_g_object_unref0 (d);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp293_ = can_continue;
			if (_tmp293_ == FALSE) {
				self->priv->step = INSTALLATION_STEP_DONE;
				self->priv->last_step = INSTALLATION_STEP_DONE;
				installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
				installation_set_description (self, "Error while doing partition");
				_g_object_unref0 (device);
				_g_object_unref0 (partitions);
				_g_object_unref0 (d);
				return;
			}
			_tmp294_ = parted_get_devices (FALSE);
			_tmp295_ = _tmp294_;
			_g_object_unref0 (_tmp295_);
			_tmp296_ = self->priv->device_path;
			_tmp297_ = new_partition;
			_tmp298_ = g_strdup_printf ("%i", _tmp297_);
			_tmp299_ = _tmp298_;
			_tmp300_ = g_strconcat (_tmp296_, _tmp299_, NULL);
			_g_free0 (self->priv->partition_path);
			self->priv->partition_path = _tmp300_;
			_g_free0 (_tmp299_);
			_g_object_unref0 (device);
		} else {
			GeeArrayList* _tmp301_ = NULL;
			gint _tmp302_ = 0;
			gpointer _tmp303_ = NULL;
			Device* _tmp304_ = NULL;
			gchar* _tmp305_ = NULL;
			gchar* _tmp306_ = NULL;
			GeeArrayList* _tmp307_ = NULL;
			gint _tmp308_ = 0;
			gpointer _tmp309_ = NULL;
			DevicePartition* _tmp310_ = NULL;
			gint _tmp311_ = 0;
			gint _tmp312_ = 0;
			gchar* _tmp313_ = NULL;
			gchar* _tmp314_ = NULL;
			gchar* _tmp315_ = NULL;
			_tmp301_ = d;
			_tmp302_ = self->priv->_device;
			_tmp303_ = gee_abstract_list_get ((GeeAbstractList*) _tmp301_, _tmp302_);
			_tmp304_ = (Device*) _tmp303_;
			_tmp305_ = device_get_path (_tmp304_);
			_tmp306_ = _tmp305_;
			_tmp307_ = partitions;
			_tmp308_ = self->priv->_partition;
			_tmp309_ = gee_abstract_list_get ((GeeAbstractList*) _tmp307_, _tmp308_);
			_tmp310_ = (DevicePartition*) _tmp309_;
			_tmp311_ = device_partition_get_number (_tmp310_);
			_tmp312_ = _tmp311_;
			_tmp313_ = g_strdup_printf ("%i", _tmp312_);
			_tmp314_ = _tmp313_;
			_tmp315_ = g_strconcat (_tmp306_, _tmp314_, NULL);
			_g_free0 (self->priv->partition_path);
			self->priv->partition_path = _tmp315_;
			_g_free0 (_tmp314_);
			_g_object_unref0 (_tmp310_);
			_g_free0 (_tmp306_);
			_g_object_unref0 (_tmp304_);
		}
		self->priv->last_step = INSTALLATION_STEP_PARTITION;
		installation_do_next_job (self);
		_g_object_unref0 (partitions);
		_g_object_unref0 (d);
	}
}


static void installation_do_fs (Installation* self) {
	gchar** c = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("/sbin/mkfs.ext4");
	_tmp1_ = self->priv->partition_path;
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp0_;
	_tmp3_[1] = _tmp2_;
	c = _tmp3_;
	c_length1 = 2;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_FS, "Installing filesystem", "Unable to install filesystem");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_mount (Installation* self) {
	Log* _tmp0_ = NULL;
	Log* _tmp1_ = NULL;
	gchar** c = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar** _tmp6_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = log_instance ();
	_tmp1_ = _tmp0_;
	log_log (_tmp1_, "\nho home\n");
	_g_object_unref0 (_tmp1_);
	g_mkdir ("/target", 0700);
	_tmp2_ = g_strdup ("/bin/mount");
	_tmp3_ = self->priv->partition_path;
	_tmp4_ = g_strdup (_tmp3_);
	_tmp5_ = g_strdup ("/target");
	_tmp6_ = g_new0 (gchar*, 3 + 1);
	_tmp6_[0] = _tmp2_;
	_tmp6_[1] = _tmp4_;
	_tmp6_[2] = _tmp5_;
	c = _tmp6_;
	c_length1 = 3;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_MOUNT, "Mounting filesystem ", "Unable to mount filesystem");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_mount_home (Installation* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->separatedHome;
	if (_tmp1_ == TRUE) {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = self->priv->_advancedMode;
		_tmp0_ = _tmp2_ == TRUE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Log* _tmp3_ = NULL;
		Log* _tmp4_ = NULL;
		gchar** c = NULL;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gint c_length1 = 0;
		gint _c_size_ = 0;
		gchar** _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* content = NULL;
		const gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		_tmp3_ = log_instance ();
		_tmp4_ = _tmp3_;
		log_log (_tmp4_, "\nmount separated home partition\n");
		_g_object_unref0 (_tmp4_);
		g_mkdir ("/target/home", 0700);
		_tmp5_ = g_strdup ("/bin/mount");
		_tmp6_ = self->priv->_home;
		_tmp7_ = g_strdup (_tmp6_);
		_tmp8_ = g_strdup ("/target/home");
		_tmp9_ = g_new0 (gchar*, 3 + 1);
		_tmp9_[0] = _tmp5_;
		_tmp9_[1] = _tmp7_;
		_tmp9_[2] = _tmp8_;
		c = _tmp9_;
		c_length1 = 3;
		_c_size_ = c_length1;
		_tmp10_ = c;
		_tmp10__length1 = c_length1;
		installation_do_simple_command_with_args (self, _tmp10_, _tmp10__length1, INSTALLATION_STEP_MOUNTHOME, "Mounting home filesystem ", "Unable to mount home filesystem");
		_tmp11_ = self->priv->partition_path;
		_tmp12_ = g_strconcat (_tmp11_, " / ext4 defaults 1 2", NULL);
		content = _tmp12_;
		_tmp13_ = content;
		utils_write_simple_file ("/tmp/fstab", _tmp13_);
		_tmp14_ = self->priv->_home;
		_tmp15_ = g_strconcat (_tmp14_, " /home ext4 defaults 1 2", NULL);
		_g_free0 (content);
		content = _tmp15_;
		_tmp16_ = content;
		utils_write_simple_file ("/tmp/fstab", _tmp16_);
		_g_free0 (content);
		c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
	} else {
		self->priv->last_step = INSTALLATION_STEP_MOUNTHOME;
		installation_do_next_job (self);
	}
}


static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gchar** c = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	InstallationStep _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_to_run != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	_tmp0_ = command_to_run;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	c = _tmp2_;
	c_length1 = 1;
	_c_size_ = c_length1;
	_tmp3_ = command_step;
	_tmp4_ = command_description;
	_tmp5_ = error_description;
	installation_do_simple_command_with_args (self, c, c_length1, _tmp3_, _tmp4_, _tmp5_);
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_copy (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-copy-fs", INSTALLATION_STEP_COPY, "Copying filesystem", "Unable to copy filesystem");
}


static void installation_do_setup (Installation* self) {
	gchar* content = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* swaps = NULL;
	gchar* _tmp14_ = NULL;
	const gchar* _tmp30_ = NULL;
	gchar* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_user_name;
	_tmp1_ = self->priv->_password;
	_tmp2_ = g_strdup_printf ("%s:%s\n", _tmp0_, _tmp1_);
	content = _tmp2_;
	_tmp3_ = content;
	utils_write_simple_file ("/tmp/user-pass", _tmp3_);
	_tmp4_ = self->priv->_autologin;
	_tmp5_ = self->priv->_user_name;
	_tmp6_ = g_strdup_printf ("%d %s\n", (gint) _tmp4_, _tmp5_);
	_g_free0 (content);
	content = _tmp6_;
	_tmp7_ = content;
	utils_write_simple_file ("/tmp/user-setup", _tmp7_);
	_tmp8_ = self->priv->_full_name;
	_tmp9_ = g_strdup_printf ("%s\n\n\n\n\n", _tmp8_);
	_g_free0 (content);
	content = _tmp9_;
	_tmp10_ = content;
	utils_write_simple_file ("/tmp/user-info", _tmp10_);
	_tmp11_ = self->priv->_host_name;
	_tmp12_ = g_strdup_printf ("%s\n", _tmp11_);
	_g_free0 (content);
	content = _tmp12_;
	_tmp13_ = content;
	utils_write_simple_file ("/tmp/hostname", _tmp13_);
	swap_collector_reset ();
	_tmp14_ = g_strdup ("");
	swaps = _tmp14_;
	{
		GeeArrayList* _p_list = NULL;
		GeeArrayList* _tmp15_ = NULL;
		gint _p_size = 0;
		GeeArrayList* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _p_index = 0;
		_tmp15_ = swap_collector_get_partitions ();
		_p_list = _tmp15_;
		_tmp16_ = _p_list;
		_tmp17_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp16_);
		_tmp18_ = _tmp17_;
		_p_size = _tmp18_;
		_p_index = -1;
		while (TRUE) {
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gchar* p = NULL;
			GeeArrayList* _tmp22_ = NULL;
			gint _tmp23_ = 0;
			gpointer _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			const gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			_tmp19_ = _p_index;
			_p_index = _tmp19_ + 1;
			_tmp20_ = _p_index;
			_tmp21_ = _p_size;
			if (!(_tmp20_ < _tmp21_)) {
				break;
			}
			_tmp22_ = _p_list;
			_tmp23_ = _p_index;
			_tmp24_ = gee_abstract_list_get ((GeeAbstractList*) _tmp22_, _tmp23_);
			p = (gchar*) _tmp24_;
			_tmp25_ = swaps;
			_tmp26_ = p;
			_tmp27_ = g_strconcat (_tmp26_, "\n", NULL);
			_tmp28_ = _tmp27_;
			_tmp29_ = g_strconcat (_tmp25_, _tmp28_, NULL);
			_g_free0 (swaps);
			swaps = _tmp29_;
			_g_free0 (_tmp28_);
			_g_free0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	_tmp30_ = swaps;
	_tmp31_ = g_strdup_printf ("%s", _tmp30_);
	_g_free0 (content);
	content = _tmp31_;
	_tmp32_ = content;
	utils_write_simple_file ("/tmp/swaps", _tmp32_);
	installation_do_simple_command (self, "/sbin/b-i-setup-fs", INSTALLATION_STEP_SETUP, "Setting up", "Unable to setup installation");
	_g_free0 (swaps);
	_g_free0 (content);
}


static void installation_do_grub (Installation* self) {
	gchar* device = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar** c = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar** _tmp8_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->device_path;
	_tmp1_ = g_strdup (_tmp0_);
	device = _tmp1_;
	_tmp2_ = device;
	if (g_strcmp0 (_tmp2_, "") == 0) {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->device_path;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (device);
		device = _tmp4_;
	}
	_tmp5_ = g_strdup ("/sbin/b-i-install-grub");
	_tmp6_ = device;
	_tmp7_ = g_strdup (_tmp6_);
	_tmp8_ = g_new0 (gchar*, 2 + 1);
	_tmp8_[0] = _tmp5_;
	_tmp8_[1] = _tmp7_;
	c = _tmp8_;
	c_length1 = 2;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_GRUB, "Installing GRUB", "Unable to install GRUB");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (device);
}


static void installation_do_cleanup (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-cleanup", INSTALLATION_STEP_CLEANUP, "Cleaning up", "Unable to properly clean up");
}


static void installation_do_done (Installation* self) {
	g_return_if_fail (self != NULL);
	self->priv->step = INSTALLATION_STEP_DONE;
	self->priv->last_step = INSTALLATION_STEP_DONE;
	installation_set_state (self, (gint) INSTALLATION_STATE_DONE);
	installation_do_next_job (self);
}


static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDERR: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDOUT: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix) {
	gboolean result = FALSE;
	GIOStatus ret = 0;
	gchar* msg = NULL;
	gsize len = 0UL;
	gboolean _result_ = FALSE;
	GIOCondition _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	g_return_val_if_fail (prefix != NULL, FALSE);
	_result_ = TRUE;
	_tmp0_ = condition;
	if ((_tmp0_ & G_IO_HUP) == G_IO_HUP) {
		_result_ = FALSE;
	}
	{
		while (TRUE) {
			GIOStatus _tmp1_ = 0;
			GIOChannel* _tmp2_ = NULL;
			gchar* _tmp3_ = NULL;
			gsize _tmp4_ = 0UL;
			GIOStatus _tmp5_ = 0;
			Log* _tmp6_ = NULL;
			Log* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			_tmp2_ = gio;
			_tmp5_ = g_io_channel_read_line (_tmp2_, &_tmp3_, &_tmp4_, NULL, &_inner_error_);
			_g_free0 (msg);
			msg = _tmp3_;
			len = _tmp4_;
			_tmp1_ = _tmp5_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_IO_CHANNEL_ERROR) {
					goto __catch3_g_io_channel_error;
				}
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch3_g_convert_error;
				}
				_g_free0 (msg);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			if (!(_tmp1_ == G_IO_STATUS_NORMAL)) {
				break;
			}
			_tmp6_ = log_instance ();
			_tmp7_ = _tmp6_;
			_tmp8_ = prefix;
			_tmp9_ = msg;
			_tmp10_ = g_strconcat (_tmp8_, _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			log_log_without_newline (_tmp7_, _tmp11_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp7_);
		}
	}
	goto __finally3;
	__catch3_g_io_channel_error:
	{
		GError* e = NULL;
		Log* _tmp12_ = NULL;
		Log* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp12_ = log_instance ();
		_tmp13_ = _tmp12_;
		_tmp14_ = prefix;
		_tmp15_ = g_strconcat (_tmp14_, "Error reading: ", NULL);
		_tmp16_ = _tmp15_;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		_tmp19_ = g_strconcat (_tmp16_, _tmp18_, NULL);
		_tmp20_ = _tmp19_;
		log_log (_tmp13_, _tmp20_);
		_g_free0 (_tmp20_);
		_g_free0 (_tmp16_);
		_g_object_unref0 (_tmp13_);
		_g_error_free0 (e);
	}
	goto __finally3;
	__catch3_g_convert_error:
	{
		GError* e = NULL;
		Log* _tmp21_ = NULL;
		Log* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		GError* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp21_ = log_instance ();
		_tmp22_ = _tmp21_;
		_tmp23_ = prefix;
		_tmp24_ = g_strconcat (_tmp23_, "Error reading: ", NULL);
		_tmp25_ = _tmp24_;
		_tmp26_ = e;
		_tmp27_ = _tmp26_->message;
		_tmp28_ = g_strconcat (_tmp25_, _tmp27_, NULL);
		_tmp29_ = _tmp28_;
		log_log (_tmp22_, _tmp29_);
		_g_free0 (_tmp29_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp22_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (msg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _result_;
	_g_free0 (msg);
	return result;
}


static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self) {
	installation_child_watch ((Installation*) self, pid, status);
}


static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stdout ((Installation*) self, source, condition);
	return result;
}


static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stderr ((Installation*) self, source, condition);
	return result;
}


static gint installation_run (Installation* self, gchar** command, int command_length1) {
	gint result = 0;
	gchar** env = NULL;
	gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* cmd_log = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint fd_out = 0;
	gint fd_err = 0;
	gint child_pid = 0;
	Log* _tmp12_ = NULL;
	Log* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	guint w = 0U;
	gint _tmp26_ = 0;
	guint _tmp27_ = 0U;
	Log* _tmp28_ = NULL;
	Log* _tmp29_ = NULL;
	gint _tmp30_ = 0;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	guint _tmp37_ = 0U;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	GIOChannel* _tmp43_ = NULL;
	gint _tmp44_ = 0;
	GIOChannel* _tmp45_ = NULL;
	GIOChannel* _tmp46_ = NULL;
	guint _tmp47_ = 0U;
	GIOChannel* _tmp50_ = NULL;
	guint _tmp51_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_strdup ("LC_ALL=C");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	env = _tmp1_;
	env_length1 = 1;
	_env_size_ = env_length1;
	_tmp2_ = g_strdup ("Running command: '");
	cmd_log = _tmp2_;
	_tmp3_ = command;
	_tmp3__length1 = command_length1;
	{
		gchar** c_collection = NULL;
		gint c_collection_length1 = 0;
		gint _c_collection_size_ = 0;
		gint c_it = 0;
		c_collection = _tmp3_;
		c_collection_length1 = _tmp3__length1;
		for (c_it = 0; c_it < _tmp3__length1; c_it = c_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* c = NULL;
			_tmp4_ = g_strdup (c_collection[c_it]);
			c = _tmp4_;
			{
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp5_ = cmd_log;
				_tmp6_ = c;
				_tmp7_ = g_strconcat (_tmp6_, " ", NULL);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
				_g_free0 (cmd_log);
				cmd_log = _tmp9_;
				_g_free0 (_tmp8_);
				_g_free0 (c);
			}
		}
	}
	_tmp10_ = cmd_log;
	_tmp11_ = g_strconcat (_tmp10_, "'", NULL);
	_g_free0 (cmd_log);
	cmd_log = _tmp11_;
	_tmp12_ = log_instance ();
	_tmp13_ = _tmp12_;
	_tmp14_ = cmd_log;
	log_log (_tmp13_, _tmp14_);
	_g_object_unref0 (_tmp13_);
	{
		gchar** _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		gchar** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		GPid _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		_tmp15_ = command;
		_tmp15__length1 = command_length1;
		_tmp16_ = env;
		_tmp16__length1 = env_length1;
		g_spawn_async_with_pipes ("/tmp/", _tmp15_, _tmp16_, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp17_, NULL, &_tmp18_, &_tmp19_, &_inner_error_);
		child_pid = (gint) _tmp17_;
		fd_out = _tmp18_;
		fd_err = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		Log* _tmp20_ = NULL;
		Log* _tmp21_ = NULL;
		GError* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = log_instance ();
		_tmp21_ = _tmp20_;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		_tmp24_ = g_strconcat ("Error running: ", _tmp23_, NULL);
		_tmp25_ = _tmp24_;
		log_log (_tmp21_, _tmp25_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp21_);
		result = -1;
		_g_error_free0 (e);
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp26_ = child_pid;
	_tmp27_ = g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, (GPid) _tmp26_, _installation_child_watch_gchild_watch_func, g_object_ref (self), g_object_unref);
	w = _tmp27_;
	_tmp28_ = log_instance ();
	_tmp29_ = _tmp28_;
	_tmp30_ = child_pid;
	_tmp31_ = g_strdup_printf ("%i", _tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat ("Child is spawn with PID: ", _tmp32_, NULL);
	_tmp34_ = _tmp33_;
	_tmp35_ = g_strconcat (_tmp34_, " and watched as ", NULL);
	_tmp36_ = _tmp35_;
	_tmp37_ = w;
	_tmp38_ = g_strdup_printf ("%u", _tmp37_);
	_tmp39_ = _tmp38_;
	_tmp40_ = g_strconcat (_tmp36_, _tmp39_, NULL);
	_tmp41_ = _tmp40_;
	log_log (_tmp29_, _tmp41_);
	_g_free0 (_tmp41_);
	_g_free0 (_tmp39_);
	_g_free0 (_tmp36_);
	_g_free0 (_tmp34_);
	_g_free0 (_tmp32_);
	_g_object_unref0 (_tmp29_);
	_tmp42_ = fd_out;
	_tmp43_ = g_io_channel_unix_new (_tmp42_);
	_g_io_channel_unref0 (self->priv->io_out);
	self->priv->io_out = _tmp43_;
	_tmp44_ = fd_err;
	_tmp45_ = g_io_channel_unix_new (_tmp44_);
	_g_io_channel_unref0 (self->priv->io_err);
	self->priv->io_err = _tmp45_;
	_tmp46_ = self->priv->io_out;
	_tmp47_ = g_io_add_watch (_tmp46_, G_IO_IN | G_IO_HUP, _installation_watch_stdout_gio_func, self);
	if (!(_tmp47_ != ((guint) 0))) {
		Log* _tmp48_ = NULL;
		Log* _tmp49_ = NULL;
		_tmp48_ = log_instance ();
		_tmp49_ = _tmp48_;
		log_log (_tmp49_, "Error watching stdout for cmd_log");
		_g_object_unref0 (_tmp49_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp50_ = self->priv->io_err;
	_tmp51_ = g_io_add_watch (_tmp50_, G_IO_IN | G_IO_HUP, _installation_watch_stderr_gio_func, self);
	if (!(_tmp51_ != ((guint) 0))) {
		Log* _tmp52_ = NULL;
		Log* _tmp53_ = NULL;
		_tmp52_ = log_instance ();
		_tmp53_ = _tmp52_;
		log_log (_tmp53_, "Error watching stderr for cmd_log");
		_g_object_unref0 (_tmp53_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = child_pid;
	_g_free0 (cmd_log);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_status (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_start (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* s = NULL;
	void* _tmp4_ = NULL;
	void* f = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	void* _tmp8_ = NULL;
	void* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	void* _tmp11_ = NULL;
	void* _tmp12_ = NULL;
	void* _tmp13_ = NULL;
	void* _tmp14_ = NULL;
	void* _tmp15_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	void* _tmp19_ = NULL;
	void** _tmp20_ = NULL;
	gint _tmp20__length1 = 0;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (constructor != NULL, NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = ctx;
	_tmp2_ = c;
	_tmp3_ = JSObjectMake (_tmp1_, _tmp2_, NULL);
	o = _tmp3_;
	_tmp4_ = JSStringCreateWithUTF8CString ("getStatus");
	s = _tmp4_;
	_tmp5_ = ctx;
	_tmp6_ = s;
	_tmp7_ = JSObjectMakeFunctionWithCallback (_tmp5_, _tmp6_, _installation_js_get_status_js_core_object_call_as_function_callback);
	f = _tmp7_;
	_tmp8_ = o;
	_tmp9_ = ctx;
	_tmp10_ = s;
	_tmp11_ = f;
	JSObjectSetProperty (_tmp9_, _tmp8_, _tmp10_, _tmp11_, 0, NULL);
	_tmp12_ = JSStringCreateWithUTF8CString ("start");
	_JSStringRelease0 (s);
	s = _tmp12_;
	_tmp13_ = ctx;
	_tmp14_ = s;
	_tmp15_ = JSObjectMakeFunctionWithCallback (_tmp13_, _tmp14_, _installation_js_start_js_core_object_call_as_function_callback);
	_0 (f);
	f = _tmp15_;
	_tmp16_ = o;
	_tmp17_ = ctx;
	_tmp18_ = s;
	_tmp19_ = f;
	JSObjectSetProperty (_tmp17_, _tmp16_, _tmp18_, _tmp19_, 0, NULL);
	_tmp20_ = arguments;
	_tmp20__length1 = arguments_length1;
	if (_tmp20__length1 == 1) {
		void** _tmp21_ = NULL;
		gint _tmp21__length1 = 0;
		void* _tmp22_ = NULL;
		void* _tmp23_ = NULL;
		void* _tmp24_ = NULL;
		gchar buffer[1024] = {0};
		void* _tmp25_ = NULL;
		Installation* i = NULL;
		Installation* _tmp26_ = NULL;
		void* _tmp27_ = NULL;
		Installation* _tmp28_ = NULL;
		_tmp21_ = arguments;
		_tmp21__length1 = arguments_length1;
		_tmp22_ = _tmp21_[0];
		_tmp23_ = ctx;
		_tmp24_ = JSValueToStringCopy (_tmp23_, _tmp22_, NULL);
		_JSStringRelease0 (s);
		s = _tmp24_;
		_tmp25_ = s;
		JSStringGetUTF8CString (_tmp25_, buffer, (gsize) 1024);
		_tmp26_ = installation_new_from_string ((const gchar*) buffer);
		i = _tmp26_;
		_tmp27_ = o;
		_tmp28_ = i;
		JSObjectSetPrivate (_tmp27_, _tmp28_);
	}
	result = o;
	_0 (f);
	_JSStringRelease0 (s);
	_JSClassRelease0 (c);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		gchar* _result_ = NULL;
		Installation* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		Installation* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		Installation* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gchar* _tmp10_ = NULL;
		void* s = NULL;
		const gchar* _tmp11_ = NULL;
		void* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		_tmp4_ = i;
		_tmp5_ = _tmp4_->priv->_state;
		_tmp6_ = i;
		_tmp7_ = _tmp6_->priv->_description;
		_tmp8_ = i;
		_tmp9_ = _tmp8_->priv->_progress;
		_tmp10_ = g_strdup_printf ("({ 'status': %d, 'description': '%s', 'progress': %d })", _tmp5_, _tmp7_, _tmp9_);
		_result_ = _tmp10_;
		_tmp11_ = _result_;
		_tmp12_ = JSStringCreateWithUTF8CString (_tmp11_);
		s = _tmp12_;
		_tmp13_ = ctx;
		_tmp14_ = s;
		_tmp15_ = JSEvaluateScript (_tmp13_, _tmp14_, NULL, NULL, 0, NULL);
		result = _tmp15_;
		_JSStringRelease0 (s);
		_g_free0 (_result_);
		_g_object_unref0 (i);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp16_ = ctx;
	_tmp17_ = JSValueMakeUndefined (_tmp16_);
	result = _tmp17_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		Installation* _tmp4_ = NULL;
		_tmp4_ = i;
		installation_start (_tmp4_);
	}
	_tmp5_ = ctx;
	_tmp6_ = JSValueMakeUndefined (_tmp5_);
	result = _tmp6_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	gtk_main_quit ();
	_tmp0_ = ctx;
	_tmp1_ = JSValueMakeUndefined (_tmp0_);
	result = _tmp1_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* location = NULL;
	gchar* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = g_strdup ("/tmp/post-install.sh");
	location = _tmp0_;
	utils_write_simple_file (location, "sudo /sbin/reboot\n");
	g_spawn_command_line_sync ("/bin/chmod a+x /tmp/post-install.sh", NULL, NULL, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (location);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	gtk_main_quit ();
	_tmp1_ = ctx;
	_tmp2_ = JSValueMakeUndefined (_tmp1_);
	result = _tmp2_;
	_g_free0 (location);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _result_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		void* _tmp16_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = _ ((const gchar*) _tmp11_);
		_tmp13_ = JSStringCreateWithUTF8CString (_tmp12_);
		_JSStringRelease0 (s);
		s = _tmp13_;
		_tmp14_ = ctx;
		_tmp15_ = s;
		_tmp16_ = JSValueMakeString (_tmp14_, _tmp15_);
		_result_ = _tmp16_;
		_JSStringRelease0 (s);
		s = NULL;
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		result = _result_;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp17_ = ctx;
	_tmp18_ = JSValueMakeUndefined (_tmp17_);
	result = _tmp18_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp19_ = NULL;
	void* _tmp20_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		FILE* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		gchar* _tmp13_ = NULL;
		gint _tmp13__length1 = 0;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = stdout;
		_tmp12_ = buffer;
		_tmp12__length1 = buffer_length1;
		fprintf (_tmp11_, "Changing timezone to %s\n", (const gchar*) _tmp12_);
		g_unlink ("/etc/localtime");
		_tmp13_ = buffer;
		_tmp13__length1 = buffer_length1;
		_tmp14_ = g_strdup_printf ("/usr/share/zoneinfo/%s", (const gchar*) _tmp13_);
		_tmp15_ = _tmp14_;
		symlink (_tmp15_, "/etc/localtime");
		_g_free0 (_tmp15_);
		_tmp16_ = buffer;
		_tmp16__length1 = buffer_length1;
		_tmp17_ = g_strdup_printf ("TZ=%s\nexport TZ\n", (const gchar*) _tmp16_);
		_tmp18_ = _tmp17_;
		utils_write_simple_file ("/run/timezone", _tmp18_);
		_g_free0 (_tmp18_);
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp19_ = ctx;
	_tmp20_ = JSValueMakeUndefined (_tmp19_);
	result = _tmp20_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp21_ = NULL;
	void* _tmp22_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* x = NULL;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		FILE* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gint _tmp17__length1 = 0;
		gchar* _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = setlocale (LC_ALL, (const gchar*) _tmp11_);
		_tmp13_ = g_strdup (_tmp12_);
		x = _tmp13_;
		_tmp14_ = stdout;
		_tmp15_ = buffer;
		_tmp15__length1 = buffer_length1;
		_tmp16_ = x;
		fprintf (_tmp14_, "Changing locale to %s: %s\n", (const gchar*) _tmp15_, _tmp16_);
		bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
		bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
		textdomain (GETTEXT_PACKAGE);
		_tmp17_ = buffer;
		_tmp17__length1 = buffer_length1;
		_tmp18_ = buffer;
		_tmp18__length1 = buffer_length1;
		_tmp19_ = g_strdup_printf ("LC_ALL=%s\nLANG=%s\n", (const gchar*) _tmp17_, (const gchar*) _tmp18_);
		_tmp20_ = _tmp19_;
		utils_write_simple_file ("/run/locale", _tmp20_);
		_g_free0 (_tmp20_);
		g_spawn_command_line_sync ("/bin/cp /run/locale /etc/default/locale", NULL, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (x);
			buffer = (g_free (buffer), NULL);
			_JSStringRelease0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		_g_free0 (x);
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp21_ = ctx;
	_tmp22_ = JSValueMakeUndefined (_tmp21_);
	result = _tmp22_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* normal_output = NULL;
	gchar* error_output = NULL;
	gint status = 0;
	gchar** args = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	gchar** env = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* _result_ = NULL;
	gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar** _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	const gchar* _tmp29_ = NULL;
	gchar* _tmp30_ = NULL;
	void* s = NULL;
	const gchar* _tmp31_ = NULL;
	void* _tmp32_ = NULL;
	void* _tmp33_ = NULL;
	void* _tmp34_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = g_strdup ("/usr/bin/locale");
	_tmp1_ = g_strdup ("-a");
	_tmp2_ = g_new0 (gchar*, 2 + 1);
	_tmp2_[0] = _tmp0_;
	_tmp2_[1] = _tmp1_;
	args = _tmp2_;
	args_length1 = 2;
	_args_size_ = args_length1;
	_tmp3_ = g_strdup ("LC_ALL=C");
	_tmp4_ = g_new0 (gchar*, 1 + 1);
	_tmp4_[0] = _tmp3_;
	env = _tmp4_;
	env_length1 = 1;
	_env_size_ = env_length1;
	{
		gchar** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		_tmp5_ = args;
		_tmp5__length1 = args_length1;
		_tmp6_ = env;
		_tmp6__length1 = env_length1;
		g_spawn_sync ("/tmp", _tmp5_, _tmp6_, G_SPAWN_LEAVE_DESCRIPTORS_OPEN, NULL, NULL, &_tmp7_, &_tmp8_, &_tmp9_, &_inner_error_);
		_g_free0 (normal_output);
		normal_output = _tmp7_;
		_g_free0 (error_output);
		error_output = _tmp8_;
		status = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (error_output);
		_g_free0 (normal_output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp10_ = g_strdup ("[");
	_result_ = _tmp10_;
	_tmp11_ = normal_output;
	_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp13_;
		line_collection_length1 = _vala_array_length (_tmp12_);
		for (line_it = 0; line_it < _vala_array_length (_tmp12_); line_it = line_it + 1) {
			gchar* _tmp14_ = NULL;
			gchar* line = NULL;
			_tmp14_ = g_strdup (line_collection[line_it]);
			line = _tmp14_;
			{
				const gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				gboolean _tmp17_ = FALSE;
				const gchar* _tmp18_ = NULL;
				_tmp15_ = line;
				if (g_strcmp0 (_tmp15_, "") == 0) {
					_g_free0 (line);
					continue;
				}
				_tmp18_ = line;
				if (g_strcmp0 (_tmp18_, "C") == 0) {
					_tmp17_ = TRUE;
				} else {
					const gchar* _tmp19_ = NULL;
					gboolean _tmp20_ = FALSE;
					_tmp19_ = line;
					_tmp20_ = g_str_has_prefix (_tmp19_, "C.");
					_tmp17_ = _tmp20_;
				}
				if (_tmp17_) {
					_tmp16_ = TRUE;
				} else {
					const gchar* _tmp21_ = NULL;
					_tmp21_ = line;
					_tmp16_ = g_strcmp0 (_tmp21_, "POSIX") == 0;
				}
				if (!_tmp16_) {
					const gchar* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					gchar* _tmp24_ = NULL;
					gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					_tmp22_ = _result_;
					_tmp23_ = line;
					_tmp24_ = g_strconcat ("'", _tmp23_, NULL);
					_tmp25_ = _tmp24_;
					_tmp26_ = g_strconcat (_tmp25_, "',", NULL);
					_tmp27_ = _tmp26_;
					_tmp28_ = g_strconcat (_tmp22_, _tmp27_, NULL);
					_g_free0 (_result_);
					_result_ = _tmp28_;
					_g_free0 (_tmp27_);
					_g_free0 (_tmp25_);
				}
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp29_ = _result_;
	_tmp30_ = g_strconcat (_tmp29_, "'C']", NULL);
	_g_free0 (_result_);
	_result_ = _tmp30_;
	_tmp31_ = _result_;
	_tmp32_ = JSStringCreateWithUTF8CString (_tmp31_);
	s = _tmp32_;
	_tmp33_ = ctx;
	_tmp34_ = JSEvaluateScript (_tmp33_, s, NULL, NULL, 0, NULL);
	result = _tmp34_;
	_JSStringRelease0 (s);
	_g_free0 (_result_);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (error_output);
	_g_free0 (normal_output);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void installation_setup_js_class (void* context) {
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* g = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* s = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	g_return_if_fail (context != NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = context;
	_tmp2_ = context;
	_tmp3_ = JSObjectMake (_tmp1_, c, _tmp2_);
	o = _tmp3_;
	_tmp4_ = context;
	_tmp5_ = JSContextGetGlobalObject (_tmp4_);
	g = _tmp5_;
	_tmp6_ = JSStringCreateWithUTF8CString ("Installation");
	s = _tmp6_;
	_tmp7_ = context;
	JSObjectSetProperty (_tmp7_, g, s, o, kJSPropertyAttributeNone, NULL);
	_JSStringRelease0 (s);
	_0 (g);
	_0 (o);
	_JSClassRelease0 (c);
}


Installation* installation_construct (GType object_type) {
	Installation * self = NULL;
	self = (Installation*) g_object_new (object_type, NULL);
	return self;
}


Installation* installation_new (void) {
	return installation_construct (TYPE_INSTALLATION);
}


gint installation_get_partition (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_partition;
	result = _tmp0_;
	return result;
}


void installation_set_partition (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_partition = _tmp0_;
	g_object_notify ((GObject *) self, "partition");
}


gint installation_get_device (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_device;
	result = _tmp0_;
	return result;
}


void installation_set_device (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_device = _tmp0_;
	g_object_notify ((GObject *) self, "device");
}


const gchar* installation_get_user_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user_name;
	result = _tmp0_;
	return result;
}


void installation_set_user_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_user_name);
	self->priv->_user_name = _tmp1_;
	g_object_notify ((GObject *) self, "user-name");
}


const gchar* installation_get_password (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_password;
	result = _tmp0_;
	return result;
}


void installation_set_password (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_password);
	self->priv->_password = _tmp1_;
	g_object_notify ((GObject *) self, "password");
}


const gchar* installation_get_host_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_host_name;
	result = _tmp0_;
	return result;
}


void installation_set_host_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_host_name);
	self->priv->_host_name = _tmp1_;
	g_object_notify ((GObject *) self, "host-name");
}


const gchar* installation_get_full_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_full_name;
	result = _tmp0_;
	return result;
}


void installation_set_full_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_full_name);
	self->priv->_full_name = _tmp1_;
	g_object_notify ((GObject *) self, "full-name");
}


const gchar* installation_get_grub_device (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_grub_device;
	result = _tmp0_;
	return result;
}


void installation_set_grub_device (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_grub_device);
	self->priv->_grub_device = _tmp1_;
	g_object_notify ((GObject *) self, "grub-device");
}


const gchar* installation_get_language (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_language;
	result = _tmp0_;
	return result;
}


void installation_set_language (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_language);
	self->priv->_language = _tmp1_;
	g_object_notify ((GObject *) self, "language");
}


const gchar* installation_get_region (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_region;
	result = _tmp0_;
	return result;
}


void installation_set_region (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_region);
	self->priv->_region = _tmp1_;
	g_object_notify ((GObject *) self, "region");
}


const gchar* installation_get_keyboard (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_keyboard;
	result = _tmp0_;
	return result;
}


void installation_set_keyboard (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_keyboard);
	self->priv->_keyboard = _tmp1_;
	g_object_notify ((GObject *) self, "keyboard");
}


const gchar* installation_get_home (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_home;
	result = _tmp0_;
	return result;
}


void installation_set_home (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_home);
	self->priv->_home = _tmp1_;
	g_object_notify ((GObject *) self, "home");
}


const gchar* installation_get_root (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_root;
	result = _tmp0_;
	return result;
}


void installation_set_root (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_root);
	self->priv->_root = _tmp1_;
	g_object_notify ((GObject *) self, "root");
}


gboolean installation_get_autologin (Installation* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_autologin;
	result = _tmp0_;
	return result;
}


void installation_set_autologin (Installation* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_autologin = _tmp0_;
	g_object_notify ((GObject *) self, "autologin");
}


gboolean installation_get_advancedMode (Installation* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_advancedMode;
	result = _tmp0_;
	return result;
}


void installation_set_advancedMode (Installation* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_advancedMode = _tmp0_;
	g_object_notify ((GObject *) self, "advancedMode");
}


gint installation_get_state (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}


void installation_set_state (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_state = _tmp0_;
	g_object_notify ((GObject *) self, "state");
}


gint installation_get_progress (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_progress;
	result = _tmp0_;
	return result;
}


static void installation_set_progress (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_progress = _tmp0_;
	g_object_notify ((GObject *) self, "progress");
}


const gchar* installation_get_description (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


void installation_set_description (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


const gchar* installation_get_steps (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_steps;
	result = _tmp0_;
	return result;
}


void installation_set_steps (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_steps);
	self->priv->_steps = _tmp1_;
	g_object_notify ((GObject *) self, "steps");
}


static void installation_class_init (InstallationClass * klass) {
	installation_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_installation_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_installation_set_property;
	G_OBJECT_CLASS (klass)->finalize = installation_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PARTITION, g_param_spec_int ("partition", "partition", "partition", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DEVICE, g_param_spec_int ("device", "device", "device", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_USER_NAME, g_param_spec_string ("user-name", "user-name", "user-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PASSWORD, g_param_spec_string ("password", "password", "password", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_HOST_NAME, g_param_spec_string ("host-name", "host-name", "host-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_FULL_NAME, g_param_spec_string ("full-name", "full-name", "full-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_GRUB_DEVICE, g_param_spec_string ("grub-device", "grub-device", "grub-device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_LANGUAGE, g_param_spec_string ("language", "language", "language", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_REGION, g_param_spec_string ("region", "region", "region", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_KEYBOARD, g_param_spec_string ("keyboard", "keyboard", "keyboard", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_HOME, g_param_spec_string ("home", "home", "home", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_ROOT, g_param_spec_string ("root", "root", "root", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_AUTOLOGIN, g_param_spec_boolean ("autologin", "autologin", "autologin", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_ADVANCED_MODE, g_param_spec_boolean ("advancedMode", "advancedMode", "advancedMode", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_STATE, g_param_spec_int ("state", "state", "state", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PROGRESS, g_param_spec_int ("progress", "progress", "progress", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_STEPS, g_param_spec_string ("steps", "steps", "steps", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_signal_new ("installation_started", TYPE_INSTALLATION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void installation_instance_init (Installation * self) {
	self->priv = INSTALLATION_GET_PRIVATE (self);
	self->separatedHome = FALSE;
	self->priv->step = INSTALLATION_STEP_IDLE;
	self->priv->last_step = INSTALLATION_STEP_IDLE;
}


static void installation_finalize (GObject* obj) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLATION, Installation);
	_g_free0 (self->priv->_user_name);
	_g_free0 (self->priv->_password);
	_g_free0 (self->priv->_host_name);
	_g_free0 (self->priv->_full_name);
	_g_free0 (self->priv->_grub_device);
	_g_free0 (self->priv->_language);
	_g_free0 (self->priv->_region);
	_g_free0 (self->priv->_keyboard);
	_g_free0 (self->priv->_home);
	_g_free0 (self->priv->_root);
	_g_free0 (self->priv->_description);
	_g_free0 (self->priv->_steps);
	_g_free0 (self->priv->partition_path);
	_g_free0 (self->priv->device_path);
	_g_io_channel_unref0 (self->priv->io_err);
	_g_io_channel_unref0 (self->priv->io_out);
	G_OBJECT_CLASS (installation_parent_class)->finalize (obj);
}


GType installation_get_type (void) {
	static volatile gsize installation_type_id__volatile = 0;
	if (g_once_init_enter (&installation_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installation), 0, (GInstanceInitFunc) installation_instance_init, NULL };
		GType installation_type_id;
		installation_type_id = g_type_register_static (G_TYPE_OBJECT, "Installation", &g_define_type_info, 0);
		g_once_init_leave (&installation_type_id__volatile, installation_type_id);
	}
	return installation_type_id__volatile;
}


static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		g_value_set_int (value, installation_get_partition (self));
		break;
		case INSTALLATION_DEVICE:
		g_value_set_int (value, installation_get_device (self));
		break;
		case INSTALLATION_USER_NAME:
		g_value_set_string (value, installation_get_user_name (self));
		break;
		case INSTALLATION_PASSWORD:
		g_value_set_string (value, installation_get_password (self));
		break;
		case INSTALLATION_HOST_NAME:
		g_value_set_string (value, installation_get_host_name (self));
		break;
		case INSTALLATION_FULL_NAME:
		g_value_set_string (value, installation_get_full_name (self));
		break;
		case INSTALLATION_GRUB_DEVICE:
		g_value_set_string (value, installation_get_grub_device (self));
		break;
		case INSTALLATION_LANGUAGE:
		g_value_set_string (value, installation_get_language (self));
		break;
		case INSTALLATION_REGION:
		g_value_set_string (value, installation_get_region (self));
		break;
		case INSTALLATION_KEYBOARD:
		g_value_set_string (value, installation_get_keyboard (self));
		break;
		case INSTALLATION_HOME:
		g_value_set_string (value, installation_get_home (self));
		break;
		case INSTALLATION_ROOT:
		g_value_set_string (value, installation_get_root (self));
		break;
		case INSTALLATION_AUTOLOGIN:
		g_value_set_boolean (value, installation_get_autologin (self));
		break;
		case INSTALLATION_ADVANCED_MODE:
		g_value_set_boolean (value, installation_get_advancedMode (self));
		break;
		case INSTALLATION_STATE:
		g_value_set_int (value, installation_get_state (self));
		break;
		case INSTALLATION_PROGRESS:
		g_value_set_int (value, installation_get_progress (self));
		break;
		case INSTALLATION_DESCRIPTION:
		g_value_set_string (value, installation_get_description (self));
		break;
		case INSTALLATION_STEPS:
		g_value_set_string (value, installation_get_steps (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		installation_set_partition (self, g_value_get_int (value));
		break;
		case INSTALLATION_DEVICE:
		installation_set_device (self, g_value_get_int (value));
		break;
		case INSTALLATION_USER_NAME:
		installation_set_user_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_PASSWORD:
		installation_set_password (self, g_value_get_string (value));
		break;
		case INSTALLATION_HOST_NAME:
		installation_set_host_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_FULL_NAME:
		installation_set_full_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_GRUB_DEVICE:
		installation_set_grub_device (self, g_value_get_string (value));
		break;
		case INSTALLATION_LANGUAGE:
		installation_set_language (self, g_value_get_string (value));
		break;
		case INSTALLATION_REGION:
		installation_set_region (self, g_value_get_string (value));
		break;
		case INSTALLATION_KEYBOARD:
		installation_set_keyboard (self, g_value_get_string (value));
		break;
		case INSTALLATION_HOME:
		installation_set_home (self, g_value_get_string (value));
		break;
		case INSTALLATION_ROOT:
		installation_set_root (self, g_value_get_string (value));
		break;
		case INSTALLATION_AUTOLOGIN:
		installation_set_autologin (self, g_value_get_boolean (value));
		break;
		case INSTALLATION_ADVANCED_MODE:
		installation_set_advancedMode (self, g_value_get_boolean (value));
		break;
		case INSTALLATION_STATE:
		installation_set_state (self, g_value_get_int (value));
		break;
		case INSTALLATION_PROGRESS:
		installation_set_progress (self, g_value_get_int (value));
		break;
		case INSTALLATION_DESCRIPTION:
		installation_set_description (self, g_value_get_string (value));
		break;
		case INSTALLATION_STEPS:
		installation_set_steps (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally6;
	__catch6_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* installer_translate_uri (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "http://system", "file://" SYSTEM_PATH "/");
	uri = _tmp1_;
	result = uri;
	return result;
}


static gchar* installer_translate_install (Installer* self, const gchar* uri) {
	gchar* result = NULL;
	gchar* path = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = string_replace (_tmp0_, "http://install/", "");
	path = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = g_str_has_prefix (_tmp2_, "show_log?");
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		uri = "file:///var/log/blankon-installer.log";
		_tmp4_ = uri;
		_tmp5_ = g_strdup (_tmp4_);
		result = _tmp5_;
		_g_free0 (path);
		return result;
	}
	_tmp6_ = g_strdup ("about:blank");
	result = _tmp6_;
	_g_free0 (path);
	return result;
}


static gchar* installer_translate_theme (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "theme://", "");
	_tmp2_ = _tmp1_;
	_tmp3_ = utils_get_icon_path (_tmp2_, 24);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strdup_printf ("file://%s", _tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	uri = _tmp6_;
	result = uri;
	return result;
}


static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self) {
	WebKitWebView* result;
	result = installer_getInspectorView ((Installer*) self, p0);
	return result;
}


static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response) {
	WebKitWebResource* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (frame != NULL);
	g_return_if_fail (resource != NULL);
	g_return_if_fail (request != NULL);
	_tmp0_ = resource;
	_tmp1_ = webkit_web_resource_get_uri (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_str_has_prefix (_tmp2_, "theme://");
	if (_tmp3_) {
		WebKitNetworkRequest* _tmp4_ = NULL;
		WebKitWebResource* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp4_ = request;
		_tmp5_ = resource;
		_tmp6_ = webkit_web_resource_get_uri (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = installer_translate_theme (self, _tmp7_);
		_tmp9_ = _tmp8_;
		webkit_network_request_set_uri (_tmp4_, _tmp9_);
		_g_free0 (_tmp9_);
	} else {
		WebKitNetworkRequest* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp10_ = request;
		_tmp11_ = webkit_network_request_get_uri (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_str_has_prefix (_tmp12_, "http://install/");
		if (_tmp13_) {
			gchar* uri = NULL;
			WebKitWebResource* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			WebKitNetworkRequest* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			_tmp14_ = resource;
			_tmp15_ = webkit_web_resource_get_uri (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = installer_translate_install (self, _tmp16_);
			uri = _tmp17_;
			_tmp18_ = request;
			_tmp19_ = uri;
			webkit_network_request_set_uri (_tmp18_, _tmp19_);
			_g_free0 (uri);
		} else {
			gchar* uri = NULL;
			WebKitWebResource* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			const gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			WebKitNetworkRequest* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			_tmp20_ = resource;
			_tmp21_ = webkit_web_resource_get_uri (_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp23_ = installer_translate_uri (self, _tmp22_);
			uri = _tmp23_;
			_tmp24_ = request;
			_tmp25_ = uri;
			webkit_network_request_set_uri (_tmp24_, _tmp25_);
			_g_free0 (uri);
		}
	}
}


static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self) {
	__lambda5_ ((Installer*) self, p0, p1, p2, p3);
}


static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context) {
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	g_return_if_fail (frame != NULL);
	_tmp0_ = context;
	utils_setup_js_class ((void*) _tmp0_);
	_tmp1_ = context;
	parted_setup_js_class ((void*) _tmp1_);
	_tmp2_ = context;
	installation_setup_js_class ((void*) _tmp2_);
}


static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self) {
	__lambda6_ ((Installer*) self, frame, context);
}


Installer* installer_construct (GType object_type) {
	Installer * self = NULL;
	WebKitWebSettings* settings = NULL;
	WebKitWebSettings* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	WebKitWebSettings* _tmp6_ = NULL;
	WebKitWebSettings* _tmp7_ = NULL;
	WebKitWebSettings* _tmp8_ = NULL;
	self = (Installer*) g_object_new (object_type, NULL);
	_tmp0_ = webkit_web_settings_new ();
	settings = _tmp0_;
	_tmp1_ = self->priv->debug;
	if (g_strcmp0 (_tmp1_, "1") == 0) {
		WebKitWebSettings* _tmp2_ = NULL;
		WebKitWebInspector* _tmp3_ = NULL;
		WebKitWebInspector* _tmp4_ = NULL;
		WebKitWebInspector* _tmp5_ = NULL;
		_tmp2_ = settings;
		g_object_set (_tmp2_, "enable-developer-extras", TRUE, NULL);
		g_object_get ((WebKitWebView*) self, "web-inspector", &_tmp3_, NULL);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		g_signal_connect_object (_tmp5_, "inspect-web-view", (GCallback) _installer_getInspectorView_webkit_web_inspector_inspect_web_view, self, 0);
		_g_object_unref0 (_tmp5_);
	}
	_tmp6_ = settings;
	g_object_set (_tmp6_, "enable-file-access-from-file-uris", TRUE, NULL);
	_tmp7_ = settings;
	g_object_set (_tmp7_, "enable-universal-access-from-file-uris", TRUE, NULL);
	_tmp8_ = settings;
	webkit_web_view_set_settings ((WebKitWebView*) self, _tmp8_);
	g_signal_connect_object ((WebKitWebView*) self, "resource-request-starting", (GCallback) ___lambda5__webkit_web_view_resource_request_starting, self, 0);
	g_signal_connect_object ((WebKitWebView*) self, "window-object-cleared", (GCallback) ___lambda6__webkit_web_view_window_object_cleared, self, 0);
	_g_object_unref0 (settings);
	return self;
}


Installer* installer_new (void) {
	return installer_construct (TYPE_INSTALLER);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Installer* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->webview);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda4_ (Block1Data* _data1_) {
	Installer* self;
	gboolean result = FALSE;
	WebKitWebInspector* _tmp0_ = NULL;
	WebKitWebInspector* _tmp1_ = NULL;
	WebKitWebInspector* _tmp2_ = NULL;
	self = _data1_->self;
	g_object_get (_data1_->webview, "web-inspector", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	webkit_web_inspector_close (_tmp2_);
	_g_object_unref0 (_tmp2_);
	result = FALSE;
	return result;
}


static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
	gboolean result;
	result = __lambda4_ (self);
	return result;
}


static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView) {
	WebKitWebView* result = NULL;
	Block1Data* _data1_;
	GtkWindow* window = NULL;
	GtkWindow* _tmp0_ = NULL;
	WebKitWebView* _tmp1_ = NULL;
	GtkScrolledWindow* scrolled_window = NULL;
	GtkScrolledWindow* _tmp2_ = NULL;
	WebKitWebView* handle = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inspectedView != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp0_);
	window = _tmp0_;
	_tmp1_ = (WebKitWebView*) webkit_web_view_new ();
	g_object_ref_sink (_tmp1_);
	_data1_->webview = _tmp1_;
	_tmp2_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp2_);
	scrolled_window = _tmp2_;
	gtk_scrolled_window_set_policy (scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) _data1_->webview);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) scrolled_window);
	gtk_window_set_title (window, "Inspector");
	gtk_window_set_default_size (window, 640, 480);
	gtk_widget_show_all ((GtkWidget*) window);
	g_signal_connect_data ((GtkWidget*) window, "delete-event", (GCallback) ___lambda4__gtk_widget_delete_event, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	handle = _data1_->webview;
	result = handle;
	_g_object_unref0 (scrolled_window);
	_g_object_unref0 (window);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


void installer_start (Installer* self) {
	g_return_if_fail (self != NULL);
	webkit_web_view_load_uri ((WebKitWebView*) self, "http://system/index.html");
}


static void installer_class_init (InstallerClass * klass) {
	installer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallerPrivate));
	G_OBJECT_CLASS (klass)->finalize = installer_finalize;
}


static void installer_instance_init (Installer * self) {
	const gchar* _tmp0_ = NULL;
	self->priv = INSTALLER_GET_PRIVATE (self);
	_tmp0_ = g_getenv ("DEBUG");
	self->priv->debug = _tmp0_;
}


static void installer_finalize (GObject* obj) {
	Installer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLER, Installer);
	G_OBJECT_CLASS (installer_parent_class)->finalize (obj);
}


GType installer_get_type (void) {
	static volatile gsize installer_type_id__volatile = 0;
	if (g_once_init_enter (&installer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installer), 0, (GInstanceInitFunc) installer_instance_init, NULL };
		GType installer_type_id;
		installer_type_id = g_type_register_static (WEBKIT_TYPE_WEB_VIEW, "Installer", &g_define_type_info, 0);
		g_once_init_leave (&installer_type_id__volatile, installer_type_id);
	}
	return installer_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



