/* installer.c generated by valac 0.26.1, the Vala compiler
 * generated from installer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <JavaScriptCore/JavaScript.h>
#include <sys/wait.h>
#include <gee.h>
#include <glib/gstdio.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <unistd.h>
#include <locale.h>
#include <config.h>
#include <webkit/webkit.h>
#include <gdk/gdk.h>


#define TYPE_LOG (log_get_type ())
#define LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOG, Log))
#define LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOG, LogClass))
#define IS_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOG))
#define IS_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOG))
#define LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOG, LogClass))

typedef struct _Log Log;
typedef struct _LogClass LogClass;
typedef struct _LogPrivate LogPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_INSTALLATION (installation_get_type ())
#define INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLATION, Installation))
#define INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLATION, InstallationClass))
#define IS_INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLATION))
#define IS_INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLATION))
#define INSTALLATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLATION, InstallationClass))

typedef struct _Installation Installation;
typedef struct _InstallationClass InstallationClass;
typedef struct _InstallationPrivate InstallationPrivate;

#define INSTALLATION_TYPE_STEP (installation_step_get_type ())

#define INSTALLATION_TYPE_STATE (installation_state_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;

#define DEVICE_TYPE_PARTITION (device_partition_get_type ())
#define DEVICE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEVICE_TYPE_PARTITION, DevicePartition))
#define DEVICE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEVICE_TYPE_PARTITION, DevicePartitionClass))
#define DEVICE_IS_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEVICE_TYPE_PARTITION))
#define DEVICE_IS_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEVICE_TYPE_PARTITION))
#define DEVICE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEVICE_TYPE_PARTITION, DevicePartitionClass))

typedef struct _DevicePartition DevicePartition;
typedef struct _DevicePartitionClass DevicePartitionClass;

#define DEVICE_TYPE_PARTITION_TYPE (device_partition_type_get_type ())
#define _JSStringRelease0(var) ((var == NULL) ? NULL : (var = (JSStringRelease (var), NULL)))
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _JSClassRelease0(var) ((var == NULL) ? NULL : (var = (JSClassRelease (var), NULL)))

#define TYPE_INSTALLER (installer_get_type ())
#define INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLER, Installer))
#define INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLER, InstallerClass))
#define IS_INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLER))
#define IS_INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLER))
#define INSTALLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLER, InstallerClass))

typedef struct _Installer Installer;
typedef struct _InstallerClass InstallerClass;
typedef struct _InstallerPrivate InstallerPrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _Log {
	GObject parent_instance;
	LogPrivate * priv;
};

struct _LogClass {
	GObjectClass parent_class;
};

struct _LogPrivate {
	GDataOutputStream* stream;
};

struct _Installation {
	GObject parent_instance;
	InstallationPrivate * priv;
	gchar* root;
	gboolean separatedHome;
};

struct _InstallationClass {
	GObjectClass parent_class;
};

typedef enum  {
	INSTALLATION_STEP_IDLE,
	INSTALLATION_STEP_PARTITION,
	INSTALLATION_STEP_FS,
	INSTALLATION_STEP_MOUNT,
	INSTALLATION_STEP_COPY,
	INSTALLATION_STEP_SETUP,
	INSTALLATION_STEP_GRUB,
	INSTALLATION_STEP_CLEANUP,
	INSTALLATION_STEP_DONE
} InstallationStep;

struct _InstallationPrivate {
	gint _partition;
	gint _device;
	gchar* _user_name;
	gchar* _password;
	gchar* _host_name;
	gchar* _full_name;
	gchar* _grub_device;
	gchar* _language;
	gchar* _region;
	gchar* _keyboard;
	gchar* _home;
	gboolean _autologin;
	gboolean _advancedMode;
	gint _state;
	gint _progress;
	gchar* _description;
	gchar* _steps;
	guint64 installation_size;
	gchar* partition_path;
	gchar* device_path;
	InstallationStep step;
	InstallationStep last_step;
	GIOChannel* io_err;
	GIOChannel* io_out;
};

typedef enum  {
	INSTALLATION_STATE_NOT_STARTED,
	INSTALLATION_STATE_ON_GOING,
	INSTALLATION_STATE_ERROR,
	INSTALLATION_STATE_DONE
} InstallationState;

typedef enum  {
	DEVICE_ERROR_CANT_CREATE_PARTITION
} DeviceError;
#define DEVICE_ERROR device_error_quark ()
typedef enum  {
	DEVICE_PARTITION_TYPE_NORMAL,
	DEVICE_PARTITION_TYPE_LOGICAL,
	DEVICE_PARTITION_TYPE_EXTENDED,
	DEVICE_PARTITION_TYPE_FREESPACE,
	DEVICE_PARTITION_TYPE_METADATA,
	DEVICE_PARTITION_TYPE_PROTECTED,
	DEVICE_PARTITION_TYPE_INVALID
} DevicePartitionType;

struct _Installer {
	WebKitWebView parent_instance;
	InstallerPrivate * priv;
};

struct _InstallerClass {
	WebKitWebViewClass parent_class;
};

struct _InstallerPrivate {
	const gchar* debug;
};

struct _Block1Data {
	int _ref_count_;
	Installer* self;
	WebKitWebView* webview;
};


static gpointer log_parent_class = NULL;
static Log* log__instance;
static Log* log__instance = NULL;
static gpointer installation_parent_class = NULL;
static gpointer installer_parent_class = NULL;

GType log_get_type (void) G_GNUC_CONST;
#define LOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LOG, LogPrivate))
enum  {
	LOG_DUMMY_PROPERTY
};
Log* log_new (void);
Log* log_construct (GType object_type);
void log_log_without_newline (Log* self, const gchar* string);
void log_log (Log* self, const gchar* string);
Log* log_instance (void);
static void log_finalize (GObject* obj);
GType installation_get_type (void) G_GNUC_CONST;
static GType installation_step_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define INSTALLATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLATION, InstallationPrivate))
enum  {
	INSTALLATION_DUMMY_PROPERTY,
	INSTALLATION_PARTITION,
	INSTALLATION_DEVICE,
	INSTALLATION_USER_NAME,
	INSTALLATION_PASSWORD,
	INSTALLATION_HOST_NAME,
	INSTALLATION_FULL_NAME,
	INSTALLATION_GRUB_DEVICE,
	INSTALLATION_LANGUAGE,
	INSTALLATION_REGION,
	INSTALLATION_KEYBOARD,
	INSTALLATION_HOME,
	INSTALLATION_AUTOLOGIN,
	INSTALLATION_ADVANCED_MODE,
	INSTALLATION_STATE,
	INSTALLATION_PROGRESS,
	INSTALLATION_DESCRIPTION,
	INSTALLATION_STEPS
};
GType installation_state_get_type (void) G_GNUC_CONST;
#define INSTALLATION_OneGig ((guint64) ((1024 * 1024) * 1024))
void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception);
Installation* installation_new_from_string (const gchar* uri);
Installation* installation_construct_from_string (GType object_type, const gchar* uri);
static void installation_set_progress (Installation* self, gint value);
void installation_set_state (Installation* self, gint value);
void installation_set_description (Installation* self, const gchar* value);
void installation_set_autologin (Installation* self, gboolean value);
void installation_set_device (Installation* self, gint value);
void installation_set_partition (Installation* self, gint value);
void installation_set_user_name (Installation* self, const gchar* value);
void installation_set_password (Installation* self, const gchar* value);
void installation_set_host_name (Installation* self, const gchar* value);
void installation_set_full_name (Installation* self, const gchar* value);
void installation_set_grub_device (Installation* self, const gchar* value);
void installation_set_language (Installation* self, const gchar* value);
void installation_set_region (Installation* self, const gchar* value);
void installation_set_keyboard (Installation* self, const gchar* value);
void installation_set_home (Installation* self, const gchar* value);
void installation_set_advancedMode (Installation* self, gboolean value);
void installation_set_steps (Installation* self, const gchar* value);
static void __lambda7_ (Installation* self);
static void installation_real_start (Installation* self);
static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self);
void installation_start (Installation* self);
static void installation_do_next_job (Installation* self);
static void installation_do_partition (Installation* self);
static void installation_do_fs (Installation* self);
static void installation_do_mount (Installation* self);
static void installation_do_copy (Installation* self);
static void installation_do_setup (Installation* self);
static void installation_do_grub (Installation* self);
static void installation_do_cleanup (Installation* self);
static void installation_do_done (Installation* self);
gint installation_get_state (Installation* self);
static void installation_child_watch (Installation* self, GPid pid, gint status);
static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
static gint installation_run (Installation* self, gchar** command, int command_length1);
gboolean installation_get_advancedMode (Installation* self);
const gchar* installation_get_steps (Installation* self);
GType device_get_type (void) G_GNUC_CONST;
Device* device_new_from_name (const gchar* s);
Device* device_construct_from_name (GType object_type, const gchar* s);
GQuark device_error_quark (void);
gint device_create_partition (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, const gchar* type, const gchar* mount, GError** error);
gint device_delete_partition (Device* self, gint index, GError** error);
const gchar* installation_get_home (Installation* self);
GeeArrayList* parted_get_devices (gboolean from_cache);
gint installation_get_device (Installation* self);
GType device_partition_get_type (void) G_GNUC_CONST;
GeeArrayList* device_get_partitions (Device* self);
gint installation_get_partition (Installation* self);
gchar* device_get_path (Device* self);
GType device_partition_type_get_type (void) G_GNUC_CONST;
DevicePartitionType device_partition_get_ptype (DevicePartition* self);
GeeArrayList* swap_collector_get_partitions (void);
guint64 device_partition_get_size (DevicePartition* self);
gint device_create_partition_simple (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, guint64 swap_size, GError** error);
guint64 device_partition_get_start (DevicePartition* self);
guint64 device_partition_get_end (DevicePartition* self);
gint device_partition_get_number (DevicePartition* self);
static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
const gchar* installation_get_user_name (Installation* self);
const gchar* installation_get_password (Installation* self);
void utils_write_simple_file (const gchar* path, const gchar* content);
gboolean installation_get_autologin (Installation* self);
const gchar* installation_get_full_name (Installation* self);
const gchar* installation_get_host_name (Installation* self);
void swap_collector_reset (void);
static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition);
static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix);
static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition);
static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self);
static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
const gchar* installation_get_description (Installation* self);
gint installation_get_progress (Installation* self);
void installation_setup_js_class (void* context);
Installation* installation_new (void);
Installation* installation_construct (GType object_type);
const gchar* installation_get_grub_device (Installation* self);
const gchar* installation_get_language (Installation* self);
const gchar* installation_get_region (Installation* self);
const gchar* installation_get_keyboard (Installation* self);
static void installation_finalize (GObject* obj);
static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType installer_get_type (void) G_GNUC_CONST;
#define INSTALLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLER, InstallerPrivate))
enum  {
	INSTALLER_DUMMY_PROPERTY
};
static gchar* installer_translate_uri (Installer* self, const gchar* old);
static gchar* installer_translate_install (Installer* self, const gchar* uri);
static gchar* installer_translate_theme (Installer* self, const gchar* old);
gchar* utils_get_icon_path (const gchar* name, gint size);
Installer* installer_new (void);
Installer* installer_construct (GType object_type);
static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView);
static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self);
static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response);
static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self);
static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context);
void utils_setup_js_class (void* context);
void parted_setup_js_class (void* context);
static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
void installer_start (Installer* self);
static void installer_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const JSStaticFunction INSTALLATION_js_funcs[7] = {{"shutdown", _installation_js_shutdown_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"reboot", _installation_js_reboot_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"translate", _installation_js_translate_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setLocale", _installation_js_set_locale_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setTimezone", _installation_js_set_timezone_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"getLocaleList", _installation_js_get_locale_list_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {NULL, NULL, 0}};
static const JSClassDefinition INSTALLATION_js_class = {0, kJSClassAttributeNone, "Installation", NULL, NULL, INSTALLATION_js_funcs, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, _installation_js_constructor_js_core_object_call_as_constructor_callback, NULL, NULL};

Log* log_construct (GType object_type) {
	Log * self = NULL;
	GError * _inner_error_ = NULL;
	self = (Log*) g_object_new (object_type, NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		GFileOutputStream* _tmp4_ = NULL;
		GFile* _tmp5_ = NULL;
		GFileOutputStream* _tmp6_ = NULL;
		GDataOutputStream* _tmp7_ = NULL;
		_tmp0_ = g_file_new_for_path ("/var/log/blankon-installer.log");
		file = _tmp0_;
		_tmp1_ = file;
		_tmp2_ = g_file_query_exists (_tmp1_, NULL);
		if (_tmp2_) {
			GFile* _tmp3_ = NULL;
			_tmp3_ = file;
			g_file_delete (_tmp3_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
		}
		_tmp5_ = file;
		_tmp6_ = g_file_create (_tmp5_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp4_ = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp7_ = g_data_output_stream_new ((GOutputStream*) _tmp4_);
		_g_object_unref0 (self->priv->stream);
		self->priv->stream = _tmp7_;
		_g_object_unref0 (_tmp4_);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp8_ = NULL;
		GError* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "%s\n", _tmp10_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Log* log_new (void) {
	return log_construct (TYPE_LOG);
}


void log_log_without_newline (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void log_log (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GDataOutputStream* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = self->priv->stream;
	g_data_output_stream_put_string (_tmp2_, "\n", NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Log* log_instance (void) {
	Log* result = NULL;
	Log* _tmp0_ = NULL;
	Log* _tmp2_ = NULL;
	Log* _tmp3_ = NULL;
	_tmp0_ = log__instance;
	if (_tmp0_ == NULL) {
		Log* _tmp1_ = NULL;
		_tmp1_ = log_new ();
		_g_object_unref0 (log__instance);
		log__instance = _tmp1_;
	}
	_tmp2_ = log__instance;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static void log_class_init (LogClass * klass) {
	log_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LogPrivate));
	G_OBJECT_CLASS (klass)->finalize = log_finalize;
}


static void log_instance_init (Log * self) {
	self->priv = LOG_GET_PRIVATE (self);
}


static void log_finalize (GObject* obj) {
	Log * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOG, Log);
	_g_object_unref0 (self->priv->stream);
	G_OBJECT_CLASS (log_parent_class)->finalize (obj);
}


GType log_get_type (void) {
	static volatile gsize log_type_id__volatile = 0;
	if (g_once_init_enter (&log_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) log_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Log), 0, (GInstanceInitFunc) log_instance_init, NULL };
		GType log_type_id;
		log_type_id = g_type_register_static (G_TYPE_OBJECT, "Log", &g_define_type_info, 0);
		g_once_init_leave (&log_type_id__volatile, log_type_id);
	}
	return log_type_id__volatile;
}


GType installation_state_get_type (void) {
	static volatile gsize installation_state_type_id__volatile = 0;
	if (g_once_init_enter (&installation_state_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STATE_NOT_STARTED, "INSTALLATION_STATE_NOT_STARTED", "not-started"}, {INSTALLATION_STATE_ON_GOING, "INSTALLATION_STATE_ON_GOING", "on-going"}, {INSTALLATION_STATE_ERROR, "INSTALLATION_STATE_ERROR", "error"}, {INSTALLATION_STATE_DONE, "INSTALLATION_STATE_DONE", "done"}, {0, NULL, NULL}};
		GType installation_state_type_id;
		installation_state_type_id = g_enum_register_static ("InstallationState", values);
		g_once_init_leave (&installation_state_type_id__volatile, installation_state_type_id);
	}
	return installation_state_type_id__volatile;
}


static GType installation_step_get_type (void) {
	static volatile gsize installation_step_type_id__volatile = 0;
	if (g_once_init_enter (&installation_step_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STEP_IDLE, "INSTALLATION_STEP_IDLE", "idle"}, {INSTALLATION_STEP_PARTITION, "INSTALLATION_STEP_PARTITION", "partition"}, {INSTALLATION_STEP_FS, "INSTALLATION_STEP_FS", "fs"}, {INSTALLATION_STEP_MOUNT, "INSTALLATION_STEP_MOUNT", "mount"}, {INSTALLATION_STEP_COPY, "INSTALLATION_STEP_COPY", "copy"}, {INSTALLATION_STEP_SETUP, "INSTALLATION_STEP_SETUP", "setup"}, {INSTALLATION_STEP_GRUB, "INSTALLATION_STEP_GRUB", "grub"}, {INSTALLATION_STEP_CLEANUP, "INSTALLATION_STEP_CLEANUP", "cleanup"}, {INSTALLATION_STEP_DONE, "INSTALLATION_STEP_DONE", "done"}, {0, NULL, NULL}};
		GType installation_step_type_id;
		installation_step_type_id = g_enum_register_static ("InstallationStep", values);
		g_once_init_leave (&installation_step_type_id__volatile, installation_step_type_id);
	}
	return installation_step_type_id__volatile;
}


static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_shutdown (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_reboot (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_translate (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_locale (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_timezone (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_locale_list (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_constructor (ctx, constructor, arguments, arguments_length1, exception);
	return result;
}


static void __lambda7_ (Installation* self) {
	installation_real_start (self);
}


static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self) {
	__lambda7_ ((Installation*) self);
}


static guint64 uint64_parse (const gchar* str) {
	guint64 result = 0ULL;
	const gchar* _tmp0_ = NULL;
	guint64 _tmp1_ = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoull (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


Installation* installation_construct_from_string (GType object_type, const gchar* uri) {
	Installation * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	self = (Installation*) g_object_new (object_type, NULL);
	installation_set_progress (self, 0);
	installation_set_state (self, (gint) INSTALLATION_STATE_NOT_STARTED);
	installation_set_description (self, "");
	installation_set_autologin (self, FALSE);
	_tmp0_ = uri;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "&", 0);
	{
		gchar** param_collection = NULL;
		gint param_collection_length1 = 0;
		gint _param_collection_size_ = 0;
		gint param_it = 0;
		param_collection = _tmp2_;
		param_collection_length1 = _vala_array_length (_tmp1_);
		for (param_it = 0; param_it < _vala_array_length (_tmp1_); param_it = param_it + 1) {
			gchar* _tmp3_ = NULL;
			gchar* param = NULL;
			_tmp3_ = g_strdup (param_collection[param_it]);
			param = _tmp3_;
			{
				gchar** entry = NULL;
				const gchar* _tmp4_ = NULL;
				gchar** _tmp5_ = NULL;
				gchar** _tmp6_ = NULL;
				gint entry_length1 = 0;
				gint _entry_size_ = 0;
				gchar** _tmp7_ = NULL;
				gint _tmp7__length1 = 0;
				_tmp4_ = param;
				_tmp6_ = _tmp5_ = g_strsplit (_tmp4_, "=", 0);
				entry = _tmp6_;
				entry_length1 = _vala_array_length (_tmp5_);
				_entry_size_ = entry_length1;
				_tmp7_ = entry;
				_tmp7__length1 = entry_length1;
				if (_tmp7__length1 == 2) {
					gchar** _tmp8_ = NULL;
					gint _tmp8__length1 = 0;
					const gchar* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					GQuark _tmp12_ = 0U;
					static GQuark _tmp11_label0 = 0;
					static GQuark _tmp11_label1 = 0;
					static GQuark _tmp11_label2 = 0;
					static GQuark _tmp11_label3 = 0;
					static GQuark _tmp11_label4 = 0;
					static GQuark _tmp11_label5 = 0;
					static GQuark _tmp11_label6 = 0;
					static GQuark _tmp11_label7 = 0;
					static GQuark _tmp11_label8 = 0;
					static GQuark _tmp11_label9 = 0;
					static GQuark _tmp11_label10 = 0;
					static GQuark _tmp11_label11 = 0;
					static GQuark _tmp11_label12 = 0;
					static GQuark _tmp11_label13 = 0;
					_tmp8_ = entry;
					_tmp8__length1 = entry_length1;
					_tmp9_ = _tmp8_[0];
					_tmp10_ = _tmp9_;
					_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
					if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("device")))) {
						switch (0) {
							default:
							{
								gchar** _tmp13_ = NULL;
								gint _tmp13__length1 = 0;
								const gchar* _tmp14_ = NULL;
								gint _tmp15_ = 0;
								_tmp13_ = entry;
								_tmp13__length1 = entry_length1;
								_tmp14_ = _tmp13_[1];
								_tmp15_ = atoi (_tmp14_);
								installation_set_device (self, _tmp15_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("partition")))) {
						switch (0) {
							default:
							{
								gchar** _tmp16_ = NULL;
								gint _tmp16__length1 = 0;
								const gchar* _tmp17_ = NULL;
								gint _tmp18_ = 0;
								_tmp16_ = entry;
								_tmp16__length1 = entry_length1;
								_tmp17_ = _tmp16_[1];
								_tmp18_ = atoi (_tmp17_);
								installation_set_partition (self, _tmp18_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("username")))) {
						switch (0) {
							default:
							{
								gchar** _tmp19_ = NULL;
								gint _tmp19__length1 = 0;
								const gchar* _tmp20_ = NULL;
								_tmp19_ = entry;
								_tmp19__length1 = entry_length1;
								_tmp20_ = _tmp19_[1];
								installation_set_user_name (self, _tmp20_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label3) ? _tmp11_label3 : (_tmp11_label3 = g_quark_from_static_string ("password")))) {
						switch (0) {
							default:
							{
								gchar** _tmp21_ = NULL;
								gint _tmp21__length1 = 0;
								const gchar* _tmp22_ = NULL;
								_tmp21_ = entry;
								_tmp21__length1 = entry_length1;
								_tmp22_ = _tmp21_[1];
								installation_set_password (self, _tmp22_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label4) ? _tmp11_label4 : (_tmp11_label4 = g_quark_from_static_string ("hostname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp23_ = NULL;
								gint _tmp23__length1 = 0;
								const gchar* _tmp24_ = NULL;
								_tmp23_ = entry;
								_tmp23__length1 = entry_length1;
								_tmp24_ = _tmp23_[1];
								installation_set_host_name (self, _tmp24_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label5) ? _tmp11_label5 : (_tmp11_label5 = g_quark_from_static_string ("fullname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp25_ = NULL;
								gint _tmp25__length1 = 0;
								const gchar* _tmp26_ = NULL;
								_tmp25_ = entry;
								_tmp25__length1 = entry_length1;
								_tmp26_ = _tmp25_[1];
								installation_set_full_name (self, _tmp26_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label6) ? _tmp11_label6 : (_tmp11_label6 = g_quark_from_static_string ("grubdevice")))) {
						switch (0) {
							default:
							{
								gchar** _tmp27_ = NULL;
								gint _tmp27__length1 = 0;
								const gchar* _tmp28_ = NULL;
								_tmp27_ = entry;
								_tmp27__length1 = entry_length1;
								_tmp28_ = _tmp27_[1];
								installation_set_grub_device (self, _tmp28_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label7) ? _tmp11_label7 : (_tmp11_label7 = g_quark_from_static_string ("language")))) {
						switch (0) {
							default:
							{
								gchar** _tmp29_ = NULL;
								gint _tmp29__length1 = 0;
								const gchar* _tmp30_ = NULL;
								_tmp29_ = entry;
								_tmp29__length1 = entry_length1;
								_tmp30_ = _tmp29_[1];
								installation_set_language (self, _tmp30_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label8) ? _tmp11_label8 : (_tmp11_label8 = g_quark_from_static_string ("region")))) {
						switch (0) {
							default:
							{
								gchar** _tmp31_ = NULL;
								gint _tmp31__length1 = 0;
								const gchar* _tmp32_ = NULL;
								_tmp31_ = entry;
								_tmp31__length1 = entry_length1;
								_tmp32_ = _tmp31_[1];
								installation_set_region (self, _tmp32_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label9) ? _tmp11_label9 : (_tmp11_label9 = g_quark_from_static_string ("keyboard")))) {
						switch (0) {
							default:
							{
								gchar** _tmp33_ = NULL;
								gint _tmp33__length1 = 0;
								const gchar* _tmp34_ = NULL;
								_tmp33_ = entry;
								_tmp33__length1 = entry_length1;
								_tmp34_ = _tmp33_[1];
								installation_set_keyboard (self, _tmp34_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label10) ? _tmp11_label10 : (_tmp11_label10 = g_quark_from_static_string ("autologin")))) {
						switch (0) {
							default:
							{
								gchar** _tmp35_ = NULL;
								gint _tmp35__length1 = 0;
								const gchar* _tmp36_ = NULL;
								_tmp35_ = entry;
								_tmp35__length1 = entry_length1;
								_tmp36_ = _tmp35_[1];
								installation_set_autologin (self, g_strcmp0 (_tmp36_, "true") == 0);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label11) ? _tmp11_label11 : (_tmp11_label11 = g_quark_from_static_string ("home")))) {
						switch (0) {
							default:
							{
								gchar** _tmp37_ = NULL;
								gint _tmp37__length1 = 0;
								const gchar* _tmp38_ = NULL;
								_tmp37_ = entry;
								_tmp37__length1 = entry_length1;
								_tmp38_ = _tmp37_[1];
								installation_set_home (self, _tmp38_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label12) ? _tmp11_label12 : (_tmp11_label12 = g_quark_from_static_string ("advancedMode")))) {
						switch (0) {
							default:
							{
								gchar** _tmp39_ = NULL;
								gint _tmp39__length1 = 0;
								const gchar* _tmp40_ = NULL;
								_tmp39_ = entry;
								_tmp39__length1 = entry_length1;
								_tmp40_ = _tmp39_[1];
								installation_set_advancedMode (self, g_strcmp0 (_tmp40_, "true") == 0);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label13) ? _tmp11_label13 : (_tmp11_label13 = g_quark_from_static_string ("steps")))) {
						switch (0) {
							default:
							{
								gchar** _tmp41_ = NULL;
								gint _tmp41__length1 = 0;
								const gchar* _tmp42_ = NULL;
								_tmp41_ = entry;
								_tmp41__length1 = entry_length1;
								_tmp42_ = _tmp41_[1];
								installation_set_steps (self, _tmp42_);
								break;
							}
						}
					}
				}
				entry = (_vala_array_free (entry, entry_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (param);
			}
		}
		param_collection = (_vala_array_free (param_collection, param_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	g_signal_connect_object (self, "installation-started", (GCallback) ___lambda7__installation_installation_started, self, 0);
	self->priv->installation_size = 4 * INSTALLATION_OneGig;
	{
		GFile* file = NULL;
		GFile* _tmp43_ = NULL;
		GFile* _tmp44_ = NULL;
		gboolean _tmp45_ = FALSE;
		_tmp43_ = g_file_new_for_path ("/live/image/.disk/installation_size");
		file = _tmp43_;
		_tmp44_ = file;
		_tmp45_ = g_file_query_exists (_tmp44_, NULL);
		if (_tmp45_) {
			GFileInputStream* _tmp46_ = NULL;
			GFile* _tmp47_ = NULL;
			GFileInputStream* _tmp48_ = NULL;
			GDataInputStream* dis = NULL;
			GDataInputStream* _tmp49_ = NULL;
			gsize l = 0UL;
			gchar* line = NULL;
			GDataInputStream* _tmp50_ = NULL;
			gsize _tmp51_ = 0UL;
			gchar* _tmp52_ = NULL;
			GDataInputStream* _tmp53_ = NULL;
			const gchar* _tmp54_ = NULL;
			_tmp47_ = file;
			_tmp48_ = g_file_read (_tmp47_, NULL, &_inner_error_);
			_tmp46_ = _tmp48_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp49_ = g_data_input_stream_new ((GInputStream*) _tmp46_);
			dis = _tmp49_;
			_tmp50_ = dis;
			_tmp52_ = g_data_input_stream_read_line (_tmp50_, &_tmp51_, NULL, &_inner_error_);
			l = _tmp51_;
			line = _tmp52_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp46_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp53_ = dis;
			g_input_stream_close ((GInputStream*) _tmp53_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp46_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp54_ = line;
			if (_tmp54_ != NULL) {
				const gchar* _tmp55_ = NULL;
				guint64 _tmp56_ = 0ULL;
				guint64 _tmp57_ = 0ULL;
				_tmp55_ = line;
				_tmp56_ = uint64_parse (_tmp55_);
				self->priv->installation_size = _tmp56_;
				_tmp57_ = self->priv->installation_size;
				if (_tmp57_ <= ((guint64) 0)) {
					self->priv->installation_size = 4 * INSTALLATION_OneGig;
				}
			}
			_g_free0 (line);
			_g_object_unref0 (dis);
			_g_object_unref0 (_tmp46_);
		}
		_g_object_unref0 (file);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp58_ = NULL;
		GError* _tmp59_ = NULL;
		const gchar* _tmp60_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp58_ = stderr;
		_tmp59_ = e;
		_tmp60_ = _tmp59_->message;
		fprintf (_tmp58_, "%s\n", _tmp60_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Installation* installation_new_from_string (const gchar* uri) {
	return installation_construct_from_string (TYPE_INSTALLATION, uri);
}


void installation_start (Installation* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "installation-started");
}


static void installation_real_start (Installation* self) {
	Log* _tmp0_ = NULL;
	Log* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = log_instance ();
	_tmp1_ = _tmp0_;
	log_log (_tmp1_, "START");
	_g_object_unref0 (_tmp1_);
	installation_set_state (self, (gint) INSTALLATION_STATE_ON_GOING);
	installation_do_next_job (self);
}


static void installation_do_next_job (Installation* self) {
	InstallationStep _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->last_step;
	switch (_tmp0_) {
		case INSTALLATION_STEP_IDLE:
		{
			Log* _tmp1_ = NULL;
			Log* _tmp2_ = NULL;
			installation_set_progress (self, 5);
			_tmp1_ = log_instance ();
			_tmp2_ = _tmp1_;
			log_log (_tmp2_, "PARTITION");
			_g_object_unref0 (_tmp2_);
			installation_do_partition (self);
			break;
		}
		case INSTALLATION_STEP_PARTITION:
		{
			Log* _tmp3_ = NULL;
			Log* _tmp4_ = NULL;
			installation_set_progress (self, 10);
			_tmp3_ = log_instance ();
			_tmp4_ = _tmp3_;
			log_log (_tmp4_, "FS");
			_g_object_unref0 (_tmp4_);
			installation_do_fs (self);
			break;
		}
		case INSTALLATION_STEP_FS:
		{
			Log* _tmp5_ = NULL;
			Log* _tmp6_ = NULL;
			_tmp5_ = log_instance ();
			_tmp6_ = _tmp5_;
			log_log (_tmp6_, "MOUNT");
			_g_object_unref0 (_tmp6_);
			installation_do_mount (self);
			break;
		}
		case INSTALLATION_STEP_MOUNT:
		{
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			installation_set_progress (self, 15);
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			log_log (_tmp8_, "COPY");
			_g_object_unref0 (_tmp8_);
			installation_do_copy (self);
			break;
		}
		case INSTALLATION_STEP_COPY:
		{
			Log* _tmp9_ = NULL;
			Log* _tmp10_ = NULL;
			installation_set_progress (self, 80);
			_tmp9_ = log_instance ();
			_tmp10_ = _tmp9_;
			log_log (_tmp10_, "SETUP");
			_g_object_unref0 (_tmp10_);
			installation_do_setup (self);
			break;
		}
		case INSTALLATION_STEP_SETUP:
		{
			Log* _tmp11_ = NULL;
			Log* _tmp12_ = NULL;
			installation_set_progress (self, 90);
			_tmp11_ = log_instance ();
			_tmp12_ = _tmp11_;
			log_log (_tmp12_, "GRUB");
			_g_object_unref0 (_tmp12_);
			installation_do_grub (self);
			break;
		}
		case INSTALLATION_STEP_GRUB:
		{
			Log* _tmp13_ = NULL;
			Log* _tmp14_ = NULL;
			_tmp13_ = log_instance ();
			_tmp14_ = _tmp13_;
			log_log (_tmp14_, "CLEANUP");
			_g_object_unref0 (_tmp14_);
			installation_do_cleanup (self);
			break;
		}
		case INSTALLATION_STEP_CLEANUP:
		{
			Log* _tmp15_ = NULL;
			Log* _tmp16_ = NULL;
			installation_set_progress (self, 100);
			_tmp15_ = log_instance ();
			_tmp16_ = _tmp15_;
			log_log (_tmp16_, "DONE");
			_g_object_unref0 (_tmp16_);
			installation_do_done (self);
			break;
		}
		case INSTALLATION_STEP_DONE:
		{
			gint _tmp17_ = 0;
			_tmp17_ = self->priv->_state;
			if (_tmp17_ != ((gint) INSTALLATION_STATE_ERROR)) {
				Log* _tmp18_ = NULL;
				Log* _tmp19_ = NULL;
				_tmp18_ = log_instance ();
				_tmp19_ = _tmp18_;
				log_log (_tmp19_, "ERROR");
				_g_object_unref0 (_tmp19_);
				installation_set_description (self, "Done");
			} else {
				Log* _tmp20_ = NULL;
				Log* _tmp21_ = NULL;
				_tmp20_ = log_instance ();
				_tmp21_ = _tmp20_;
				log_log (_tmp21_, "DONE");
				_g_object_unref0 (_tmp21_);
			}
			break;
		}
		default:
		break;
	}
}


static void installation_child_watch (Installation* self, GPid pid, gint status) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = status;
	_tmp2_ = WIFEXITED (_tmp1_);
	if (_tmp2_) {
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		_tmp3_ = status;
		_tmp4_ = WEXITSTATUS (_tmp3_);
		_tmp0_ = _tmp4_ == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp5_ = status;
		_tmp6_ = WEXITSTATUS (_tmp5_);
		if (_tmp6_ == 0) {
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			GPid _tmp9_ = 0;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			InstallationStep _tmp16_ = 0;
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			_tmp9_ = pid;
			_tmp10_ = g_strdup_printf ("%i", (gint) _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = g_strconcat ("Child ", _tmp11_, NULL);
			_tmp13_ = _tmp12_;
			_tmp14_ = g_strconcat (_tmp13_, " has finished it's task successfuly.", NULL);
			_tmp15_ = _tmp14_;
			log_log (_tmp8_, _tmp15_);
			_g_free0 (_tmp15_);
			_g_free0 (_tmp13_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp8_);
			_tmp16_ = self->priv->step;
			self->priv->last_step = _tmp16_;
			self->priv->step = INSTALLATION_STEP_IDLE;
		} else {
			Log* _tmp17_ = NULL;
			Log* _tmp18_ = NULL;
			GPid _tmp19_ = 0;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			gint _tmp26_ = 0;
			gint _tmp27_ = 0;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			_tmp17_ = log_instance ();
			_tmp18_ = _tmp17_;
			_tmp19_ = pid;
			_tmp20_ = g_strdup_printf ("%i", (gint) _tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat ("Child ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strconcat (_tmp23_, " has ended and return with ", NULL);
			_tmp25_ = _tmp24_;
			_tmp26_ = status;
			_tmp27_ = WEXITSTATUS (_tmp26_);
			_tmp28_ = g_strdup_printf ("%i", _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = g_strconcat (_tmp25_, _tmp29_, NULL);
			_tmp31_ = _tmp30_;
			log_log (_tmp18_, _tmp31_);
			_g_free0 (_tmp31_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp25_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
			_g_object_unref0 (_tmp18_);
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
		}
	} else {
		Log* _tmp32_ = NULL;
		Log* _tmp33_ = NULL;
		GPid _tmp34_ = 0;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		_tmp32_ = log_instance ();
		_tmp33_ = _tmp32_;
		_tmp34_ = pid;
		_tmp35_ = g_strdup_printf ("%i", (gint) _tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = g_strconcat ("Child ", _tmp36_, NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_strconcat (_tmp38_, " has ended and failed.", NULL);
		_tmp40_ = _tmp39_;
		log_log (_tmp33_, _tmp40_);
		_g_free0 (_tmp40_);
		_g_free0 (_tmp38_);
		_g_free0 (_tmp36_);
		_g_object_unref0 (_tmp33_);
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
	}
	installation_do_next_job (self);
}


static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gint pid = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	pid = 0;
	_tmp0_ = commands_to_run;
	_tmp0__length1 = commands_to_run_length1;
	_tmp1_ = installation_run (self, _tmp0_, _tmp0__length1);
	pid = _tmp1_;
	_tmp2_ = pid;
	if (_tmp2_ != 0) {
		InstallationStep _tmp3_ = 0;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = command_step;
		self->priv->step = _tmp3_;
		_tmp4_ = command_description;
		installation_set_description (self, _tmp4_);
	} else {
		const gchar* _tmp5_ = NULL;
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		_tmp5_ = error_description;
		installation_set_description (self, _tmp5_);
	}
}


static void installation_do_partition (Installation* self) {
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_advancedMode;
	if (_tmp0_ == TRUE) {
		gchar* _tmp1_ = NULL;
		gboolean can_continue = FALSE;
		Log* _tmp2_ = NULL;
		Log* _tmp3_ = NULL;
		Log* _tmp4_ = NULL;
		Log* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar** stepsArray = NULL;
		const gchar* _tmp7_ = NULL;
		gchar** _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gint stepsArray_length1 = 0;
		gint _stepsArray_size_ = 0;
		gchar** _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		const gchar* _tmp158_ = NULL;
		const gchar* _tmp159_ = NULL;
		gchar* _tmp160_ = NULL;
		Log* _tmp161_ = NULL;
		Log* _tmp162_ = NULL;
		const gchar* _tmp163_ = NULL;
		gchar* _tmp164_ = NULL;
		gchar* _tmp165_ = NULL;
		gchar* _tmp166_ = NULL;
		gchar* _tmp167_ = NULL;
		gboolean _tmp168_ = FALSE;
		_tmp1_ = g_strdup ("/dev/sda");
		_g_free0 (self->priv->device_path);
		self->priv->device_path = _tmp1_;
		installation_set_description (self, "Partitioning");
		self->priv->step = INSTALLATION_STEP_PARTITION;
		can_continue = FALSE;
		_tmp2_ = log_instance ();
		_tmp3_ = _tmp2_;
		log_log (_tmp3_, "Enter advanced partitioning ");
		_g_object_unref0 (_tmp3_);
		_tmp4_ = log_instance ();
		_tmp5_ = _tmp4_;
		_tmp6_ = self->priv->_steps;
		log_log (_tmp5_, _tmp6_);
		_g_object_unref0 (_tmp5_);
		_tmp7_ = self->priv->_steps;
		_tmp9_ = _tmp8_ = g_strsplit (_tmp7_, ",", 0);
		stepsArray = _tmp9_;
		stepsArray_length1 = _vala_array_length (_tmp8_);
		_stepsArray_size_ = stepsArray_length1;
		_tmp10_ = stepsArray;
		_tmp10__length1 = stepsArray_length1;
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
			s_collection = _tmp10_;
			s_collection_length1 = _tmp10__length1;
			for (s_it = 0; s_it < _tmp10__length1; s_it = s_it + 1) {
				gchar* _tmp11_ = NULL;
				gchar* s = NULL;
				_tmp11_ = g_strdup (s_collection[s_it]);
				s = _tmp11_;
				{
					gchar** splittedParams = NULL;
					const gchar* _tmp12_ = NULL;
					gchar** _tmp13_ = NULL;
					gchar** _tmp14_ = NULL;
					gint splittedParams_length1 = 0;
					gint _splittedParams_size_ = 0;
					Log* _tmp15_ = NULL;
					Log* _tmp16_ = NULL;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					const gchar* _tmp18_ = NULL;
					gchar** _tmp19_ = NULL;
					gint _tmp19__length1 = 0;
					const gchar* _tmp20_ = NULL;
					const gchar* _tmp21_ = NULL;
					GQuark _tmp23_ = 0U;
					static GQuark _tmp22_label0 = 0;
					static GQuark _tmp22_label1 = 0;
					static GQuark _tmp22_label2 = 0;
					_tmp12_ = s;
					_tmp14_ = _tmp13_ = g_strsplit (_tmp12_, ";", 0);
					splittedParams = _tmp14_;
					splittedParams_length1 = _vala_array_length (_tmp13_);
					_splittedParams_size_ = splittedParams_length1;
					_tmp15_ = log_instance ();
					_tmp16_ = _tmp15_;
					_tmp17_ = splittedParams;
					_tmp17__length1 = splittedParams_length1;
					_tmp18_ = _tmp17_[0];
					log_log (_tmp16_, _tmp18_);
					_g_object_unref0 (_tmp16_);
					_tmp19_ = splittedParams;
					_tmp19__length1 = splittedParams_length1;
					_tmp20_ = _tmp19_[0];
					_tmp21_ = _tmp20_;
					_tmp23_ = (NULL == _tmp21_) ? 0 : g_quark_from_string (_tmp21_);
					if (_tmp23_ == ((0 != _tmp22_label0) ? _tmp22_label0 : (_tmp22_label0 = g_quark_from_static_string ("create")))) {
						switch (0) {
							default:
							{
								Device* dev = NULL;
								const gchar* _tmp24_ = NULL;
								Device* _tmp25_ = NULL;
								gchar** range = NULL;
								gchar** _tmp26_ = NULL;
								gint _tmp26__length1 = 0;
								const gchar* _tmp27_ = NULL;
								gchar** _tmp28_ = NULL;
								gchar** _tmp29_ = NULL;
								gint range_length1 = 0;
								gint _range_size_ = 0;
								Log* _tmp30_ = NULL;
								Log* _tmp31_ = NULL;
								gchar** _tmp32_ = NULL;
								gint _tmp32__length1 = 0;
								const gchar* _tmp33_ = NULL;
								gchar* _tmp34_ = NULL;
								gchar* _tmp35_ = NULL;
								Log* _tmp36_ = NULL;
								Log* _tmp37_ = NULL;
								gchar** _tmp38_ = NULL;
								gint _tmp38__length1 = 0;
								const gchar* _tmp39_ = NULL;
								gchar* _tmp40_ = NULL;
								gchar* _tmp41_ = NULL;
								gchar* mount = NULL;
								gchar* _tmp42_ = NULL;
								gboolean _tmp43_ = FALSE;
								gchar** _tmp44_ = NULL;
								gint _tmp44__length1 = 0;
								const gchar* _tmp45_ = NULL;
								gint new_partition = 0;
								Device* _tmp51_ = NULL;
								gchar** _tmp52_ = NULL;
								gint _tmp52__length1 = 0;
								const gchar* _tmp53_ = NULL;
								guint64 _tmp54_ = 0ULL;
								gchar** _tmp55_ = NULL;
								gint _tmp55__length1 = 0;
								const gchar* _tmp56_ = NULL;
								guint64 _tmp57_ = 0ULL;
								gchar** _tmp58_ = NULL;
								gint _tmp58__length1 = 0;
								const gchar* _tmp59_ = NULL;
								gchar** _tmp60_ = NULL;
								gint _tmp60__length1 = 0;
								const gchar* _tmp61_ = NULL;
								const gchar* _tmp62_ = NULL;
								gint _tmp63_ = 0;
								gchar** _tmp64_ = NULL;
								gint _tmp64__length1 = 0;
								const gchar* _tmp65_ = NULL;
								gchar** _tmp79_ = NULL;
								gint _tmp79__length1 = 0;
								const gchar* _tmp80_ = NULL;
								gchar* _tmp81_ = NULL;
								gchar* _tmp82_ = NULL;
								gchar* _tmp83_ = NULL;
								gchar* _tmp84_ = NULL;
								const gchar* _tmp85_ = NULL;
								gchar* _tmp86_ = NULL;
								gchar* _tmp87_ = NULL;
								gint _tmp88_ = 0;
								gchar* _tmp89_ = NULL;
								gchar* _tmp90_ = NULL;
								gchar* _tmp91_ = NULL;
								gchar* _tmp92_ = NULL;
								Log* _tmp93_ = NULL;
								Log* _tmp94_ = NULL;
								gint _tmp95_ = 0;
								gchar* _tmp96_ = NULL;
								gchar* _tmp97_ = NULL;
								gchar* _tmp98_ = NULL;
								gchar* _tmp99_ = NULL;
								_tmp24_ = self->priv->device_path;
								_tmp25_ = device_new_from_name (_tmp24_);
								dev = _tmp25_;
								_tmp26_ = splittedParams;
								_tmp26__length1 = splittedParams_length1;
								_tmp27_ = _tmp26_[3];
								_tmp29_ = _tmp28_ = g_strsplit (_tmp27_, "-", 0);
								range = _tmp29_;
								range_length1 = _vala_array_length (_tmp28_);
								_range_size_ = range_length1;
								_tmp30_ = log_instance ();
								_tmp31_ = _tmp30_;
								_tmp32_ = range;
								_tmp32__length1 = range_length1;
								_tmp33_ = _tmp32_[0];
								_tmp34_ = g_strconcat ("range_start :", _tmp33_, NULL);
								_tmp35_ = _tmp34_;
								log_log (_tmp31_, _tmp35_);
								_g_free0 (_tmp35_);
								_g_object_unref0 (_tmp31_);
								_tmp36_ = log_instance ();
								_tmp37_ = _tmp36_;
								_tmp38_ = range;
								_tmp38__length1 = range_length1;
								_tmp39_ = _tmp38_[1];
								_tmp40_ = g_strconcat ("range_start :", _tmp39_, NULL);
								_tmp41_ = _tmp40_;
								log_log (_tmp37_, _tmp41_);
								_g_free0 (_tmp41_);
								_g_object_unref0 (_tmp37_);
								_tmp42_ = g_strdup ("none");
								mount = _tmp42_;
								_tmp44_ = splittedParams;
								_tmp44__length1 = splittedParams_length1;
								_tmp45_ = _tmp44_[4];
								if (g_strcmp0 (_tmp45_, "root") == 0) {
									_tmp43_ = TRUE;
								} else {
									gchar** _tmp46_ = NULL;
									gint _tmp46__length1 = 0;
									const gchar* _tmp47_ = NULL;
									_tmp46_ = splittedParams;
									_tmp46__length1 = splittedParams_length1;
									_tmp47_ = _tmp46_[4];
									_tmp43_ = g_strcmp0 (_tmp47_, "home") == 0;
								}
								if (_tmp43_) {
									gchar** _tmp48_ = NULL;
									gint _tmp48__length1 = 0;
									const gchar* _tmp49_ = NULL;
									gchar* _tmp50_ = NULL;
									_tmp48_ = splittedParams;
									_tmp48__length1 = splittedParams_length1;
									_tmp49_ = _tmp48_[4];
									_tmp50_ = g_strdup (_tmp49_);
									_g_free0 (mount);
									mount = _tmp50_;
								}
								_tmp51_ = dev;
								_tmp52_ = range;
								_tmp52__length1 = range_length1;
								_tmp53_ = _tmp52_[0];
								_tmp54_ = uint64_parse (_tmp53_);
								_tmp55_ = range;
								_tmp55__length1 = range_length1;
								_tmp56_ = _tmp55_[1];
								_tmp57_ = uint64_parse (_tmp56_);
								_tmp58_ = splittedParams;
								_tmp58__length1 = splittedParams_length1;
								_tmp59_ = _tmp58_[2];
								_tmp60_ = splittedParams;
								_tmp60__length1 = splittedParams_length1;
								_tmp61_ = _tmp60_[1];
								_tmp62_ = mount;
								_tmp63_ = device_create_partition (_tmp51_, _tmp54_, _tmp57_, _tmp59_, _tmp61_, _tmp62_, &_inner_error_);
								new_partition = _tmp63_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (mount);
									range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
									_g_object_unref0 (dev);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp64_ = splittedParams;
								_tmp64__length1 = splittedParams_length1;
								_tmp65_ = _tmp64_[4];
								if (g_strcmp0 (_tmp65_, "root") == 0) {
									Log* _tmp66_ = NULL;
									Log* _tmp67_ = NULL;
									gint _tmp68_ = 0;
									gchar* _tmp69_ = NULL;
									_tmp66_ = log_instance ();
									_tmp67_ = _tmp66_;
									log_log (_tmp67_, "root");
									_g_object_unref0 (_tmp67_);
									_tmp68_ = new_partition;
									_tmp69_ = g_strdup_printf ("%i", _tmp68_);
									_g_free0 (self->root);
									self->root = _tmp69_;
								} else {
									gchar** _tmp70_ = NULL;
									gint _tmp70__length1 = 0;
									const gchar* _tmp71_ = NULL;
									_tmp70_ = splittedParams;
									_tmp70__length1 = splittedParams_length1;
									_tmp71_ = _tmp70_[4];
									if (g_strcmp0 (_tmp71_, "home") == 0) {
										Log* _tmp72_ = NULL;
										Log* _tmp73_ = NULL;
										gint _tmp74_ = 0;
										gchar* _tmp75_ = NULL;
										gchar* _tmp76_ = NULL;
										_tmp72_ = log_instance ();
										_tmp73_ = _tmp72_;
										log_log (_tmp73_, "home");
										_g_object_unref0 (_tmp73_);
										_tmp74_ = new_partition;
										_tmp75_ = g_strdup_printf ("%i", _tmp74_);
										_tmp76_ = _tmp75_;
										installation_set_home (self, _tmp76_);
										_g_free0 (_tmp76_);
										self->separatedHome = TRUE;
									} else {
										Log* _tmp77_ = NULL;
										Log* _tmp78_ = NULL;
										_tmp77_ = log_instance ();
										_tmp78_ = _tmp77_;
										log_log (_tmp78_, "neither root or home");
										_g_object_unref0 (_tmp78_);
									}
								}
								_tmp79_ = splittedParams;
								_tmp79__length1 = splittedParams_length1;
								_tmp80_ = _tmp79_[2];
								_tmp81_ = g_strconcat ("/sbin/mkfs.", _tmp80_, NULL);
								_tmp82_ = _tmp81_;
								_tmp83_ = g_strconcat (_tmp82_, " ", NULL);
								_tmp84_ = _tmp83_;
								_tmp85_ = self->priv->device_path;
								_tmp86_ = g_strconcat (_tmp84_, _tmp85_, NULL);
								_tmp87_ = _tmp86_;
								_tmp88_ = new_partition;
								_tmp89_ = g_strdup_printf ("%i", _tmp88_);
								_tmp90_ = _tmp89_;
								_tmp91_ = g_strconcat (_tmp87_, _tmp90_, NULL);
								_tmp92_ = _tmp91_;
								g_spawn_command_line_sync (_tmp92_, NULL, NULL, NULL, &_inner_error_);
								_g_free0 (_tmp92_);
								_g_free0 (_tmp90_);
								_g_free0 (_tmp87_);
								_g_free0 (_tmp84_);
								_g_free0 (_tmp82_);
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (mount);
									range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
									_g_object_unref0 (dev);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp93_ = log_instance ();
								_tmp94_ = _tmp93_;
								_tmp95_ = new_partition;
								_tmp96_ = g_strdup_printf ("%i", _tmp95_);
								_tmp97_ = _tmp96_;
								_tmp98_ = g_strconcat ("newly created ", _tmp97_, NULL);
								_tmp99_ = _tmp98_;
								log_log (_tmp94_, _tmp99_);
								_g_free0 (_tmp99_);
								_g_free0 (_tmp97_);
								_g_object_unref0 (_tmp94_);
								_g_free0 (mount);
								range = (_vala_array_free (range, range_length1, (GDestroyNotify) g_free), NULL);
								_g_object_unref0 (dev);
								break;
							}
						}
					} else if (_tmp23_ == ((0 != _tmp22_label1) ? _tmp22_label1 : (_tmp22_label1 = g_quark_from_static_string ("format")))) {
						switch (0) {
							default:
							{
								gchar* id = NULL;
								gchar** _tmp100_ = NULL;
								gint _tmp100__length1 = 0;
								const gchar* _tmp101_ = NULL;
								gchar* _tmp102_ = NULL;
								gchar** _tmp103_ = NULL;
								gint _tmp103__length1 = 0;
								const gchar* _tmp104_ = NULL;
								gchar* _tmp105_ = NULL;
								gchar* _tmp106_ = NULL;
								gchar* _tmp107_ = NULL;
								gchar* _tmp108_ = NULL;
								const gchar* _tmp109_ = NULL;
								gchar* _tmp110_ = NULL;
								gchar* _tmp111_ = NULL;
								gchar** _tmp112_ = NULL;
								gint _tmp112__length1 = 0;
								const gchar* _tmp113_ = NULL;
								gchar* _tmp114_ = NULL;
								gchar* _tmp115_ = NULL;
								Log* _tmp116_ = NULL;
								Log* _tmp117_ = NULL;
								gchar** _tmp118_ = NULL;
								gint _tmp118__length1 = 0;
								const gchar* _tmp119_ = NULL;
								gchar* _tmp120_ = NULL;
								gchar* _tmp121_ = NULL;
								gchar** _tmp122_ = NULL;
								gint _tmp122__length1 = 0;
								const gchar* _tmp123_ = NULL;
								_tmp100_ = splittedParams;
								_tmp100__length1 = splittedParams_length1;
								_tmp101_ = _tmp100_[1];
								_tmp102_ = g_strdup (_tmp101_);
								id = _tmp102_;
								_tmp103_ = splittedParams;
								_tmp103__length1 = splittedParams_length1;
								_tmp104_ = _tmp103_[2];
								_tmp105_ = g_strconcat ("/sbin/mkfs.", _tmp104_, NULL);
								_tmp106_ = _tmp105_;
								_tmp107_ = g_strconcat (_tmp106_, " ", NULL);
								_tmp108_ = _tmp107_;
								_tmp109_ = self->priv->device_path;
								_tmp110_ = g_strconcat (_tmp108_, _tmp109_, NULL);
								_tmp111_ = _tmp110_;
								_tmp112_ = splittedParams;
								_tmp112__length1 = splittedParams_length1;
								_tmp113_ = _tmp112_[1];
								_tmp114_ = g_strconcat (_tmp111_, _tmp113_, NULL);
								_tmp115_ = _tmp114_;
								g_spawn_command_line_sync (_tmp115_, NULL, NULL, NULL, &_inner_error_);
								_g_free0 (_tmp115_);
								_g_free0 (_tmp111_);
								_g_free0 (_tmp108_);
								_g_free0 (_tmp106_);
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (id);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp116_ = log_instance ();
								_tmp117_ = _tmp116_;
								_tmp118_ = splittedParams;
								_tmp118__length1 = splittedParams_length1;
								_tmp119_ = _tmp118_[1];
								_tmp120_ = g_strconcat ("should format partition ", _tmp119_, NULL);
								_tmp121_ = _tmp120_;
								log_log (_tmp117_, _tmp121_);
								_g_free0 (_tmp121_);
								_g_object_unref0 (_tmp117_);
								_tmp122_ = splittedParams;
								_tmp122__length1 = splittedParams_length1;
								_tmp123_ = _tmp122_[3];
								if (g_strcmp0 (_tmp123_, "root") == 0) {
									Log* _tmp124_ = NULL;
									Log* _tmp125_ = NULL;
									gchar** _tmp126_ = NULL;
									gint _tmp126__length1 = 0;
									const gchar* _tmp127_ = NULL;
									gchar* _tmp128_ = NULL;
									_tmp124_ = log_instance ();
									_tmp125_ = _tmp124_;
									log_log (_tmp125_, "root");
									_g_object_unref0 (_tmp125_);
									_tmp126_ = splittedParams;
									_tmp126__length1 = splittedParams_length1;
									_tmp127_ = _tmp126_[1];
									_tmp128_ = g_strdup (_tmp127_);
									_g_free0 (self->root);
									self->root = _tmp128_;
								} else {
									gchar** _tmp129_ = NULL;
									gint _tmp129__length1 = 0;
									const gchar* _tmp130_ = NULL;
									_tmp129_ = splittedParams;
									_tmp129__length1 = splittedParams_length1;
									_tmp130_ = _tmp129_[3];
									if (g_strcmp0 (_tmp130_, "home") == 0) {
										gchar** _tmp131_ = NULL;
										gint _tmp131__length1 = 0;
										const gchar* _tmp132_ = NULL;
										_tmp131_ = splittedParams;
										_tmp131__length1 = splittedParams_length1;
										_tmp132_ = _tmp131_[1];
										installation_set_home (self, _tmp132_);
										self->separatedHome = TRUE;
									}
								}
								_g_free0 (id);
								break;
							}
						}
					} else if (_tmp23_ == ((0 != _tmp22_label2) ? _tmp22_label2 : (_tmp22_label2 = g_quark_from_static_string ("delete")))) {
						switch (0) {
							default:
							{
								Device* dev = NULL;
								const gchar* _tmp133_ = NULL;
								Device* _tmp134_ = NULL;
								gchar* id = NULL;
								gchar** _tmp135_ = NULL;
								gint _tmp135__length1 = 0;
								const gchar* _tmp136_ = NULL;
								gchar* _tmp137_ = NULL;
								Log* _tmp138_ = NULL;
								Log* _tmp139_ = NULL;
								gchar** _tmp140_ = NULL;
								gint _tmp140__length1 = 0;
								const gchar* _tmp141_ = NULL;
								gchar* _tmp142_ = NULL;
								gchar* _tmp143_ = NULL;
								gint _result_ = 0;
								Device* _tmp144_ = NULL;
								gchar** _tmp145_ = NULL;
								gint _tmp145__length1 = 0;
								const gchar* _tmp146_ = NULL;
								gint _tmp147_ = 0;
								gint _tmp148_ = 0;
								Log* _tmp149_ = NULL;
								Log* _tmp150_ = NULL;
								gint _tmp151_ = 0;
								gchar* _tmp152_ = NULL;
								gchar* _tmp153_ = NULL;
								gchar* _tmp154_ = NULL;
								gchar* _tmp155_ = NULL;
								gchar* _tmp156_ = NULL;
								gchar* _tmp157_ = NULL;
								_tmp133_ = self->priv->device_path;
								_tmp134_ = device_new_from_name (_tmp133_);
								dev = _tmp134_;
								_tmp135_ = splittedParams;
								_tmp135__length1 = splittedParams_length1;
								_tmp136_ = _tmp135_[1];
								_tmp137_ = g_strdup (_tmp136_);
								id = _tmp137_;
								_tmp138_ = log_instance ();
								_tmp139_ = _tmp138_;
								_tmp140_ = splittedParams;
								_tmp140__length1 = splittedParams_length1;
								_tmp141_ = _tmp140_[1];
								_tmp142_ = g_strconcat ("should delete partition ", _tmp141_, NULL);
								_tmp143_ = _tmp142_;
								log_log (_tmp139_, _tmp143_);
								_g_free0 (_tmp143_);
								_g_object_unref0 (_tmp139_);
								_tmp144_ = dev;
								_tmp145_ = splittedParams;
								_tmp145__length1 = splittedParams_length1;
								_tmp146_ = _tmp145_[1];
								_tmp147_ = atoi (_tmp146_);
								_tmp148_ = device_delete_partition (_tmp144_, _tmp147_, &_inner_error_);
								_result_ = _tmp148_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (id);
									_g_object_unref0 (dev);
									splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (s);
									stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp149_ = log_instance ();
								_tmp150_ = _tmp149_;
								_tmp151_ = _result_;
								_tmp152_ = g_strdup_printf ("%i", _tmp151_);
								_tmp153_ = _tmp152_;
								_tmp154_ = g_strconcat ("\nDeleted :", _tmp153_, NULL);
								_tmp155_ = _tmp154_;
								_tmp156_ = g_strconcat (_tmp155_, "\n", NULL);
								_tmp157_ = _tmp156_;
								log_log (_tmp150_, _tmp157_);
								_g_free0 (_tmp157_);
								_g_free0 (_tmp155_);
								_g_free0 (_tmp153_);
								_g_object_unref0 (_tmp150_);
								_g_free0 (id);
								_g_object_unref0 (dev);
								break;
							}
						}
					}
					splittedParams = (_vala_array_free (splittedParams, splittedParams_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (s);
				}
			}
		}
		_tmp158_ = self->priv->device_path;
		_tmp159_ = self->root;
		_tmp160_ = g_strconcat (_tmp158_, _tmp159_, NULL);
		_g_free0 (self->priv->partition_path);
		self->priv->partition_path = _tmp160_;
		_tmp161_ = log_instance ();
		_tmp162_ = _tmp161_;
		_tmp163_ = self->priv->partition_path;
		_tmp164_ = g_strconcat ("\nTarget :", _tmp163_, NULL);
		_tmp165_ = _tmp164_;
		_tmp166_ = g_strconcat (_tmp165_, "\n", NULL);
		_tmp167_ = _tmp166_;
		log_log (_tmp162_, _tmp167_);
		_g_free0 (_tmp167_);
		_g_free0 (_tmp165_);
		_g_object_unref0 (_tmp162_);
		_tmp168_ = self->separatedHome;
		if (_tmp168_ == TRUE) {
			const gchar* _tmp169_ = NULL;
			const gchar* _tmp170_ = NULL;
			gchar* _tmp171_ = NULL;
			gchar* _tmp172_ = NULL;
			Log* _tmp173_ = NULL;
			Log* _tmp174_ = NULL;
			const gchar* _tmp175_ = NULL;
			gchar* _tmp176_ = NULL;
			gchar* _tmp177_ = NULL;
			gchar* _tmp178_ = NULL;
			gchar* _tmp179_ = NULL;
			_tmp169_ = self->priv->device_path;
			_tmp170_ = self->priv->_home;
			_tmp171_ = g_strconcat (_tmp169_, _tmp170_, NULL);
			_tmp172_ = _tmp171_;
			installation_set_home (self, _tmp172_);
			_g_free0 (_tmp172_);
			_tmp173_ = log_instance ();
			_tmp174_ = _tmp173_;
			_tmp175_ = self->priv->_home;
			_tmp176_ = g_strconcat ("\nHome :", _tmp175_, NULL);
			_tmp177_ = _tmp176_;
			_tmp178_ = g_strconcat (_tmp177_, "\n", NULL);
			_tmp179_ = _tmp178_;
			log_log (_tmp174_, _tmp179_);
			_g_free0 (_tmp179_);
			_g_free0 (_tmp177_);
			_g_object_unref0 (_tmp174_);
		}
		self->priv->last_step = INSTALLATION_STEP_PARTITION;
		installation_do_next_job (self);
		stepsArray = (_vala_array_free (stepsArray, stepsArray_length1, (GDestroyNotify) g_free), NULL);
	} else {
		GeeArrayList* d = NULL;
		GeeArrayList* _tmp180_ = NULL;
		gboolean inconsistent = FALSE;
		gboolean _tmp181_ = FALSE;
		GeeArrayList* _tmp182_ = NULL;
		gboolean _tmp204_ = FALSE;
		GeeArrayList* partitions = NULL;
		GeeArrayList* _tmp205_ = NULL;
		gint _tmp206_ = 0;
		gpointer _tmp207_ = NULL;
		Device* _tmp208_ = NULL;
		GeeArrayList* _tmp209_ = NULL;
		GeeArrayList* _tmp210_ = NULL;
		GeeArrayList* _tmp211_ = NULL;
		GeeArrayList* _tmp212_ = NULL;
		GeeArrayList* _tmp213_ = NULL;
		gint _tmp214_ = 0;
		gpointer _tmp215_ = NULL;
		Device* _tmp216_ = NULL;
		gchar* _tmp217_ = NULL;
		Log* _tmp218_ = NULL;
		Log* _tmp219_ = NULL;
		GeeArrayList* _tmp220_ = NULL;
		gint _tmp221_ = 0;
		gpointer _tmp222_ = NULL;
		DevicePartition* _tmp223_ = NULL;
		DevicePartitionType _tmp224_ = 0;
		DevicePartitionType _tmp225_ = 0;
		gboolean _tmp226_ = FALSE;
		_tmp180_ = parted_get_devices (TRUE);
		d = _tmp180_;
		inconsistent = FALSE;
		_tmp182_ = d;
		if (_tmp182_ != NULL) {
			gint _tmp183_ = 0;
			GeeArrayList* _tmp184_ = NULL;
			gint _tmp185_ = 0;
			gint _tmp186_ = 0;
			_tmp183_ = self->priv->_device;
			_tmp184_ = d;
			_tmp185_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp184_);
			_tmp186_ = _tmp185_;
			_tmp181_ = _tmp183_ > _tmp186_;
		} else {
			_tmp181_ = FALSE;
		}
		if (_tmp181_) {
			inconsistent = TRUE;
		} else {
			gboolean _tmp187_ = FALSE;
			GeeArrayList* _tmp188_ = NULL;
			gint _tmp189_ = 0;
			gpointer _tmp190_ = NULL;
			Device* _tmp191_ = NULL;
			GeeArrayList* _tmp192_ = NULL;
			GeeArrayList* _tmp193_ = NULL;
			gboolean _tmp194_ = FALSE;
			_tmp188_ = d;
			_tmp189_ = self->priv->_device;
			_tmp190_ = gee_abstract_list_get ((GeeAbstractList*) _tmp188_, _tmp189_);
			_tmp191_ = (Device*) _tmp190_;
			_tmp192_ = device_get_partitions (_tmp191_);
			_tmp193_ = _tmp192_;
			_tmp194_ = _tmp193_ != NULL;
			_g_object_unref0 (_tmp191_);
			if (_tmp194_) {
				gint _tmp195_ = 0;
				GeeArrayList* _tmp196_ = NULL;
				gint _tmp197_ = 0;
				gpointer _tmp198_ = NULL;
				Device* _tmp199_ = NULL;
				GeeArrayList* _tmp200_ = NULL;
				GeeArrayList* _tmp201_ = NULL;
				gint _tmp202_ = 0;
				gint _tmp203_ = 0;
				_tmp195_ = self->priv->_partition;
				_tmp196_ = d;
				_tmp197_ = self->priv->_device;
				_tmp198_ = gee_abstract_list_get ((GeeAbstractList*) _tmp196_, _tmp197_);
				_tmp199_ = (Device*) _tmp198_;
				_tmp200_ = device_get_partitions (_tmp199_);
				_tmp201_ = _tmp200_;
				_tmp202_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp201_);
				_tmp203_ = _tmp202_;
				_tmp187_ = _tmp195_ > _tmp203_;
				_g_object_unref0 (_tmp199_);
			} else {
				_tmp187_ = FALSE;
			}
			if (_tmp187_) {
				inconsistent = TRUE;
			}
		}
		_tmp204_ = inconsistent;
		if (_tmp204_) {
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			installation_set_description (self, "Inconsistent partition record");
			_g_object_unref0 (d);
			return;
		}
		_tmp205_ = d;
		_tmp206_ = self->priv->_device;
		_tmp207_ = gee_abstract_list_get ((GeeAbstractList*) _tmp205_, _tmp206_);
		_tmp208_ = (Device*) _tmp207_;
		_tmp209_ = device_get_partitions (_tmp208_);
		_tmp210_ = _tmp209_;
		_tmp211_ = _g_object_ref0 (_tmp210_);
		_tmp212_ = _tmp211_;
		_g_object_unref0 (_tmp208_);
		partitions = _tmp212_;
		_tmp213_ = d;
		_tmp214_ = self->priv->_device;
		_tmp215_ = gee_abstract_list_get ((GeeAbstractList*) _tmp213_, _tmp214_);
		_tmp216_ = (Device*) _tmp215_;
		_tmp217_ = device_get_path (_tmp216_);
		_g_free0 (self->priv->device_path);
		self->priv->device_path = _tmp217_;
		_g_object_unref0 (_tmp216_);
		installation_set_description (self, "Partitioning");
		self->priv->step = INSTALLATION_STEP_PARTITION;
		_tmp218_ = log_instance ();
		_tmp219_ = _tmp218_;
		log_log (_tmp219_, "Enter simple partitioning");
		_g_object_unref0 (_tmp219_);
		_tmp220_ = partitions;
		_tmp221_ = self->priv->_partition;
		_tmp222_ = gee_abstract_list_get ((GeeAbstractList*) _tmp220_, _tmp221_);
		_tmp223_ = (DevicePartition*) _tmp222_;
		_tmp224_ = device_partition_get_ptype (_tmp223_);
		_tmp225_ = _tmp224_;
		_tmp226_ = _tmp225_ == DEVICE_PARTITION_TYPE_FREESPACE;
		_g_object_unref0 (_tmp223_);
		if (_tmp226_) {
			Device* device = NULL;
			const gchar* _tmp227_ = NULL;
			Device* _tmp228_ = NULL;
			gboolean can_continue = FALSE;
			gint new_partition = 0;
			gboolean _tmp278_ = FALSE;
			GeeArrayList* _tmp279_ = NULL;
			GeeArrayList* _tmp280_ = NULL;
			const gchar* _tmp281_ = NULL;
			gint _tmp282_ = 0;
			gchar* _tmp283_ = NULL;
			gchar* _tmp284_ = NULL;
			gchar* _tmp285_ = NULL;
			_tmp227_ = self->priv->device_path;
			_tmp228_ = device_new_from_name (_tmp227_);
			device = _tmp228_;
			can_continue = FALSE;
			new_partition = -1;
			{
				guint64 swap_size = 0ULL;
				GeeArrayList* _tmp229_ = NULL;
				GeeArrayList* _tmp230_ = NULL;
				gboolean _tmp231_ = FALSE;
				gboolean _tmp232_ = FALSE;
				gboolean _tmp233_ = FALSE;
				gint _tmp249_ = 0;
				Device* _tmp250_ = NULL;
				GeeArrayList* _tmp251_ = NULL;
				gint _tmp252_ = 0;
				gpointer _tmp253_ = NULL;
				DevicePartition* _tmp254_ = NULL;
				guint64 _tmp255_ = 0ULL;
				guint64 _tmp256_ = 0ULL;
				GeeArrayList* _tmp257_ = NULL;
				gint _tmp258_ = 0;
				gpointer _tmp259_ = NULL;
				DevicePartition* _tmp260_ = NULL;
				guint64 _tmp261_ = 0ULL;
				guint64 _tmp262_ = 0ULL;
				guint64 _tmp263_ = 0ULL;
				gint _tmp264_ = 0;
				gint _tmp265_ = 0;
				Log* _tmp266_ = NULL;
				Log* _tmp267_ = NULL;
				gint _tmp268_ = 0;
				gchar* _tmp269_ = NULL;
				gchar* _tmp270_ = NULL;
				gchar* _tmp271_ = NULL;
				gchar* _tmp272_ = NULL;
				gint _tmp273_ = 0;
				swap_size = (guint64) 0;
				_tmp229_ = swap_collector_get_partitions ();
				_tmp230_ = _tmp229_;
				_tmp231_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp230_);
				_tmp232_ = _tmp231_;
				_tmp233_ = _tmp232_;
				_g_object_unref0 (_tmp230_);
				if (_tmp233_) {
					GeeArrayList* _tmp234_ = NULL;
					gint _tmp235_ = 0;
					gpointer _tmp236_ = NULL;
					DevicePartition* _tmp237_ = NULL;
					guint64 _tmp238_ = 0ULL;
					guint64 _tmp239_ = 0ULL;
					guint64 _tmp240_ = 0ULL;
					gboolean _tmp241_ = FALSE;
					_tmp234_ = partitions;
					_tmp235_ = self->priv->_partition;
					_tmp236_ = gee_abstract_list_get ((GeeAbstractList*) _tmp234_, _tmp235_);
					_tmp237_ = (DevicePartition*) _tmp236_;
					_tmp238_ = device_partition_get_size (_tmp237_);
					_tmp239_ = _tmp238_;
					_tmp240_ = self->priv->installation_size;
					_tmp241_ = (_tmp239_ - INSTALLATION_OneGig) > _tmp240_;
					_g_object_unref0 (_tmp237_);
					if (_tmp241_) {
						Log* _tmp242_ = NULL;
						Log* _tmp243_ = NULL;
						guint64 _tmp244_ = 0ULL;
						gchar* _tmp245_ = NULL;
						gchar* _tmp246_ = NULL;
						gchar* _tmp247_ = NULL;
						gchar* _tmp248_ = NULL;
						swap_size = INSTALLATION_OneGig;
						_tmp242_ = log_instance ();
						_tmp243_ = _tmp242_;
						_tmp244_ = swap_size;
						_tmp245_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp244_);
						_tmp246_ = _tmp245_;
						_tmp247_ = g_strconcat ("No swap detected, creating swap along with partition creation, swap si" \
"ze = ", _tmp246_, NULL);
						_tmp248_ = _tmp247_;
						log_log (_tmp243_, _tmp248_);
						_g_free0 (_tmp248_);
						_g_free0 (_tmp246_);
						_g_object_unref0 (_tmp243_);
					}
				}
				swap_size = INSTALLATION_OneGig;
				_tmp250_ = device;
				_tmp251_ = partitions;
				_tmp252_ = self->priv->_partition;
				_tmp253_ = gee_abstract_list_get ((GeeAbstractList*) _tmp251_, _tmp252_);
				_tmp254_ = (DevicePartition*) _tmp253_;
				_tmp255_ = device_partition_get_start (_tmp254_);
				_tmp256_ = _tmp255_;
				_tmp257_ = partitions;
				_tmp258_ = self->priv->_partition;
				_tmp259_ = gee_abstract_list_get ((GeeAbstractList*) _tmp257_, _tmp258_);
				_tmp260_ = (DevicePartition*) _tmp259_;
				_tmp261_ = device_partition_get_end (_tmp260_);
				_tmp262_ = _tmp261_;
				_tmp263_ = swap_size;
				_tmp264_ = device_create_partition_simple (_tmp250_, _tmp256_, _tmp262_, "ext4", _tmp263_, &_inner_error_);
				_tmp265_ = _tmp264_;
				_g_object_unref0 (_tmp260_);
				_g_object_unref0 (_tmp254_);
				_tmp249_ = _tmp265_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == DEVICE_ERROR) {
						goto __catch2_device_error;
					}
					_g_object_unref0 (device);
					_g_object_unref0 (partitions);
					_g_object_unref0 (d);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				new_partition = _tmp249_;
				_tmp266_ = log_instance ();
				_tmp267_ = _tmp266_;
				_tmp268_ = new_partition;
				_tmp269_ = g_strdup_printf ("%i", _tmp268_);
				_tmp270_ = _tmp269_;
				_tmp271_ = g_strconcat ("Partition creation returns new partition ID: ", _tmp270_, NULL);
				_tmp272_ = _tmp271_;
				log_log (_tmp267_, _tmp272_);
				_g_free0 (_tmp272_);
				_g_free0 (_tmp270_);
				_g_object_unref0 (_tmp267_);
				_tmp273_ = new_partition;
				if (_tmp273_ != (-1)) {
					can_continue = TRUE;
				}
			}
			goto __finally2;
			__catch2_device_error:
			{
				GError* e = NULL;
				Log* _tmp274_ = NULL;
				Log* _tmp275_ = NULL;
				GError* _tmp276_ = NULL;
				const gchar* _tmp277_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp274_ = log_instance ();
				_tmp275_ = _tmp274_;
				_tmp276_ = e;
				_tmp277_ = _tmp276_->message;
				log_log_without_newline (_tmp275_, _tmp277_);
				_g_object_unref0 (_tmp275_);
				_g_error_free0 (e);
			}
			__finally2:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (device);
				_g_object_unref0 (partitions);
				_g_object_unref0 (d);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp278_ = can_continue;
			if (_tmp278_ == FALSE) {
				self->priv->step = INSTALLATION_STEP_DONE;
				self->priv->last_step = INSTALLATION_STEP_DONE;
				installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
				installation_set_description (self, "Error while doing partition");
				_g_object_unref0 (device);
				_g_object_unref0 (partitions);
				_g_object_unref0 (d);
				return;
			}
			_tmp279_ = parted_get_devices (FALSE);
			_tmp280_ = _tmp279_;
			_g_object_unref0 (_tmp280_);
			_tmp281_ = self->priv->device_path;
			_tmp282_ = new_partition;
			_tmp283_ = g_strdup_printf ("%i", _tmp282_);
			_tmp284_ = _tmp283_;
			_tmp285_ = g_strconcat (_tmp281_, _tmp284_, NULL);
			_g_free0 (self->priv->partition_path);
			self->priv->partition_path = _tmp285_;
			_g_free0 (_tmp284_);
			_g_object_unref0 (device);
		} else {
			GeeArrayList* _tmp286_ = NULL;
			gint _tmp287_ = 0;
			gpointer _tmp288_ = NULL;
			Device* _tmp289_ = NULL;
			gchar* _tmp290_ = NULL;
			gchar* _tmp291_ = NULL;
			GeeArrayList* _tmp292_ = NULL;
			gint _tmp293_ = 0;
			gpointer _tmp294_ = NULL;
			DevicePartition* _tmp295_ = NULL;
			gint _tmp296_ = 0;
			gint _tmp297_ = 0;
			gchar* _tmp298_ = NULL;
			gchar* _tmp299_ = NULL;
			gchar* _tmp300_ = NULL;
			_tmp286_ = d;
			_tmp287_ = self->priv->_device;
			_tmp288_ = gee_abstract_list_get ((GeeAbstractList*) _tmp286_, _tmp287_);
			_tmp289_ = (Device*) _tmp288_;
			_tmp290_ = device_get_path (_tmp289_);
			_tmp291_ = _tmp290_;
			_tmp292_ = partitions;
			_tmp293_ = self->priv->_partition;
			_tmp294_ = gee_abstract_list_get ((GeeAbstractList*) _tmp292_, _tmp293_);
			_tmp295_ = (DevicePartition*) _tmp294_;
			_tmp296_ = device_partition_get_number (_tmp295_);
			_tmp297_ = _tmp296_;
			_tmp298_ = g_strdup_printf ("%i", _tmp297_);
			_tmp299_ = _tmp298_;
			_tmp300_ = g_strconcat (_tmp291_, _tmp299_, NULL);
			_g_free0 (self->priv->partition_path);
			self->priv->partition_path = _tmp300_;
			_g_free0 (_tmp299_);
			_g_object_unref0 (_tmp295_);
			_g_free0 (_tmp291_);
			_g_object_unref0 (_tmp289_);
		}
		self->priv->last_step = INSTALLATION_STEP_PARTITION;
		installation_do_next_job (self);
		_g_object_unref0 (partitions);
		_g_object_unref0 (d);
	}
}


static void installation_do_fs (Installation* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_advancedMode;
	if (_tmp0_ == FALSE) {
		gchar** c = NULL;
		gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar** _tmp4_ = NULL;
		gint c_length1 = 0;
		gint _c_size_ = 0;
		gchar** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		_tmp1_ = g_strdup ("/sbin/mkfs.ext4");
		_tmp2_ = self->priv->partition_path;
		_tmp3_ = g_strdup (_tmp2_);
		_tmp4_ = g_new0 (gchar*, 2 + 1);
		_tmp4_[0] = _tmp1_;
		_tmp4_[1] = _tmp3_;
		c = _tmp4_;
		c_length1 = 2;
		_c_size_ = c_length1;
		_tmp5_ = c;
		_tmp5__length1 = c_length1;
		installation_do_simple_command_with_args (self, _tmp5_, _tmp5__length1, INSTALLATION_STEP_FS, "Installing filesystem", "Unable to install filesystem");
		c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
	}
}


static void installation_do_mount (Installation* self) {
	gchar** c = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_mkdir ("/target", 0700);
	_tmp0_ = g_strdup ("/bin/mount");
	_tmp1_ = self->priv->partition_path;
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = g_strdup ("/target");
	_tmp4_ = g_new0 (gchar*, 3 + 1);
	_tmp4_[0] = _tmp0_;
	_tmp4_[1] = _tmp2_;
	_tmp4_[2] = _tmp3_;
	c = _tmp4_;
	c_length1 = 3;
	_c_size_ = c_length1;
	_tmp5_ = c;
	_tmp5__length1 = c_length1;
	installation_do_simple_command_with_args (self, _tmp5_, _tmp5__length1, INSTALLATION_STEP_MOUNT, "Mounting filesystem ", "Unable to mount filesystem");
	_tmp6_ = self->separatedHome;
	if (_tmp6_) {
		gchar** c_home = NULL;
		gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar** _tmp11_ = NULL;
		gint c_home_length1 = 0;
		gint _c_home_size_ = 0;
		gchar** _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		g_mkdir ("/test_home", 0700);
		_tmp7_ = g_strdup ("/bin/mount");
		_tmp8_ = self->priv->_home;
		_tmp9_ = g_strdup (_tmp8_);
		_tmp10_ = g_strdup ("/test_home");
		_tmp11_ = g_new0 (gchar*, 3 + 1);
		_tmp11_[0] = _tmp7_;
		_tmp11_[1] = _tmp9_;
		_tmp11_[2] = _tmp10_;
		c_home = _tmp11_;
		c_home_length1 = 3;
		_c_home_size_ = c_home_length1;
		_tmp12_ = c_home;
		_tmp12__length1 = c_home_length1;
		installation_do_simple_command_with_args (self, _tmp12_, _tmp12__length1, INSTALLATION_STEP_MOUNT, "Mounting home filesystem ", "Unable to mount filesystem");
		c_home = (_vala_array_free (c_home, c_home_length1, (GDestroyNotify) g_free), NULL);
	}
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gchar** c = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	InstallationStep _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_to_run != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	_tmp0_ = command_to_run;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	c = _tmp2_;
	c_length1 = 1;
	_c_size_ = c_length1;
	_tmp3_ = command_step;
	_tmp4_ = command_description;
	_tmp5_ = error_description;
	installation_do_simple_command_with_args (self, c, c_length1, _tmp3_, _tmp4_, _tmp5_);
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_copy (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-copy-fs", INSTALLATION_STEP_COPY, "Copying filesystem", "Unable to copy filesystem");
}


static void installation_do_setup (Installation* self) {
	gchar* content = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* swaps = NULL;
	gchar* _tmp14_ = NULL;
	const gchar* _tmp30_ = NULL;
	gchar* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_user_name;
	_tmp1_ = self->priv->_password;
	_tmp2_ = g_strdup_printf ("%s:%s\n", _tmp0_, _tmp1_);
	content = _tmp2_;
	_tmp3_ = content;
	utils_write_simple_file ("/tmp/user-pass", _tmp3_);
	_tmp4_ = self->priv->_autologin;
	_tmp5_ = self->priv->_user_name;
	_tmp6_ = g_strdup_printf ("%d %s\n", (gint) _tmp4_, _tmp5_);
	_g_free0 (content);
	content = _tmp6_;
	_tmp7_ = content;
	utils_write_simple_file ("/tmp/user-setup", _tmp7_);
	_tmp8_ = self->priv->_full_name;
	_tmp9_ = g_strdup_printf ("%s\n\n\n\n\n", _tmp8_);
	_g_free0 (content);
	content = _tmp9_;
	_tmp10_ = content;
	utils_write_simple_file ("/tmp/user-info", _tmp10_);
	_tmp11_ = self->priv->_host_name;
	_tmp12_ = g_strdup_printf ("%s\n", _tmp11_);
	_g_free0 (content);
	content = _tmp12_;
	_tmp13_ = content;
	utils_write_simple_file ("/tmp/hostname", _tmp13_);
	swap_collector_reset ();
	_tmp14_ = g_strdup ("");
	swaps = _tmp14_;
	{
		GeeArrayList* _p_list = NULL;
		GeeArrayList* _tmp15_ = NULL;
		gint _p_size = 0;
		GeeArrayList* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _p_index = 0;
		_tmp15_ = swap_collector_get_partitions ();
		_p_list = _tmp15_;
		_tmp16_ = _p_list;
		_tmp17_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp16_);
		_tmp18_ = _tmp17_;
		_p_size = _tmp18_;
		_p_index = -1;
		while (TRUE) {
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gchar* p = NULL;
			GeeArrayList* _tmp22_ = NULL;
			gint _tmp23_ = 0;
			gpointer _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			const gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			_tmp19_ = _p_index;
			_p_index = _tmp19_ + 1;
			_tmp20_ = _p_index;
			_tmp21_ = _p_size;
			if (!(_tmp20_ < _tmp21_)) {
				break;
			}
			_tmp22_ = _p_list;
			_tmp23_ = _p_index;
			_tmp24_ = gee_abstract_list_get ((GeeAbstractList*) _tmp22_, _tmp23_);
			p = (gchar*) _tmp24_;
			_tmp25_ = swaps;
			_tmp26_ = p;
			_tmp27_ = g_strconcat (_tmp26_, "\n", NULL);
			_tmp28_ = _tmp27_;
			_tmp29_ = g_strconcat (_tmp25_, _tmp28_, NULL);
			_g_free0 (swaps);
			swaps = _tmp29_;
			_g_free0 (_tmp28_);
			_g_free0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	_tmp30_ = swaps;
	_tmp31_ = g_strdup_printf ("%s", _tmp30_);
	_g_free0 (content);
	content = _tmp31_;
	_tmp32_ = content;
	utils_write_simple_file ("/tmp/swaps", _tmp32_);
	installation_do_simple_command (self, "/sbin/b-i-setup-fs", INSTALLATION_STEP_SETUP, "Setting up", "Unable to setup installation");
	_g_free0 (swaps);
	_g_free0 (content);
}


static void installation_do_grub (Installation* self) {
	gchar* device = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar** c = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar** _tmp8_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->device_path;
	_tmp1_ = g_strdup (_tmp0_);
	device = _tmp1_;
	_tmp2_ = device;
	if (g_strcmp0 (_tmp2_, "") == 0) {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->device_path;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (device);
		device = _tmp4_;
	}
	_tmp5_ = g_strdup ("/sbin/b-i-install-grub");
	_tmp6_ = device;
	_tmp7_ = g_strdup (_tmp6_);
	_tmp8_ = g_new0 (gchar*, 2 + 1);
	_tmp8_[0] = _tmp5_;
	_tmp8_[1] = _tmp7_;
	c = _tmp8_;
	c_length1 = 2;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_GRUB, "Installing GRUB", "Unable to install GRUB");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (device);
}


static void installation_do_cleanup (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-cleanup", INSTALLATION_STEP_CLEANUP, "Cleaning up", "Unable to properly clean up");
}


static void installation_do_done (Installation* self) {
	g_return_if_fail (self != NULL);
	self->priv->step = INSTALLATION_STEP_DONE;
	self->priv->last_step = INSTALLATION_STEP_DONE;
	installation_set_state (self, (gint) INSTALLATION_STATE_DONE);
	installation_do_next_job (self);
}


static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDERR: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDOUT: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix) {
	gboolean result = FALSE;
	GIOStatus ret = 0;
	gchar* msg = NULL;
	gsize len = 0UL;
	gboolean _result_ = FALSE;
	GIOCondition _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	g_return_val_if_fail (prefix != NULL, FALSE);
	_result_ = TRUE;
	_tmp0_ = condition;
	if ((_tmp0_ & G_IO_HUP) == G_IO_HUP) {
		_result_ = FALSE;
	}
	{
		while (TRUE) {
			GIOStatus _tmp1_ = 0;
			GIOChannel* _tmp2_ = NULL;
			gchar* _tmp3_ = NULL;
			gsize _tmp4_ = 0UL;
			GIOStatus _tmp5_ = 0;
			Log* _tmp6_ = NULL;
			Log* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			_tmp2_ = gio;
			_tmp5_ = g_io_channel_read_line (_tmp2_, &_tmp3_, &_tmp4_, NULL, &_inner_error_);
			_g_free0 (msg);
			msg = _tmp3_;
			len = _tmp4_;
			_tmp1_ = _tmp5_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_IO_CHANNEL_ERROR) {
					goto __catch3_g_io_channel_error;
				}
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch3_g_convert_error;
				}
				_g_free0 (msg);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			if (!(_tmp1_ == G_IO_STATUS_NORMAL)) {
				break;
			}
			_tmp6_ = log_instance ();
			_tmp7_ = _tmp6_;
			_tmp8_ = prefix;
			_tmp9_ = msg;
			_tmp10_ = g_strconcat (_tmp8_, _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			log_log_without_newline (_tmp7_, _tmp11_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp7_);
		}
	}
	goto __finally3;
	__catch3_g_io_channel_error:
	{
		GError* e = NULL;
		Log* _tmp12_ = NULL;
		Log* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp12_ = log_instance ();
		_tmp13_ = _tmp12_;
		_tmp14_ = prefix;
		_tmp15_ = g_strconcat (_tmp14_, "Error reading: ", NULL);
		_tmp16_ = _tmp15_;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		_tmp19_ = g_strconcat (_tmp16_, _tmp18_, NULL);
		_tmp20_ = _tmp19_;
		log_log (_tmp13_, _tmp20_);
		_g_free0 (_tmp20_);
		_g_free0 (_tmp16_);
		_g_object_unref0 (_tmp13_);
		_g_error_free0 (e);
	}
	goto __finally3;
	__catch3_g_convert_error:
	{
		GError* e = NULL;
		Log* _tmp21_ = NULL;
		Log* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		GError* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp21_ = log_instance ();
		_tmp22_ = _tmp21_;
		_tmp23_ = prefix;
		_tmp24_ = g_strconcat (_tmp23_, "Error reading: ", NULL);
		_tmp25_ = _tmp24_;
		_tmp26_ = e;
		_tmp27_ = _tmp26_->message;
		_tmp28_ = g_strconcat (_tmp25_, _tmp27_, NULL);
		_tmp29_ = _tmp28_;
		log_log (_tmp22_, _tmp29_);
		_g_free0 (_tmp29_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp22_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (msg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _result_;
	_g_free0 (msg);
	return result;
}


static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self) {
	installation_child_watch ((Installation*) self, pid, status);
}


static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stdout ((Installation*) self, source, condition);
	return result;
}


static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stderr ((Installation*) self, source, condition);
	return result;
}


static gint installation_run (Installation* self, gchar** command, int command_length1) {
	gint result = 0;
	gchar** env = NULL;
	gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* cmd_log = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint fd_out = 0;
	gint fd_err = 0;
	gint child_pid = 0;
	Log* _tmp12_ = NULL;
	Log* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	guint w = 0U;
	gint _tmp26_ = 0;
	guint _tmp27_ = 0U;
	Log* _tmp28_ = NULL;
	Log* _tmp29_ = NULL;
	gint _tmp30_ = 0;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	guint _tmp37_ = 0U;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	GIOChannel* _tmp43_ = NULL;
	gint _tmp44_ = 0;
	GIOChannel* _tmp45_ = NULL;
	GIOChannel* _tmp46_ = NULL;
	guint _tmp47_ = 0U;
	GIOChannel* _tmp50_ = NULL;
	guint _tmp51_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_strdup ("LC_ALL=C");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	env = _tmp1_;
	env_length1 = 1;
	_env_size_ = env_length1;
	_tmp2_ = g_strdup ("Running command: '");
	cmd_log = _tmp2_;
	_tmp3_ = command;
	_tmp3__length1 = command_length1;
	{
		gchar** c_collection = NULL;
		gint c_collection_length1 = 0;
		gint _c_collection_size_ = 0;
		gint c_it = 0;
		c_collection = _tmp3_;
		c_collection_length1 = _tmp3__length1;
		for (c_it = 0; c_it < _tmp3__length1; c_it = c_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* c = NULL;
			_tmp4_ = g_strdup (c_collection[c_it]);
			c = _tmp4_;
			{
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp5_ = cmd_log;
				_tmp6_ = c;
				_tmp7_ = g_strconcat (_tmp6_, " ", NULL);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
				_g_free0 (cmd_log);
				cmd_log = _tmp9_;
				_g_free0 (_tmp8_);
				_g_free0 (c);
			}
		}
	}
	_tmp10_ = cmd_log;
	_tmp11_ = g_strconcat (_tmp10_, "'", NULL);
	_g_free0 (cmd_log);
	cmd_log = _tmp11_;
	_tmp12_ = log_instance ();
	_tmp13_ = _tmp12_;
	_tmp14_ = cmd_log;
	log_log (_tmp13_, _tmp14_);
	_g_object_unref0 (_tmp13_);
	{
		gchar** _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		gchar** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		GPid _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		_tmp15_ = command;
		_tmp15__length1 = command_length1;
		_tmp16_ = env;
		_tmp16__length1 = env_length1;
		g_spawn_async_with_pipes ("/tmp/", _tmp15_, _tmp16_, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp17_, NULL, &_tmp18_, &_tmp19_, &_inner_error_);
		child_pid = (gint) _tmp17_;
		fd_out = _tmp18_;
		fd_err = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		Log* _tmp20_ = NULL;
		Log* _tmp21_ = NULL;
		GError* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = log_instance ();
		_tmp21_ = _tmp20_;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		_tmp24_ = g_strconcat ("Error running: ", _tmp23_, NULL);
		_tmp25_ = _tmp24_;
		log_log (_tmp21_, _tmp25_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp21_);
		result = -1;
		_g_error_free0 (e);
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp26_ = child_pid;
	_tmp27_ = g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, (GPid) _tmp26_, _installation_child_watch_gchild_watch_func, g_object_ref (self), g_object_unref);
	w = _tmp27_;
	_tmp28_ = log_instance ();
	_tmp29_ = _tmp28_;
	_tmp30_ = child_pid;
	_tmp31_ = g_strdup_printf ("%i", _tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat ("Child is spawn with PID: ", _tmp32_, NULL);
	_tmp34_ = _tmp33_;
	_tmp35_ = g_strconcat (_tmp34_, " and watched as ", NULL);
	_tmp36_ = _tmp35_;
	_tmp37_ = w;
	_tmp38_ = g_strdup_printf ("%u", _tmp37_);
	_tmp39_ = _tmp38_;
	_tmp40_ = g_strconcat (_tmp36_, _tmp39_, NULL);
	_tmp41_ = _tmp40_;
	log_log (_tmp29_, _tmp41_);
	_g_free0 (_tmp41_);
	_g_free0 (_tmp39_);
	_g_free0 (_tmp36_);
	_g_free0 (_tmp34_);
	_g_free0 (_tmp32_);
	_g_object_unref0 (_tmp29_);
	_tmp42_ = fd_out;
	_tmp43_ = g_io_channel_unix_new (_tmp42_);
	_g_io_channel_unref0 (self->priv->io_out);
	self->priv->io_out = _tmp43_;
	_tmp44_ = fd_err;
	_tmp45_ = g_io_channel_unix_new (_tmp44_);
	_g_io_channel_unref0 (self->priv->io_err);
	self->priv->io_err = _tmp45_;
	_tmp46_ = self->priv->io_out;
	_tmp47_ = g_io_add_watch (_tmp46_, G_IO_IN | G_IO_HUP, _installation_watch_stdout_gio_func, self);
	if (!(_tmp47_ != ((guint) 0))) {
		Log* _tmp48_ = NULL;
		Log* _tmp49_ = NULL;
		_tmp48_ = log_instance ();
		_tmp49_ = _tmp48_;
		log_log (_tmp49_, "Error watching stdout for cmd_log");
		_g_object_unref0 (_tmp49_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp50_ = self->priv->io_err;
	_tmp51_ = g_io_add_watch (_tmp50_, G_IO_IN | G_IO_HUP, _installation_watch_stderr_gio_func, self);
	if (!(_tmp51_ != ((guint) 0))) {
		Log* _tmp52_ = NULL;
		Log* _tmp53_ = NULL;
		_tmp52_ = log_instance ();
		_tmp53_ = _tmp52_;
		log_log (_tmp53_, "Error watching stderr for cmd_log");
		_g_object_unref0 (_tmp53_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = child_pid;
	_g_free0 (cmd_log);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_status (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_start (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* s = NULL;
	void* _tmp4_ = NULL;
	void* f = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	void* _tmp8_ = NULL;
	void* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	void* _tmp11_ = NULL;
	void* _tmp12_ = NULL;
	void* _tmp13_ = NULL;
	void* _tmp14_ = NULL;
	void* _tmp15_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	void* _tmp19_ = NULL;
	void** _tmp20_ = NULL;
	gint _tmp20__length1 = 0;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (constructor != NULL, NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = ctx;
	_tmp2_ = c;
	_tmp3_ = JSObjectMake (_tmp1_, _tmp2_, NULL);
	o = _tmp3_;
	_tmp4_ = JSStringCreateWithUTF8CString ("getStatus");
	s = _tmp4_;
	_tmp5_ = ctx;
	_tmp6_ = s;
	_tmp7_ = JSObjectMakeFunctionWithCallback (_tmp5_, _tmp6_, _installation_js_get_status_js_core_object_call_as_function_callback);
	f = _tmp7_;
	_tmp8_ = o;
	_tmp9_ = ctx;
	_tmp10_ = s;
	_tmp11_ = f;
	JSObjectSetProperty (_tmp9_, _tmp8_, _tmp10_, _tmp11_, 0, NULL);
	_tmp12_ = JSStringCreateWithUTF8CString ("start");
	_JSStringRelease0 (s);
	s = _tmp12_;
	_tmp13_ = ctx;
	_tmp14_ = s;
	_tmp15_ = JSObjectMakeFunctionWithCallback (_tmp13_, _tmp14_, _installation_js_start_js_core_object_call_as_function_callback);
	_0 (f);
	f = _tmp15_;
	_tmp16_ = o;
	_tmp17_ = ctx;
	_tmp18_ = s;
	_tmp19_ = f;
	JSObjectSetProperty (_tmp17_, _tmp16_, _tmp18_, _tmp19_, 0, NULL);
	_tmp20_ = arguments;
	_tmp20__length1 = arguments_length1;
	if (_tmp20__length1 == 1) {
		void** _tmp21_ = NULL;
		gint _tmp21__length1 = 0;
		void* _tmp22_ = NULL;
		void* _tmp23_ = NULL;
		void* _tmp24_ = NULL;
		gchar buffer[1024] = {0};
		void* _tmp25_ = NULL;
		Installation* i = NULL;
		Installation* _tmp26_ = NULL;
		void* _tmp27_ = NULL;
		Installation* _tmp28_ = NULL;
		_tmp21_ = arguments;
		_tmp21__length1 = arguments_length1;
		_tmp22_ = _tmp21_[0];
		_tmp23_ = ctx;
		_tmp24_ = JSValueToStringCopy (_tmp23_, _tmp22_, NULL);
		_JSStringRelease0 (s);
		s = _tmp24_;
		_tmp25_ = s;
		JSStringGetUTF8CString (_tmp25_, buffer, (gsize) 1024);
		_tmp26_ = installation_new_from_string ((const gchar*) buffer);
		i = _tmp26_;
		_tmp27_ = o;
		_tmp28_ = i;
		JSObjectSetPrivate (_tmp27_, _tmp28_);
	}
	result = o;
	_0 (f);
	_JSStringRelease0 (s);
	_JSClassRelease0 (c);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		gchar* _result_ = NULL;
		Installation* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		Installation* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		Installation* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gchar* _tmp10_ = NULL;
		void* s = NULL;
		const gchar* _tmp11_ = NULL;
		void* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		_tmp4_ = i;
		_tmp5_ = _tmp4_->priv->_state;
		_tmp6_ = i;
		_tmp7_ = _tmp6_->priv->_description;
		_tmp8_ = i;
		_tmp9_ = _tmp8_->priv->_progress;
		_tmp10_ = g_strdup_printf ("({ 'status': %d, 'description': '%s', 'progress': %d })", _tmp5_, _tmp7_, _tmp9_);
		_result_ = _tmp10_;
		_tmp11_ = _result_;
		_tmp12_ = JSStringCreateWithUTF8CString (_tmp11_);
		s = _tmp12_;
		_tmp13_ = ctx;
		_tmp14_ = s;
		_tmp15_ = JSEvaluateScript (_tmp13_, _tmp14_, NULL, NULL, 0, NULL);
		result = _tmp15_;
		_JSStringRelease0 (s);
		_g_free0 (_result_);
		_g_object_unref0 (i);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp16_ = ctx;
	_tmp17_ = JSValueMakeUndefined (_tmp16_);
	result = _tmp17_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		Installation* _tmp4_ = NULL;
		_tmp4_ = i;
		installation_start (_tmp4_);
	}
	_tmp5_ = ctx;
	_tmp6_ = JSValueMakeUndefined (_tmp5_);
	result = _tmp6_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	gtk_main_quit ();
	_tmp0_ = ctx;
	_tmp1_ = JSValueMakeUndefined (_tmp0_);
	result = _tmp1_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* location = NULL;
	gchar* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = g_strdup ("/tmp/post-install.sh");
	location = _tmp0_;
	utils_write_simple_file (location, "sudo /sbin/reboot\n");
	gtk_main_quit ();
	_tmp1_ = ctx;
	_tmp2_ = JSValueMakeUndefined (_tmp1_);
	result = _tmp2_;
	_g_free0 (location);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _result_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		void* _tmp16_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = _ ((const gchar*) _tmp11_);
		_tmp13_ = JSStringCreateWithUTF8CString (_tmp12_);
		_JSStringRelease0 (s);
		s = _tmp13_;
		_tmp14_ = ctx;
		_tmp15_ = s;
		_tmp16_ = JSValueMakeString (_tmp14_, _tmp15_);
		_result_ = _tmp16_;
		_JSStringRelease0 (s);
		s = NULL;
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		result = _result_;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp17_ = ctx;
	_tmp18_ = JSValueMakeUndefined (_tmp17_);
	result = _tmp18_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp19_ = NULL;
	void* _tmp20_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		FILE* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		gchar* _tmp13_ = NULL;
		gint _tmp13__length1 = 0;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = stdout;
		_tmp12_ = buffer;
		_tmp12__length1 = buffer_length1;
		fprintf (_tmp11_, "Changing timezone to %s\n", (const gchar*) _tmp12_);
		g_unlink ("/etc/localtime");
		_tmp13_ = buffer;
		_tmp13__length1 = buffer_length1;
		_tmp14_ = g_strdup_printf ("/usr/share/zoneinfo/%s", (const gchar*) _tmp13_);
		_tmp15_ = _tmp14_;
		symlink (_tmp15_, "/etc/localtime");
		_g_free0 (_tmp15_);
		_tmp16_ = buffer;
		_tmp16__length1 = buffer_length1;
		_tmp17_ = g_strdup_printf ("TZ=%s\nexport TZ\n", (const gchar*) _tmp16_);
		_tmp18_ = _tmp17_;
		utils_write_simple_file ("/run/timezone", _tmp18_);
		_g_free0 (_tmp18_);
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp19_ = ctx;
	_tmp20_ = JSValueMakeUndefined (_tmp19_);
	result = _tmp20_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp21_ = NULL;
	void* _tmp22_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* x = NULL;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		FILE* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gint _tmp17__length1 = 0;
		gchar* _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = setlocale (LC_ALL, (const gchar*) _tmp11_);
		_tmp13_ = g_strdup (_tmp12_);
		x = _tmp13_;
		_tmp14_ = stdout;
		_tmp15_ = buffer;
		_tmp15__length1 = buffer_length1;
		_tmp16_ = x;
		fprintf (_tmp14_, "Changing locale to %s: %s\n", (const gchar*) _tmp15_, _tmp16_);
		bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
		bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
		textdomain (GETTEXT_PACKAGE);
		_tmp17_ = buffer;
		_tmp17__length1 = buffer_length1;
		_tmp18_ = buffer;
		_tmp18__length1 = buffer_length1;
		_tmp19_ = g_strdup_printf ("LC_ALL=%s\nLANG=%s\n", (const gchar*) _tmp17_, (const gchar*) _tmp18_);
		_tmp20_ = _tmp19_;
		utils_write_simple_file ("/run/locale", _tmp20_);
		_g_free0 (_tmp20_);
		g_spawn_command_line_sync ("/bin/cp /run/locale /etc/default/locale", NULL, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (x);
			buffer = (g_free (buffer), NULL);
			_JSStringRelease0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		_g_free0 (x);
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp21_ = ctx;
	_tmp22_ = JSValueMakeUndefined (_tmp21_);
	result = _tmp22_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* normal_output = NULL;
	gchar* error_output = NULL;
	gint status = 0;
	gchar** args = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	gchar** env = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* _result_ = NULL;
	gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar** _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	const gchar* _tmp29_ = NULL;
	gchar* _tmp30_ = NULL;
	void* s = NULL;
	const gchar* _tmp31_ = NULL;
	void* _tmp32_ = NULL;
	void* _tmp33_ = NULL;
	void* _tmp34_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = g_strdup ("/usr/bin/locale");
	_tmp1_ = g_strdup ("-a");
	_tmp2_ = g_new0 (gchar*, 2 + 1);
	_tmp2_[0] = _tmp0_;
	_tmp2_[1] = _tmp1_;
	args = _tmp2_;
	args_length1 = 2;
	_args_size_ = args_length1;
	_tmp3_ = g_strdup ("LC_ALL=C");
	_tmp4_ = g_new0 (gchar*, 1 + 1);
	_tmp4_[0] = _tmp3_;
	env = _tmp4_;
	env_length1 = 1;
	_env_size_ = env_length1;
	{
		gchar** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		_tmp5_ = args;
		_tmp5__length1 = args_length1;
		_tmp6_ = env;
		_tmp6__length1 = env_length1;
		g_spawn_sync ("/tmp", _tmp5_, _tmp6_, G_SPAWN_LEAVE_DESCRIPTORS_OPEN, NULL, NULL, &_tmp7_, &_tmp8_, &_tmp9_, &_inner_error_);
		_g_free0 (normal_output);
		normal_output = _tmp7_;
		_g_free0 (error_output);
		error_output = _tmp8_;
		status = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (error_output);
		_g_free0 (normal_output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp10_ = g_strdup ("[");
	_result_ = _tmp10_;
	_tmp11_ = normal_output;
	_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp13_;
		line_collection_length1 = _vala_array_length (_tmp12_);
		for (line_it = 0; line_it < _vala_array_length (_tmp12_); line_it = line_it + 1) {
			gchar* _tmp14_ = NULL;
			gchar* line = NULL;
			_tmp14_ = g_strdup (line_collection[line_it]);
			line = _tmp14_;
			{
				const gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				gboolean _tmp17_ = FALSE;
				const gchar* _tmp18_ = NULL;
				_tmp15_ = line;
				if (g_strcmp0 (_tmp15_, "") == 0) {
					_g_free0 (line);
					continue;
				}
				_tmp18_ = line;
				if (g_strcmp0 (_tmp18_, "C") == 0) {
					_tmp17_ = TRUE;
				} else {
					const gchar* _tmp19_ = NULL;
					gboolean _tmp20_ = FALSE;
					_tmp19_ = line;
					_tmp20_ = g_str_has_prefix (_tmp19_, "C.");
					_tmp17_ = _tmp20_;
				}
				if (_tmp17_) {
					_tmp16_ = TRUE;
				} else {
					const gchar* _tmp21_ = NULL;
					_tmp21_ = line;
					_tmp16_ = g_strcmp0 (_tmp21_, "POSIX") == 0;
				}
				if (!_tmp16_) {
					const gchar* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					gchar* _tmp24_ = NULL;
					gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					_tmp22_ = _result_;
					_tmp23_ = line;
					_tmp24_ = g_strconcat ("'", _tmp23_, NULL);
					_tmp25_ = _tmp24_;
					_tmp26_ = g_strconcat (_tmp25_, "',", NULL);
					_tmp27_ = _tmp26_;
					_tmp28_ = g_strconcat (_tmp22_, _tmp27_, NULL);
					_g_free0 (_result_);
					_result_ = _tmp28_;
					_g_free0 (_tmp27_);
					_g_free0 (_tmp25_);
				}
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp29_ = _result_;
	_tmp30_ = g_strconcat (_tmp29_, "'C']", NULL);
	_g_free0 (_result_);
	_result_ = _tmp30_;
	_tmp31_ = _result_;
	_tmp32_ = JSStringCreateWithUTF8CString (_tmp31_);
	s = _tmp32_;
	_tmp33_ = ctx;
	_tmp34_ = JSEvaluateScript (_tmp33_, s, NULL, NULL, 0, NULL);
	result = _tmp34_;
	_JSStringRelease0 (s);
	_g_free0 (_result_);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (error_output);
	_g_free0 (normal_output);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void installation_setup_js_class (void* context) {
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* g = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* s = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	g_return_if_fail (context != NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = context;
	_tmp2_ = context;
	_tmp3_ = JSObjectMake (_tmp1_, c, _tmp2_);
	o = _tmp3_;
	_tmp4_ = context;
	_tmp5_ = JSContextGetGlobalObject (_tmp4_);
	g = _tmp5_;
	_tmp6_ = JSStringCreateWithUTF8CString ("Installation");
	s = _tmp6_;
	_tmp7_ = context;
	JSObjectSetProperty (_tmp7_, g, s, o, kJSPropertyAttributeNone, NULL);
	_JSStringRelease0 (s);
	_0 (g);
	_0 (o);
	_JSClassRelease0 (c);
}


Installation* installation_construct (GType object_type) {
	Installation * self = NULL;
	self = (Installation*) g_object_new (object_type, NULL);
	return self;
}


Installation* installation_new (void) {
	return installation_construct (TYPE_INSTALLATION);
}


gint installation_get_partition (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_partition;
	result = _tmp0_;
	return result;
}


void installation_set_partition (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_partition = _tmp0_;
	g_object_notify ((GObject *) self, "partition");
}


gint installation_get_device (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_device;
	result = _tmp0_;
	return result;
}


void installation_set_device (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_device = _tmp0_;
	g_object_notify ((GObject *) self, "device");
}


const gchar* installation_get_user_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user_name;
	result = _tmp0_;
	return result;
}


void installation_set_user_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_user_name);
	self->priv->_user_name = _tmp1_;
	g_object_notify ((GObject *) self, "user-name");
}


const gchar* installation_get_password (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_password;
	result = _tmp0_;
	return result;
}


void installation_set_password (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_password);
	self->priv->_password = _tmp1_;
	g_object_notify ((GObject *) self, "password");
}


const gchar* installation_get_host_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_host_name;
	result = _tmp0_;
	return result;
}


void installation_set_host_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_host_name);
	self->priv->_host_name = _tmp1_;
	g_object_notify ((GObject *) self, "host-name");
}


const gchar* installation_get_full_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_full_name;
	result = _tmp0_;
	return result;
}


void installation_set_full_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_full_name);
	self->priv->_full_name = _tmp1_;
	g_object_notify ((GObject *) self, "full-name");
}


const gchar* installation_get_grub_device (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_grub_device;
	result = _tmp0_;
	return result;
}


void installation_set_grub_device (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_grub_device);
	self->priv->_grub_device = _tmp1_;
	g_object_notify ((GObject *) self, "grub-device");
}


const gchar* installation_get_language (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_language;
	result = _tmp0_;
	return result;
}


void installation_set_language (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_language);
	self->priv->_language = _tmp1_;
	g_object_notify ((GObject *) self, "language");
}


const gchar* installation_get_region (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_region;
	result = _tmp0_;
	return result;
}


void installation_set_region (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_region);
	self->priv->_region = _tmp1_;
	g_object_notify ((GObject *) self, "region");
}


const gchar* installation_get_keyboard (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_keyboard;
	result = _tmp0_;
	return result;
}


void installation_set_keyboard (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_keyboard);
	self->priv->_keyboard = _tmp1_;
	g_object_notify ((GObject *) self, "keyboard");
}


const gchar* installation_get_home (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_home;
	result = _tmp0_;
	return result;
}


void installation_set_home (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_home);
	self->priv->_home = _tmp1_;
	g_object_notify ((GObject *) self, "home");
}


gboolean installation_get_autologin (Installation* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_autologin;
	result = _tmp0_;
	return result;
}


void installation_set_autologin (Installation* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_autologin = _tmp0_;
	g_object_notify ((GObject *) self, "autologin");
}


gboolean installation_get_advancedMode (Installation* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_advancedMode;
	result = _tmp0_;
	return result;
}


void installation_set_advancedMode (Installation* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_advancedMode = _tmp0_;
	g_object_notify ((GObject *) self, "advancedMode");
}


gint installation_get_state (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}


void installation_set_state (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_state = _tmp0_;
	g_object_notify ((GObject *) self, "state");
}


gint installation_get_progress (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_progress;
	result = _tmp0_;
	return result;
}


static void installation_set_progress (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_progress = _tmp0_;
	g_object_notify ((GObject *) self, "progress");
}


const gchar* installation_get_description (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


void installation_set_description (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


const gchar* installation_get_steps (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_steps;
	result = _tmp0_;
	return result;
}


void installation_set_steps (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_steps);
	self->priv->_steps = _tmp1_;
	g_object_notify ((GObject *) self, "steps");
}


static void installation_class_init (InstallationClass * klass) {
	installation_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_installation_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_installation_set_property;
	G_OBJECT_CLASS (klass)->finalize = installation_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PARTITION, g_param_spec_int ("partition", "partition", "partition", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DEVICE, g_param_spec_int ("device", "device", "device", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_USER_NAME, g_param_spec_string ("user-name", "user-name", "user-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PASSWORD, g_param_spec_string ("password", "password", "password", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_HOST_NAME, g_param_spec_string ("host-name", "host-name", "host-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_FULL_NAME, g_param_spec_string ("full-name", "full-name", "full-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_GRUB_DEVICE, g_param_spec_string ("grub-device", "grub-device", "grub-device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_LANGUAGE, g_param_spec_string ("language", "language", "language", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_REGION, g_param_spec_string ("region", "region", "region", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_KEYBOARD, g_param_spec_string ("keyboard", "keyboard", "keyboard", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_HOME, g_param_spec_string ("home", "home", "home", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_AUTOLOGIN, g_param_spec_boolean ("autologin", "autologin", "autologin", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_ADVANCED_MODE, g_param_spec_boolean ("advancedMode", "advancedMode", "advancedMode", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_STATE, g_param_spec_int ("state", "state", "state", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PROGRESS, g_param_spec_int ("progress", "progress", "progress", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_STEPS, g_param_spec_string ("steps", "steps", "steps", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_signal_new ("installation_started", TYPE_INSTALLATION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void installation_instance_init (Installation * self) {
	gchar* _tmp0_ = NULL;
	self->priv = INSTALLATION_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->root = _tmp0_;
	self->separatedHome = FALSE;
	self->priv->step = INSTALLATION_STEP_IDLE;
	self->priv->last_step = INSTALLATION_STEP_IDLE;
}


static void installation_finalize (GObject* obj) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLATION, Installation);
	_g_free0 (self->priv->_user_name);
	_g_free0 (self->priv->_password);
	_g_free0 (self->priv->_host_name);
	_g_free0 (self->priv->_full_name);
	_g_free0 (self->priv->_grub_device);
	_g_free0 (self->priv->_language);
	_g_free0 (self->priv->_region);
	_g_free0 (self->priv->_keyboard);
	_g_free0 (self->priv->_home);
	_g_free0 (self->priv->_description);
	_g_free0 (self->priv->_steps);
	_g_free0 (self->root);
	_g_free0 (self->priv->partition_path);
	_g_free0 (self->priv->device_path);
	_g_io_channel_unref0 (self->priv->io_err);
	_g_io_channel_unref0 (self->priv->io_out);
	G_OBJECT_CLASS (installation_parent_class)->finalize (obj);
}


GType installation_get_type (void) {
	static volatile gsize installation_type_id__volatile = 0;
	if (g_once_init_enter (&installation_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installation), 0, (GInstanceInitFunc) installation_instance_init, NULL };
		GType installation_type_id;
		installation_type_id = g_type_register_static (G_TYPE_OBJECT, "Installation", &g_define_type_info, 0);
		g_once_init_leave (&installation_type_id__volatile, installation_type_id);
	}
	return installation_type_id__volatile;
}


static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		g_value_set_int (value, installation_get_partition (self));
		break;
		case INSTALLATION_DEVICE:
		g_value_set_int (value, installation_get_device (self));
		break;
		case INSTALLATION_USER_NAME:
		g_value_set_string (value, installation_get_user_name (self));
		break;
		case INSTALLATION_PASSWORD:
		g_value_set_string (value, installation_get_password (self));
		break;
		case INSTALLATION_HOST_NAME:
		g_value_set_string (value, installation_get_host_name (self));
		break;
		case INSTALLATION_FULL_NAME:
		g_value_set_string (value, installation_get_full_name (self));
		break;
		case INSTALLATION_GRUB_DEVICE:
		g_value_set_string (value, installation_get_grub_device (self));
		break;
		case INSTALLATION_LANGUAGE:
		g_value_set_string (value, installation_get_language (self));
		break;
		case INSTALLATION_REGION:
		g_value_set_string (value, installation_get_region (self));
		break;
		case INSTALLATION_KEYBOARD:
		g_value_set_string (value, installation_get_keyboard (self));
		break;
		case INSTALLATION_HOME:
		g_value_set_string (value, installation_get_home (self));
		break;
		case INSTALLATION_AUTOLOGIN:
		g_value_set_boolean (value, installation_get_autologin (self));
		break;
		case INSTALLATION_ADVANCED_MODE:
		g_value_set_boolean (value, installation_get_advancedMode (self));
		break;
		case INSTALLATION_STATE:
		g_value_set_int (value, installation_get_state (self));
		break;
		case INSTALLATION_PROGRESS:
		g_value_set_int (value, installation_get_progress (self));
		break;
		case INSTALLATION_DESCRIPTION:
		g_value_set_string (value, installation_get_description (self));
		break;
		case INSTALLATION_STEPS:
		g_value_set_string (value, installation_get_steps (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		installation_set_partition (self, g_value_get_int (value));
		break;
		case INSTALLATION_DEVICE:
		installation_set_device (self, g_value_get_int (value));
		break;
		case INSTALLATION_USER_NAME:
		installation_set_user_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_PASSWORD:
		installation_set_password (self, g_value_get_string (value));
		break;
		case INSTALLATION_HOST_NAME:
		installation_set_host_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_FULL_NAME:
		installation_set_full_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_GRUB_DEVICE:
		installation_set_grub_device (self, g_value_get_string (value));
		break;
		case INSTALLATION_LANGUAGE:
		installation_set_language (self, g_value_get_string (value));
		break;
		case INSTALLATION_REGION:
		installation_set_region (self, g_value_get_string (value));
		break;
		case INSTALLATION_KEYBOARD:
		installation_set_keyboard (self, g_value_get_string (value));
		break;
		case INSTALLATION_HOME:
		installation_set_home (self, g_value_get_string (value));
		break;
		case INSTALLATION_AUTOLOGIN:
		installation_set_autologin (self, g_value_get_boolean (value));
		break;
		case INSTALLATION_ADVANCED_MODE:
		installation_set_advancedMode (self, g_value_get_boolean (value));
		break;
		case INSTALLATION_STATE:
		installation_set_state (self, g_value_get_int (value));
		break;
		case INSTALLATION_PROGRESS:
		installation_set_progress (self, g_value_get_int (value));
		break;
		case INSTALLATION_DESCRIPTION:
		installation_set_description (self, g_value_get_string (value));
		break;
		case INSTALLATION_STEPS:
		installation_set_steps (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally6;
	__catch6_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* installer_translate_uri (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "http://system", "file://" SYSTEM_PATH "/");
	uri = _tmp1_;
	result = uri;
	return result;
}


static gchar* installer_translate_install (Installer* self, const gchar* uri) {
	gchar* result = NULL;
	gchar* path = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = string_replace (_tmp0_, "http://install/", "");
	path = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = g_str_has_prefix (_tmp2_, "show_log?");
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		uri = "file:///var/log/blankon-installer.log";
		_tmp4_ = uri;
		_tmp5_ = g_strdup (_tmp4_);
		result = _tmp5_;
		_g_free0 (path);
		return result;
	}
	_tmp6_ = g_strdup ("about:blank");
	result = _tmp6_;
	_g_free0 (path);
	return result;
}


static gchar* installer_translate_theme (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "theme://", "");
	_tmp2_ = _tmp1_;
	_tmp3_ = utils_get_icon_path (_tmp2_, 24);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strdup_printf ("file://%s", _tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	uri = _tmp6_;
	result = uri;
	return result;
}


static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self) {
	WebKitWebView* result;
	result = installer_getInspectorView ((Installer*) self, p0);
	return result;
}


static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response) {
	WebKitWebResource* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (frame != NULL);
	g_return_if_fail (resource != NULL);
	g_return_if_fail (request != NULL);
	_tmp0_ = resource;
	_tmp1_ = webkit_web_resource_get_uri (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_str_has_prefix (_tmp2_, "theme://");
	if (_tmp3_) {
		WebKitNetworkRequest* _tmp4_ = NULL;
		WebKitWebResource* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp4_ = request;
		_tmp5_ = resource;
		_tmp6_ = webkit_web_resource_get_uri (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = installer_translate_theme (self, _tmp7_);
		_tmp9_ = _tmp8_;
		webkit_network_request_set_uri (_tmp4_, _tmp9_);
		_g_free0 (_tmp9_);
	} else {
		WebKitNetworkRequest* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp10_ = request;
		_tmp11_ = webkit_network_request_get_uri (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_str_has_prefix (_tmp12_, "http://install/");
		if (_tmp13_) {
			gchar* uri = NULL;
			WebKitWebResource* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			WebKitNetworkRequest* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			_tmp14_ = resource;
			_tmp15_ = webkit_web_resource_get_uri (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = installer_translate_install (self, _tmp16_);
			uri = _tmp17_;
			_tmp18_ = request;
			_tmp19_ = uri;
			webkit_network_request_set_uri (_tmp18_, _tmp19_);
			_g_free0 (uri);
		} else {
			gchar* uri = NULL;
			WebKitWebResource* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			const gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			WebKitNetworkRequest* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			_tmp20_ = resource;
			_tmp21_ = webkit_web_resource_get_uri (_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp23_ = installer_translate_uri (self, _tmp22_);
			uri = _tmp23_;
			_tmp24_ = request;
			_tmp25_ = uri;
			webkit_network_request_set_uri (_tmp24_, _tmp25_);
			_g_free0 (uri);
		}
	}
}


static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self) {
	__lambda5_ ((Installer*) self, p0, p1, p2, p3);
}


static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context) {
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	g_return_if_fail (frame != NULL);
	_tmp0_ = context;
	utils_setup_js_class ((void*) _tmp0_);
	_tmp1_ = context;
	parted_setup_js_class ((void*) _tmp1_);
	_tmp2_ = context;
	installation_setup_js_class ((void*) _tmp2_);
}


static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self) {
	__lambda6_ ((Installer*) self, frame, context);
}


Installer* installer_construct (GType object_type) {
	Installer * self = NULL;
	WebKitWebSettings* settings = NULL;
	WebKitWebSettings* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	WebKitWebSettings* _tmp6_ = NULL;
	WebKitWebSettings* _tmp7_ = NULL;
	WebKitWebSettings* _tmp8_ = NULL;
	self = (Installer*) g_object_new (object_type, NULL);
	_tmp0_ = webkit_web_settings_new ();
	settings = _tmp0_;
	_tmp1_ = self->priv->debug;
	if (g_strcmp0 (_tmp1_, "1") == 0) {
		WebKitWebSettings* _tmp2_ = NULL;
		WebKitWebInspector* _tmp3_ = NULL;
		WebKitWebInspector* _tmp4_ = NULL;
		WebKitWebInspector* _tmp5_ = NULL;
		_tmp2_ = settings;
		g_object_set (_tmp2_, "enable-developer-extras", TRUE, NULL);
		g_object_get ((WebKitWebView*) self, "web-inspector", &_tmp3_, NULL);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		g_signal_connect_object (_tmp5_, "inspect-web-view", (GCallback) _installer_getInspectorView_webkit_web_inspector_inspect_web_view, self, 0);
		_g_object_unref0 (_tmp5_);
	}
	_tmp6_ = settings;
	g_object_set (_tmp6_, "enable-file-access-from-file-uris", TRUE, NULL);
	_tmp7_ = settings;
	g_object_set (_tmp7_, "enable-universal-access-from-file-uris", TRUE, NULL);
	_tmp8_ = settings;
	webkit_web_view_set_settings ((WebKitWebView*) self, _tmp8_);
	g_signal_connect_object ((WebKitWebView*) self, "resource-request-starting", (GCallback) ___lambda5__webkit_web_view_resource_request_starting, self, 0);
	g_signal_connect_object ((WebKitWebView*) self, "window-object-cleared", (GCallback) ___lambda6__webkit_web_view_window_object_cleared, self, 0);
	_g_object_unref0 (settings);
	return self;
}


Installer* installer_new (void) {
	return installer_construct (TYPE_INSTALLER);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Installer* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->webview);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda4_ (Block1Data* _data1_) {
	Installer* self;
	gboolean result = FALSE;
	WebKitWebInspector* _tmp0_ = NULL;
	WebKitWebInspector* _tmp1_ = NULL;
	WebKitWebInspector* _tmp2_ = NULL;
	self = _data1_->self;
	g_object_get (_data1_->webview, "web-inspector", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	webkit_web_inspector_close (_tmp2_);
	_g_object_unref0 (_tmp2_);
	result = FALSE;
	return result;
}


static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
	gboolean result;
	result = __lambda4_ (self);
	return result;
}


static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView) {
	WebKitWebView* result = NULL;
	Block1Data* _data1_;
	GtkWindow* window = NULL;
	GtkWindow* _tmp0_ = NULL;
	WebKitWebView* _tmp1_ = NULL;
	GtkScrolledWindow* scrolled_window = NULL;
	GtkScrolledWindow* _tmp2_ = NULL;
	WebKitWebView* handle = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inspectedView != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp0_);
	window = _tmp0_;
	_tmp1_ = (WebKitWebView*) webkit_web_view_new ();
	g_object_ref_sink (_tmp1_);
	_data1_->webview = _tmp1_;
	_tmp2_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp2_);
	scrolled_window = _tmp2_;
	gtk_scrolled_window_set_policy (scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) _data1_->webview);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) scrolled_window);
	gtk_window_set_title (window, "Inspector");
	gtk_window_set_default_size (window, 640, 480);
	gtk_widget_show_all ((GtkWidget*) window);
	g_signal_connect_data ((GtkWidget*) window, "delete-event", (GCallback) ___lambda4__gtk_widget_delete_event, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	handle = _data1_->webview;
	result = handle;
	_g_object_unref0 (scrolled_window);
	_g_object_unref0 (window);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


void installer_start (Installer* self) {
	g_return_if_fail (self != NULL);
	webkit_web_view_load_uri ((WebKitWebView*) self, "http://system/index.html");
}


static void installer_class_init (InstallerClass * klass) {
	installer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallerPrivate));
	G_OBJECT_CLASS (klass)->finalize = installer_finalize;
}


static void installer_instance_init (Installer * self) {
	const gchar* _tmp0_ = NULL;
	self->priv = INSTALLER_GET_PRIVATE (self);
	_tmp0_ = g_getenv ("DEBUG");
	self->priv->debug = _tmp0_;
}


static void installer_finalize (GObject* obj) {
	Installer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLER, Installer);
	G_OBJECT_CLASS (installer_parent_class)->finalize (obj);
}


GType installer_get_type (void) {
	static volatile gsize installer_type_id__volatile = 0;
	if (g_once_init_enter (&installer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installer), 0, (GInstanceInitFunc) installer_instance_init, NULL };
		GType installer_type_id;
		installer_type_id = g_type_register_static (WEBKIT_TYPE_WEB_VIEW, "Installer", &g_define_type_info, 0);
		g_once_init_leave (&installer_type_id__volatile, installer_type_id);
	}
	return installer_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



