/* parted.c generated by valac 0.26.1, the Vala compiler
 * generated from parted.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <parted/parted.h>
#include <stdio.h>
#include <JavaScriptCore/JavaScript.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SWAP_COLLECTOR (swap_collector_get_type ())
#define SWAP_COLLECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SWAP_COLLECTOR, SwapCollector))
#define SWAP_COLLECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SWAP_COLLECTOR, SwapCollectorClass))
#define IS_SWAP_COLLECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SWAP_COLLECTOR))
#define IS_SWAP_COLLECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SWAP_COLLECTOR))
#define SWAP_COLLECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SWAP_COLLECTOR, SwapCollectorClass))

typedef struct _SwapCollector SwapCollector;
typedef struct _SwapCollectorClass SwapCollectorClass;
typedef struct _SwapCollectorPrivate SwapCollectorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecSwapCollector ParamSpecSwapCollector;

#define TYPE_OS_PROBER (os_prober_get_type ())
#define OS_PROBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OS_PROBER, OsProber))
#define OS_PROBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OS_PROBER, OsProberClass))
#define IS_OS_PROBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OS_PROBER))
#define IS_OS_PROBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OS_PROBER))
#define OS_PROBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OS_PROBER, OsProberClass))

typedef struct _OsProber OsProber;
typedef struct _OsProberClass OsProberClass;
typedef struct _OsProberPrivate OsProberPrivate;
typedef struct _ParamSpecOsProber ParamSpecOsProber;

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;
typedef struct _DevicePrivate DevicePrivate;

#define DEVICE_TYPE_PARTITION (device_partition_get_type ())
#define DEVICE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEVICE_TYPE_PARTITION, DevicePartition))
#define DEVICE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEVICE_TYPE_PARTITION, DevicePartitionClass))
#define DEVICE_IS_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEVICE_TYPE_PARTITION))
#define DEVICE_IS_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEVICE_TYPE_PARTITION))
#define DEVICE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEVICE_TYPE_PARTITION, DevicePartitionClass))

typedef struct _DevicePartition DevicePartition;
typedef struct _DevicePartitionClass DevicePartitionClass;

#define DEVICE_TYPE_PARTITION_TYPE (device_partition_type_get_type ())
#define _ped_disk_destroy0(var) ((var == NULL) ? NULL : (var = (ped_disk_destroy (var), NULL)))
typedef struct _DevicePartitionPrivate DevicePartitionPrivate;
#define _ped_constraint_destroy0(var) ((var == NULL) ? NULL : (var = (ped_constraint_destroy (var), NULL)))

#define TYPE_PARTED (parted_get_type ())
#define PARTED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARTED, Parted))
#define PARTED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARTED, PartedClass))
#define IS_PARTED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARTED))
#define IS_PARTED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARTED))
#define PARTED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARTED, PartedClass))

typedef struct _Parted Parted;
typedef struct _PartedClass PartedClass;
typedef struct _PartedPrivate PartedPrivate;
#define _JSStringRelease0(var) ((var == NULL) ? NULL : (var = (JSStringRelease (var), NULL)))
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _JSClassRelease0(var) ((var == NULL) ? NULL : (var = (JSClassRelease (var), NULL)))
typedef struct _ParamSpecParted ParamSpecParted;

struct _SwapCollector {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SwapCollectorPrivate * priv;
};

struct _SwapCollectorClass {
	GTypeClass parent_class;
	void (*finalize) (SwapCollector *self);
};

struct _ParamSpecSwapCollector {
	GParamSpec parent_instance;
};

struct _OsProber {
	GTypeInstance parent_instance;
	volatile int ref_count;
	OsProberPrivate * priv;
};

struct _OsProberClass {
	GTypeClass parent_class;
	void (*finalize) (OsProber *self);
};

struct _ParamSpecOsProber {
	GParamSpec parent_instance;
};

typedef enum  {
	DEVICE_ERROR_CANT_CREATE_PARTITION
} DeviceError;
#define DEVICE_ERROR device_error_quark ()
struct _Device {
	GObject parent_instance;
	DevicePrivate * priv;
};

struct _DeviceClass {
	GObjectClass parent_class;
};

struct _DevicePrivate {
	guint64 unit_size;
	PedDevice* device;
	PedDisk* disk;
	gboolean valid;
	GeeArrayList* _partitions;
};

typedef enum  {
	DEVICE_PARTITION_TYPE_NORMAL,
	DEVICE_PARTITION_TYPE_LOGICAL,
	DEVICE_PARTITION_TYPE_EXTENDED,
	DEVICE_PARTITION_TYPE_FREESPACE,
	DEVICE_PARTITION_TYPE_METADATA,
	DEVICE_PARTITION_TYPE_PROTECTED,
	DEVICE_PARTITION_TYPE_INVALID
} DevicePartitionType;

struct _DevicePartition {
	GObject parent_instance;
	DevicePartitionPrivate * priv;
	PedPartition* internal;
};

struct _DevicePartitionClass {
	GObjectClass parent_class;
};

struct _DevicePartitionPrivate {
	gint _number;
	guint64 _start;
	guint64 _end;
	guint64 _size;
	gchar* _filesystem;
	gchar* _flag;
	gint _parent;
	gchar* _description;
	DevicePartitionType _ptype;
};

struct _Parted {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PartedPrivate * priv;
};

struct _PartedClass {
	GTypeClass parent_class;
	void (*finalize) (Parted *self);
};

struct _ParamSpecParted {
	GParamSpec parent_instance;
};


static gpointer swap_collector_parent_class = NULL;
static GeeArrayList* swap_collector_swaps;
static GeeArrayList* swap_collector_swaps = NULL;
static gpointer os_prober_parent_class = NULL;
static GeeHashMap* os_prober_probes;
static GeeHashMap* os_prober_probes = NULL;
static gpointer device_parent_class = NULL;
static gboolean device_need_free;
static gboolean device_need_free = FALSE;
static gpointer device_partition_parent_class = NULL;
static gpointer parted_parent_class = NULL;
static GeeArrayList* parted_device_list;
static GeeArrayList* parted_device_list = NULL;

gpointer swap_collector_ref (gpointer instance);
void swap_collector_unref (gpointer instance);
GParamSpec* param_spec_swap_collector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_swap_collector (GValue* value, gpointer v_object);
void value_take_swap_collector (GValue* value, gpointer v_object);
gpointer value_get_swap_collector (const GValue* value);
GType swap_collector_get_type (void) G_GNUC_CONST;
enum  {
	SWAP_COLLECTOR_DUMMY_PROPERTY
};
static void swap_collector_reget (void);
gboolean swap_collector_is_swap (const gchar* partition);
GeeArrayList* swap_collector_get_partitions (void);
void swap_collector_reset (void);
SwapCollector* swap_collector_new (void);
SwapCollector* swap_collector_construct (GType object_type);
static void swap_collector_finalize (SwapCollector* obj);
gpointer os_prober_ref (gpointer instance);
void os_prober_unref (gpointer instance);
GParamSpec* param_spec_os_prober (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_os_prober (GValue* value, gpointer v_object);
void value_take_os_prober (GValue* value, gpointer v_object);
gpointer value_get_os_prober (const GValue* value);
GType os_prober_get_type (void) G_GNUC_CONST;
enum  {
	OS_PROBER_DUMMY_PROPERTY
};
static void os_prober_reget (void);
gchar* os_prober_get_description (const gchar* partition);
OsProber* os_prober_new (void);
OsProber* os_prober_construct (GType object_type);
static void os_prober_finalize (OsProber* obj);
GQuark device_error_quark (void);
GType device_get_type (void) G_GNUC_CONST;
GType device_partition_get_type (void) G_GNUC_CONST;
#define DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DEVICE, DevicePrivate))
enum  {
	DEVICE_DUMMY_PROPERTY,
	DEVICE_PARTITIONS
};
GType device_partition_type_get_type (void) G_GNUC_CONST;
gboolean device_is_valid (Device* self);
Device* device_new (void);
Device* device_construct (GType object_type);
Device* device_new_from_list (Device* start);
Device* device_construct_from_list (GType object_type, Device* start);
static void device_init (Device* self);
Device* device_new_from_name (const gchar* s);
Device* device_construct_from_name (GType object_type, const gchar* s);
void device_set_partitions (Device* self, GeeArrayList* value);
DevicePartition* device_partition_new (void);
DevicePartition* device_partition_construct (GType object_type);
void device_partition_set_number (DevicePartition* self, gint value);
void device_partition_set_start (DevicePartition* self, guint64 value);
void device_partition_set_end (DevicePartition* self, guint64 value);
void device_partition_set_size (DevicePartition* self, guint64 value);
void device_partition_set_filesystem (DevicePartition* self, const gchar* value);
void device_partition_set_flag (DevicePartition* self, const gchar* value);
void device_partition_set_description (DevicePartition* self, const gchar* value);
void device_partition_set_ptype (DevicePartition* self, DevicePartitionType value);
GeeArrayList* device_get_partitions (Device* self);
guint64 device_get_size (Device* self);
DevicePartition* device_partition_new_blank_with_size (guint64 size);
DevicePartition* device_partition_construct_blank_with_size (GType object_type, guint64 size);
gchar* device_get_path (Device* self);
gchar* device_get_model (Device* self);
gchar* device_get_label (Device* self);
gint device_get_num_partitions (Device* self);
guint64 device_get_unit_size (Device* self);
void device_commit_changes (Device* self);
gint device_delete_partition (Device* self, gint index, GError** error);
gint device_create_partition (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, const gchar* type, const gchar* mount, GError** error);
static void _vala_array_add1 (gint** array, int* length, int* size, gint value);
static void _vala_array_add2 (gint** array, int* length, int* size, gint value);
gint device_create_partition_simple (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, guint64 swap_size, GError** error);
DevicePartitionType device_partition_get_ptype (DevicePartition* self);
guint64 device_partition_get_start (DevicePartition* self);
guint64 device_partition_get_end (DevicePartition* self);
#define DEVICE_PARTITION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), DEVICE_TYPE_PARTITION, DevicePartitionPrivate))
enum  {
	DEVICE_PARTITION_DUMMY_PROPERTY,
	DEVICE_PARTITION_NUMBER,
	DEVICE_PARTITION_START,
	DEVICE_PARTITION_END,
	DEVICE_PARTITION_SIZE,
	DEVICE_PARTITION_FILESYSTEM,
	DEVICE_PARTITION_FLAG,
	DEVICE_PARTITION_PARENT,
	DEVICE_PARTITION_DESCRIPTION,
	DEVICE_PARTITION_PTYPE
};
void device_partition_set_parent (DevicePartition* self, gint value);
gint device_partition_get_number (DevicePartition* self);
guint64 device_partition_get_size (DevicePartition* self);
const gchar* device_partition_get_filesystem (DevicePartition* self);
const gchar* device_partition_get_flag (DevicePartition* self);
gint device_partition_get_parent (DevicePartition* self);
const gchar* device_partition_get_description (DevicePartition* self);
static void device_partition_finalize (GObject* obj);
static void _vala_device_partition_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_device_partition_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void device_finalize (GObject* obj);
static void _vala_device_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_device_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gpointer parted_ref (gpointer instance);
void parted_unref (gpointer instance);
GParamSpec* param_spec_parted (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_parted (GValue* value, gpointer v_object);
void value_take_parted (GValue* value, gpointer v_object);
gpointer value_get_parted (const GValue* value);
GType parted_get_type (void) G_GNUC_CONST;
enum  {
	PARTED_DUMMY_PROPERTY
};
void* parted_js_get_devices (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _parted_js_get_devices_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
GeeArrayList* parted_get_devices (gboolean from_cache);
gchar* parted_get_devices_json (void);
const gchar* device_partition_type_to_string (DevicePartitionType self);
gchar* parted_process_request (const gchar* uri);
Parted* parted_new (void);
Parted* parted_construct (GType object_type);
void parted_setup_js_class (void* context);
static void parted_finalize (Parted* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const JSStaticFunction PARTED_js_funcs[2] = {{"getDevices", _parted_js_get_devices_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {NULL, NULL, 0}};
static const JSClassDefinition PARTED_js_class = {0, kJSClassAttributeNone, "Parted", NULL, NULL, PARTED_js_funcs, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void swap_collector_reget (void) {
	GeeArrayList* _tmp0_ = NULL;
	gchar* normal_output = NULL;
	gchar* error_output = NULL;
	gint status = 0;
	gchar** args = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	gchar** env = NULL;
	gchar* _tmp4_ = NULL;
	gchar** _tmp5_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar** _tmp9_ = NULL;
	gchar** _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	_g_object_unref0 (swap_collector_swaps);
	swap_collector_swaps = _tmp0_;
	_tmp1_ = g_strdup ("/sbin/fdisk");
	_tmp2_ = g_strdup ("-l");
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp1_;
	_tmp3_[1] = _tmp2_;
	args = _tmp3_;
	args_length1 = 2;
	_args_size_ = args_length1;
	_tmp4_ = g_strdup ("LC_ALL=C");
	_tmp5_ = g_new0 (gchar*, 1 + 1);
	_tmp5_[0] = _tmp4_;
	env = _tmp5_;
	env_length1 = 1;
	_env_size_ = env_length1;
	{
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		g_spawn_sync ("/tmp", args, env, G_SPAWN_LEAVE_DESCRIPTORS_OPEN, NULL, NULL, &_tmp6_, &_tmp7_, &_tmp8_, &_inner_error_);
		_g_free0 (normal_output);
		normal_output = _tmp6_;
		_g_free0 (error_output);
		error_output = _tmp7_;
		status = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch7_g_error;
		}
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (error_output);
		_g_free0 (normal_output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp10_ = _tmp9_ = g_strsplit (normal_output, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp10_;
		line_collection_length1 = _vala_array_length (_tmp9_);
		for (line_it = 0; line_it < _vala_array_length (_tmp9_); line_it = line_it + 1) {
			gchar* _tmp11_ = NULL;
			gchar* line = NULL;
			_tmp11_ = g_strdup (line_collection[line_it]);
			line = _tmp11_;
			{
				gboolean _tmp12_ = FALSE;
				const gchar* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				_tmp13_ = line;
				_tmp14_ = string_index_of (_tmp13_, "/dev/", 0);
				if (_tmp14_ == 0) {
					const gchar* _tmp15_ = NULL;
					gint _tmp16_ = 0;
					_tmp15_ = line;
					_tmp16_ = string_index_of (_tmp15_, "Linux swap", 0);
					_tmp12_ = _tmp16_ > 0;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					GeeArrayList* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					gchar** _tmp19_ = NULL;
					gchar** _tmp20_ = NULL;
					gchar** _tmp21_ = NULL;
					gint _tmp21__length1 = 0;
					const gchar* _tmp22_ = NULL;
					_tmp17_ = swap_collector_swaps;
					_tmp18_ = line;
					_tmp20_ = _tmp19_ = g_strsplit (_tmp18_, " ", 2);
					_tmp21_ = _tmp20_;
					_tmp21__length1 = _vala_array_length (_tmp19_);
					_tmp22_ = _tmp21_[0];
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp22_);
					_tmp21_ = (_vala_array_free (_tmp21_, _tmp21__length1, (GDestroyNotify) g_free), NULL);
				}
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (error_output);
	_g_free0 (normal_output);
}


gboolean swap_collector_is_swap (const gchar* partition) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (partition != NULL, FALSE);
	_tmp0_ = swap_collector_swaps;
	if (_tmp0_ == NULL) {
		swap_collector_reget ();
	}
	_tmp1_ = swap_collector_swaps;
	_tmp2_ = partition;
	_tmp3_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp1_, _tmp2_);
	result = _tmp3_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GeeArrayList* swap_collector_get_partitions (void) {
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	_tmp0_ = swap_collector_swaps;
	if (_tmp0_ == NULL) {
		swap_collector_reget ();
	}
	_tmp1_ = swap_collector_swaps;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	result = _tmp2_;
	return result;
}


void swap_collector_reset (void) {
	swap_collector_reget ();
}


SwapCollector* swap_collector_construct (GType object_type) {
	SwapCollector* self = NULL;
	self = (SwapCollector*) g_type_create_instance (object_type);
	return self;
}


SwapCollector* swap_collector_new (void) {
	return swap_collector_construct (TYPE_SWAP_COLLECTOR);
}


static void value_swap_collector_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_swap_collector_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		swap_collector_unref (value->data[0].v_pointer);
	}
}


static void value_swap_collector_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = swap_collector_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_swap_collector_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_swap_collector_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SwapCollector* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = swap_collector_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_swap_collector_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SwapCollector** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = swap_collector_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_swap_collector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSwapCollector* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SWAP_COLLECTOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_swap_collector (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SWAP_COLLECTOR), NULL);
	return value->data[0].v_pointer;
}


void value_set_swap_collector (GValue* value, gpointer v_object) {
	SwapCollector* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SWAP_COLLECTOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SWAP_COLLECTOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		swap_collector_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		swap_collector_unref (old);
	}
}


void value_take_swap_collector (GValue* value, gpointer v_object) {
	SwapCollector* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SWAP_COLLECTOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SWAP_COLLECTOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		swap_collector_unref (old);
	}
}


static void swap_collector_class_init (SwapCollectorClass * klass) {
	swap_collector_parent_class = g_type_class_peek_parent (klass);
	((SwapCollectorClass *) klass)->finalize = swap_collector_finalize;
}


static void swap_collector_instance_init (SwapCollector * self) {
	self->ref_count = 1;
}


static void swap_collector_finalize (SwapCollector* obj) {
	SwapCollector * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SWAP_COLLECTOR, SwapCollector);
	g_signal_handlers_destroy (self);
}


GType swap_collector_get_type (void) {
	static volatile gsize swap_collector_type_id__volatile = 0;
	if (g_once_init_enter (&swap_collector_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_swap_collector_init, value_swap_collector_free_value, value_swap_collector_copy_value, value_swap_collector_peek_pointer, "p", value_swap_collector_collect_value, "p", value_swap_collector_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SwapCollectorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) swap_collector_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SwapCollector), 0, (GInstanceInitFunc) swap_collector_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType swap_collector_type_id;
		swap_collector_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SwapCollector", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&swap_collector_type_id__volatile, swap_collector_type_id);
	}
	return swap_collector_type_id__volatile;
}


gpointer swap_collector_ref (gpointer instance) {
	SwapCollector* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void swap_collector_unref (gpointer instance) {
	SwapCollector* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SWAP_COLLECTOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void os_prober_reget (void) {
	GeeHashMap* _tmp0_ = NULL;
	gchar* normal_output = NULL;
	gchar* error_output = NULL;
	gint status = 0;
	gchar** args = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	gchar** env = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar** _tmp8_ = NULL;
	gchar** _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (os_prober_probes);
	os_prober_probes = _tmp0_;
	_tmp1_ = g_strdup ("/usr/bin/os-prober");
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	args = _tmp2_;
	args_length1 = 1;
	_args_size_ = args_length1;
	_tmp3_ = g_strdup ("LC_ALL=C");
	_tmp4_ = g_new0 (gchar*, 1 + 1);
	_tmp4_[0] = _tmp3_;
	env = _tmp4_;
	env_length1 = 1;
	_env_size_ = env_length1;
	{
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		g_spawn_sync ("/tmp", args, env, G_SPAWN_LEAVE_DESCRIPTORS_OPEN, NULL, NULL, &_tmp5_, &_tmp6_, &_tmp7_, &_inner_error_);
		_g_free0 (normal_output);
		normal_output = _tmp5_;
		_g_free0 (error_output);
		error_output = _tmp6_;
		status = _tmp7_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (error_output);
		_g_free0 (normal_output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp9_ = _tmp8_ = g_strsplit (normal_output, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp9_;
		line_collection_length1 = _vala_array_length (_tmp8_);
		for (line_it = 0; line_it < _vala_array_length (_tmp8_); line_it = line_it + 1) {
			gchar* _tmp10_ = NULL;
			gchar* line = NULL;
			_tmp10_ = g_strdup (line_collection[line_it]);
			line = _tmp10_;
			{
				gchar** fields = NULL;
				const gchar* _tmp11_ = NULL;
				gchar** _tmp12_ = NULL;
				gchar** _tmp13_ = NULL;
				gint fields_length1 = 0;
				gint _fields_size_ = 0;
				gchar** _tmp14_ = NULL;
				gint _tmp14__length1 = 0;
				_tmp11_ = line;
				_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, ":", 0);
				fields = _tmp13_;
				fields_length1 = _vala_array_length (_tmp12_);
				_fields_size_ = fields_length1;
				_tmp14_ = fields;
				_tmp14__length1 = fields_length1;
				if (_tmp14__length1 > 1) {
					GeeHashMap* _tmp15_ = NULL;
					gchar** _tmp16_ = NULL;
					gint _tmp16__length1 = 0;
					const gchar* _tmp17_ = NULL;
					gchar** _tmp18_ = NULL;
					gint _tmp18__length1 = 0;
					const gchar* _tmp19_ = NULL;
					_tmp15_ = os_prober_probes;
					_tmp16_ = fields;
					_tmp16__length1 = fields_length1;
					_tmp17_ = _tmp16_[0];
					_tmp18_ = fields;
					_tmp18__length1 = fields_length1;
					_tmp19_ = _tmp18_[1];
					gee_abstract_map_set ((GeeAbstractMap*) _tmp15_, _tmp17_, _tmp19_);
				}
				fields = (_vala_array_free (fields, fields_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (error_output);
	_g_free0 (normal_output);
}


gchar* os_prober_get_description (const gchar* partition) {
	gchar* result = NULL;
	GeeHashMap* _tmp0_ = NULL;
	gchar* s = NULL;
	GeeHashMap* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gpointer _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp8_ = NULL;
	g_return_val_if_fail (partition != NULL, NULL);
	_tmp0_ = os_prober_probes;
	if (_tmp0_ == NULL) {
		os_prober_reget ();
	}
	_tmp1_ = os_prober_probes;
	_tmp2_ = partition;
	_tmp3_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp1_, _tmp2_);
	s = (gchar*) _tmp3_;
	_tmp4_ = s;
	if (_tmp4_ == NULL) {
		GeeHashMap* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gpointer _tmp7_ = NULL;
		os_prober_reget ();
		_tmp5_ = os_prober_probes;
		_tmp6_ = partition;
		_tmp7_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, _tmp6_);
		_g_free0 (s);
		s = (gchar*) _tmp7_;
	}
	_tmp8_ = s;
	if (_tmp8_ == NULL) {
		gchar* _tmp9_ = NULL;
		_tmp9_ = g_strdup ("");
		_g_free0 (s);
		s = _tmp9_;
	}
	result = s;
	return result;
}


OsProber* os_prober_construct (GType object_type) {
	OsProber* self = NULL;
	self = (OsProber*) g_type_create_instance (object_type);
	return self;
}


OsProber* os_prober_new (void) {
	return os_prober_construct (TYPE_OS_PROBER);
}


static void value_os_prober_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_os_prober_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		os_prober_unref (value->data[0].v_pointer);
	}
}


static void value_os_prober_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = os_prober_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_os_prober_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_os_prober_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		OsProber* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = os_prober_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_os_prober_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	OsProber** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = os_prober_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_os_prober (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecOsProber* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_OS_PROBER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_os_prober (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_OS_PROBER), NULL);
	return value->data[0].v_pointer;
}


void value_set_os_prober (GValue* value, gpointer v_object) {
	OsProber* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_OS_PROBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_OS_PROBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		os_prober_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		os_prober_unref (old);
	}
}


void value_take_os_prober (GValue* value, gpointer v_object) {
	OsProber* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_OS_PROBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_OS_PROBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		os_prober_unref (old);
	}
}


static void os_prober_class_init (OsProberClass * klass) {
	os_prober_parent_class = g_type_class_peek_parent (klass);
	((OsProberClass *) klass)->finalize = os_prober_finalize;
}


static void os_prober_instance_init (OsProber * self) {
	self->ref_count = 1;
}


static void os_prober_finalize (OsProber* obj) {
	OsProber * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_OS_PROBER, OsProber);
	g_signal_handlers_destroy (self);
}


GType os_prober_get_type (void) {
	static volatile gsize os_prober_type_id__volatile = 0;
	if (g_once_init_enter (&os_prober_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_os_prober_init, value_os_prober_free_value, value_os_prober_copy_value, value_os_prober_peek_pointer, "p", value_os_prober_collect_value, "p", value_os_prober_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (OsProberClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) os_prober_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OsProber), 0, (GInstanceInitFunc) os_prober_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType os_prober_type_id;
		os_prober_type_id = g_type_register_fundamental (g_type_fundamental_next (), "OsProber", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&os_prober_type_id__volatile, os_prober_type_id);
	}
	return os_prober_type_id__volatile;
}


gpointer os_prober_ref (gpointer instance) {
	OsProber* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void os_prober_unref (gpointer instance) {
	OsProber* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		OS_PROBER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GQuark device_error_quark (void) {
	return g_quark_from_static_string ("device_error-quark");
}


GType device_partition_type_get_type (void) {
	static volatile gsize device_partition_type_type_id__volatile = 0;
	if (g_once_init_enter (&device_partition_type_type_id__volatile)) {
		static const GEnumValue values[] = {{DEVICE_PARTITION_TYPE_NORMAL, "DEVICE_PARTITION_TYPE_NORMAL", "normal"}, {DEVICE_PARTITION_TYPE_LOGICAL, "DEVICE_PARTITION_TYPE_LOGICAL", "logical"}, {DEVICE_PARTITION_TYPE_EXTENDED, "DEVICE_PARTITION_TYPE_EXTENDED", "extended"}, {DEVICE_PARTITION_TYPE_FREESPACE, "DEVICE_PARTITION_TYPE_FREESPACE", "freespace"}, {DEVICE_PARTITION_TYPE_METADATA, "DEVICE_PARTITION_TYPE_METADATA", "metadata"}, {DEVICE_PARTITION_TYPE_PROTECTED, "DEVICE_PARTITION_TYPE_PROTECTED", "protected"}, {DEVICE_PARTITION_TYPE_INVALID, "DEVICE_PARTITION_TYPE_INVALID", "invalid"}, {0, NULL, NULL}};
		GType device_partition_type_type_id;
		device_partition_type_type_id = g_enum_register_static ("DevicePartitionType", values);
		g_once_init_leave (&device_partition_type_type_id__volatile, device_partition_type_type_id);
	}
	return device_partition_type_type_id__volatile;
}


gboolean device_is_valid (Device* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->valid;
	result = _tmp0_;
	return result;
}


Device* device_construct (GType object_type) {
	Device * self = NULL;
	self = (Device*) g_object_new (object_type, NULL);
	return self;
}


Device* device_new (void) {
	return device_construct (TYPE_DEVICE);
}


Device* device_construct_from_list (GType object_type, Device* start) {
	Device * self = NULL;
	gboolean _tmp0_ = FALSE;
	PedDevice* d = NULL;
	Device* _tmp1_ = NULL;
	PedDevice* _tmp4_ = NULL;
	PedDevice* _tmp5_ = NULL;
	self = (Device*) g_object_new (object_type, NULL);
	_tmp0_ = device_need_free;
	if (_tmp0_ == FALSE) {
		ped_device_probe_all ();
		device_need_free = TRUE;
	}
	d = NULL;
	_tmp1_ = start;
	if (_tmp1_ != NULL) {
		Device* _tmp2_ = NULL;
		PedDevice* _tmp3_ = NULL;
		_tmp2_ = start;
		_tmp3_ = _tmp2_->priv->device;
		d = _tmp3_;
	}
	_tmp4_ = d;
	_tmp5_ = ped_device_get_next (_tmp4_);
	self->priv->device = _tmp5_;
	device_init (self);
	return self;
}


Device* device_new_from_list (Device* start) {
	return device_construct_from_list (TYPE_DEVICE, start);
}


Device* device_construct_from_name (GType object_type, const gchar* s) {
	Device * self = NULL;
	const gchar* _tmp0_ = NULL;
	PedDevice* _tmp1_ = NULL;
	g_return_val_if_fail (s != NULL, NULL);
	self = (Device*) g_object_new (object_type, NULL);
	_tmp0_ = s;
	_tmp1_ = ped_device_get (_tmp0_);
	self->priv->device = _tmp1_;
	device_init (self);
	return self;
}


Device* device_new_from_name (const gchar* s) {
	return device_construct_from_name (TYPE_DEVICE, s);
}


static void device_init (Device* self) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	PedDevice* _tmp2_ = NULL;
	PedDevice* _tmp3_ = NULL;
	guint64 _tmp4_ = 0ULL;
	PedDevice* _tmp5_ = NULL;
	PedDisk* _tmp6_ = NULL;
	PedDisk* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (DEVICE_TYPE_PARTITION, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_tmp1_ = _tmp0_;
	device_set_partitions (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = self->priv->device;
	if (_tmp2_ != NULL) {
		self->priv->valid = TRUE;
	} else {
		return;
	}
	_tmp3_ = self->priv->device;
	_tmp4_ = ped_unit_get_size (_tmp3_, PED_UNIT_SECTOR);
	self->priv->unit_size = _tmp4_;
	_tmp5_ = self->priv->device;
	_tmp6_ = ped_disk_new (_tmp5_);
	_ped_disk_destroy0 (self->priv->disk);
	self->priv->disk = _tmp6_;
	_tmp7_ = self->priv->disk;
	if (_tmp7_ != NULL) {
		PedPartition* p = NULL;
		PedDisk* _tmp8_ = NULL;
		PedPartition* _tmp9_ = NULL;
		GeeArrayList* _tmp60_ = NULL;
		gboolean _tmp61_ = FALSE;
		gboolean _tmp62_ = FALSE;
		_tmp8_ = self->priv->disk;
		_tmp9_ = _tmp8_->part_list;
		p = _tmp9_;
		while (TRUE) {
			PedDisk* _tmp10_ = NULL;
			PedPartition* _tmp11_ = NULL;
			PedPartition* _tmp12_ = NULL;
			PedPartition* _tmp13_ = NULL;
			gchar* fs = NULL;
			gchar* _tmp14_ = NULL;
			PedPartition* _tmp15_ = NULL;
			PedFileSystemType* _tmp16_ = NULL;
			gchar* flag = NULL;
			gchar* _tmp21_ = NULL;
			gchar* description = NULL;
			gchar* _tmp22_ = NULL;
			PedPartition* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			DevicePartitionType type = 0;
			PedPartition* _tmp25_ = NULL;
			PedPartitionType _tmp26_ = 0;
			DevicePartition* new_p = NULL;
			DevicePartition* _tmp29_ = NULL;
			DevicePartition* _tmp30_ = NULL;
			PedPartition* _tmp31_ = NULL;
			gint _tmp32_ = 0;
			DevicePartition* _tmp33_ = NULL;
			PedPartition* _tmp34_ = NULL;
			PedGeometry _tmp35_ = {0};
			guint64 _tmp36_ = 0ULL;
			guint64 _tmp37_ = 0ULL;
			DevicePartition* _tmp38_ = NULL;
			PedPartition* _tmp39_ = NULL;
			PedGeometry _tmp40_ = {0};
			guint64 _tmp41_ = 0ULL;
			guint64 _tmp42_ = 0ULL;
			DevicePartition* _tmp43_ = NULL;
			PedPartition* _tmp44_ = NULL;
			PedGeometry _tmp45_ = {0};
			guint64 _tmp46_ = 0ULL;
			guint64 _tmp47_ = 0ULL;
			DevicePartition* _tmp48_ = NULL;
			const gchar* _tmp49_ = NULL;
			DevicePartition* _tmp50_ = NULL;
			const gchar* _tmp51_ = NULL;
			DevicePartition* _tmp52_ = NULL;
			const gchar* _tmp53_ = NULL;
			DevicePartition* _tmp54_ = NULL;
			DevicePartitionType _tmp55_ = 0;
			DevicePartition* _tmp56_ = NULL;
			PedPartition* _tmp57_ = NULL;
			GeeArrayList* _tmp58_ = NULL;
			DevicePartition* _tmp59_ = NULL;
			_tmp10_ = self->priv->disk;
			_tmp11_ = p;
			_tmp12_ = ped_disk_next_partition (_tmp10_, _tmp11_);
			p = _tmp12_;
			_tmp13_ = p;
			if (!(_tmp13_ != NULL)) {
				break;
			}
			_tmp14_ = g_strdup ("");
			fs = _tmp14_;
			_tmp15_ = p;
			_tmp16_ = _tmp15_->fs_type;
			if (_tmp16_ != NULL) {
				PedPartition* _tmp17_ = NULL;
				PedFileSystemType* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				_tmp17_ = p;
				_tmp18_ = _tmp17_->fs_type;
				_tmp19_ = _tmp18_->name;
				_tmp20_ = g_strdup (_tmp19_);
				_g_free0 (fs);
				fs = _tmp20_;
			}
			_tmp21_ = g_strdup ("");
			flag = _tmp21_;
			_tmp22_ = g_strdup ("");
			description = _tmp22_;
			_tmp23_ = p;
			_tmp24_ = _tmp23_->num;
			if (_tmp24_ > 0) {
			}
			type = DEVICE_PARTITION_TYPE_NORMAL;
			_tmp25_ = p;
			_tmp26_ = _tmp25_->type;
			switch (_tmp26_) {
				case PED_PARTITION_NORMAL:
				{
					type = DEVICE_PARTITION_TYPE_NORMAL;
					break;
				}
				case PED_PARTITION_LOGICAL:
				{
					type = DEVICE_PARTITION_TYPE_LOGICAL;
					break;
				}
				case PED_PARTITION_EXTENDED:
				{
					type = DEVICE_PARTITION_TYPE_EXTENDED;
					break;
				}
				case PED_PARTITION_FREESPACE:
				{
					type = DEVICE_PARTITION_TYPE_FREESPACE;
					break;
				}
				case PED_PARTITION_METADATA:
				{
					type = DEVICE_PARTITION_TYPE_METADATA;
					break;
				}
				case PED_PARTITION_PROTECTED:
				{
					type = DEVICE_PARTITION_TYPE_PROTECTED;
					break;
				}
				default:
				{
					PedPartition* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					_tmp27_ = p;
					_tmp28_ = _tmp27_->num;
					if (_tmp28_ == (-1)) {
						type = DEVICE_PARTITION_TYPE_FREESPACE;
					} else {
						type = DEVICE_PARTITION_TYPE_NORMAL;
					}
					break;
				}
			}
			_tmp29_ = device_partition_new ();
			new_p = _tmp29_;
			_tmp30_ = new_p;
			_tmp31_ = p;
			_tmp32_ = _tmp31_->num;
			device_partition_set_number (_tmp30_, _tmp32_);
			_tmp33_ = new_p;
			_tmp34_ = p;
			_tmp35_ = _tmp34_->geom;
			_tmp36_ = _tmp35_.start;
			_tmp37_ = self->priv->unit_size;
			device_partition_set_start (_tmp33_, ((guint64) _tmp36_) * _tmp37_);
			_tmp38_ = new_p;
			_tmp39_ = p;
			_tmp40_ = _tmp39_->geom;
			_tmp41_ = _tmp40_.end;
			_tmp42_ = self->priv->unit_size;
			device_partition_set_end (_tmp38_, ((guint64) _tmp41_) * _tmp42_);
			_tmp43_ = new_p;
			_tmp44_ = p;
			_tmp45_ = _tmp44_->geom;
			_tmp46_ = _tmp45_.length;
			_tmp47_ = self->priv->unit_size;
			device_partition_set_size (_tmp43_, ((guint64) _tmp46_) * _tmp47_);
			_tmp48_ = new_p;
			_tmp49_ = fs;
			device_partition_set_filesystem (_tmp48_, _tmp49_);
			_tmp50_ = new_p;
			_tmp51_ = flag;
			device_partition_set_flag (_tmp50_, _tmp51_);
			_tmp52_ = new_p;
			_tmp53_ = description;
			device_partition_set_description (_tmp52_, _tmp53_);
			_tmp54_ = new_p;
			_tmp55_ = type;
			device_partition_set_ptype (_tmp54_, _tmp55_);
			_tmp56_ = new_p;
			_tmp57_ = p;
			_tmp56_->internal = _tmp57_;
			_tmp58_ = self->priv->_partitions;
			_tmp59_ = new_p;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp58_, _tmp59_);
			_g_object_unref0 (new_p);
			_g_free0 (description);
			_g_free0 (flag);
			_g_free0 (fs);
		}
		_tmp60_ = self->priv->_partitions;
		_tmp61_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp60_);
		_tmp62_ = _tmp61_;
		if (_tmp62_) {
			DevicePartition* new_p = NULL;
			guint64 _tmp63_ = 0ULL;
			DevicePartition* _tmp64_ = NULL;
			GeeArrayList* _tmp65_ = NULL;
			DevicePartition* _tmp66_ = NULL;
			_tmp63_ = device_get_size (self);
			_tmp64_ = device_partition_new_blank_with_size (_tmp63_ - 1);
			new_p = _tmp64_;
			_tmp65_ = self->priv->_partitions;
			_tmp66_ = new_p;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp65_, _tmp66_);
			_g_object_unref0 (new_p);
		}
	} else {
		PedDiskType* diskType = NULL;
		PedDiskType* _tmp67_ = NULL;
		PedDevice* _tmp68_ = NULL;
		PedDiskType* _tmp69_ = NULL;
		PedDisk* _tmp70_ = NULL;
		DevicePartition* new_p = NULL;
		guint64 _tmp71_ = 0ULL;
		DevicePartition* _tmp72_ = NULL;
		GeeArrayList* _tmp73_ = NULL;
		DevicePartition* _tmp74_ = NULL;
		_tmp67_ = ped_disk_type_get ("gpt");
		diskType = _tmp67_;
		_tmp68_ = self->priv->device;
		_tmp69_ = diskType;
		_tmp70_ = ped_disk_new_fresh (_tmp68_, _tmp69_);
		_ped_disk_destroy0 (self->priv->disk);
		self->priv->disk = _tmp70_;
		_tmp71_ = device_get_size (self);
		_tmp72_ = device_partition_new_blank_with_size (_tmp71_ - 1);
		new_p = _tmp72_;
		_tmp73_ = self->priv->_partitions;
		_tmp74_ = new_p;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp73_, _tmp74_);
		_g_object_unref0 (new_p);
	}
}


gchar* device_get_path (Device* self) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	PedDevice* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->priv->device;
	_tmp3_ = _tmp2_->path;
	_tmp4_ = g_strdup (_tmp3_);
	result = _tmp4_;
	return result;
}


gchar* device_get_model (Device* self) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	PedDevice* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->priv->device;
	_tmp3_ = _tmp2_->model;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ > 0) {
		PedDevice* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		_tmp6_ = self->priv->device;
		_tmp7_ = _tmp6_->model;
		_tmp8_ = g_strdup (_tmp7_);
		result = _tmp8_;
		return result;
	} else {
		gchar* _tmp9_ = NULL;
		_tmp9_ = g_strdup ("Unknown model");
		result = _tmp9_;
		return result;
	}
}


guint64 device_get_size (Device* self) {
	guint64 result = 0ULL;
	gboolean _tmp0_ = FALSE;
	PedDevice* _tmp1_ = NULL;
	guint64 _tmp2_ = 0ULL;
	guint64 _tmp3_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		result = (guint64) 0;
		return result;
	}
	_tmp1_ = self->priv->device;
	_tmp2_ = _tmp1_->length;
	_tmp3_ = self->priv->unit_size;
	result = ((guint64) _tmp2_) * _tmp3_;
	return result;
}


gchar* device_get_label (Device* self) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	PedDisk* _tmp2_ = NULL;
	PedDisk* _tmp4_ = NULL;
	PedDiskType* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->priv->disk;
	if (_tmp2_ == NULL) {
		gchar* _tmp3_ = NULL;
		_tmp3_ = g_strdup ("");
		result = _tmp3_;
		return result;
	}
	_tmp4_ = self->priv->disk;
	_tmp5_ = _tmp4_->type;
	_tmp6_ = _tmp5_->name;
	_tmp7_ = g_strdup (_tmp6_);
	result = _tmp7_;
	return result;
}


gint device_get_num_partitions (Device* self) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gint retval = 0;
	PedPartition* p = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		result = 0;
		return result;
	}
	retval = 0;
	p = NULL;
	while (TRUE) {
		PedDisk* _tmp1_ = NULL;
		PedPartition* _tmp2_ = NULL;
		PedPartition* _tmp3_ = NULL;
		PedPartition* _tmp4_ = NULL;
		PedPartition* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		_tmp1_ = self->priv->disk;
		_tmp2_ = p;
		_tmp3_ = ped_disk_next_partition (_tmp1_, _tmp2_);
		p = _tmp3_;
		_tmp4_ = p;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = p;
		_tmp6_ = _tmp5_->num;
		if (_tmp6_ >= 0) {
			gint _tmp7_ = 0;
			_tmp7_ = retval;
			retval = _tmp7_ + 1;
		}
	}
	result = retval;
	return result;
}


guint64 device_get_unit_size (Device* self) {
	guint64 result = 0ULL;
	guint64 _tmp0_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->unit_size;
	result = _tmp0_;
	return result;
}


void device_commit_changes (Device* self) {
	gboolean _tmp0_ = FALSE;
	PedDisk* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->valid;
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = self->priv->disk;
	if (_tmp1_ != NULL) {
		PedDisk* _tmp2_ = NULL;
		PedDisk* _tmp3_ = NULL;
		_tmp2_ = self->priv->disk;
		ped_disk_commit_to_dev (_tmp2_);
		_tmp3_ = self->priv->disk;
		ped_disk_commit_to_os (_tmp3_);
	}
}


gint device_delete_partition (Device* self, gint index, GError** error) {
	gint result = 0;
	PedPartition* p = NULL;
	PedDisk* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	PedPartition* _tmp2_ = NULL;
	PedPartition* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->disk;
	_tmp1_ = index;
	_tmp2_ = ped_disk_get_partition (_tmp0_, _tmp1_);
	p = _tmp2_;
	_tmp3_ = p;
	if (_tmp3_ != NULL) {
		gint retval = 0;
		PedDisk* _tmp4_ = NULL;
		PedPartition* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		_tmp4_ = self->priv->disk;
		_tmp5_ = p;
		_tmp6_ = ped_disk_delete_partition (_tmp4_, _tmp5_);
		retval = _tmp6_;
		device_commit_changes (self);
		result = retval;
		return result;
	} else {
		GError* _tmp7_ = NULL;
		_tmp7_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to delete existing partition\n");
		_inner_error_ = _tmp7_;
		if (_inner_error_->domain == DEVICE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
}


static void _vala_array_add1 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void _vala_array_add2 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


gint device_create_partition (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, const gchar* type, const gchar* mount, GError** error) {
	gint result = 0;
	PedPartition* new_partition = NULL;
	PedFileSystemType* fs_type = NULL;
	const gchar* _tmp0_ = NULL;
	PedFileSystemType* _tmp1_ = NULL;
	guint64 start = 0ULL;
	guint64 _tmp2_ = 0ULL;
	guint64 _tmp3_ = 0ULL;
	guint64 end = 0ULL;
	guint64 _tmp4_ = 0ULL;
	guint64 _tmp5_ = 0ULL;
	PedFileSystemType* new_fs = NULL;
	const gchar* _tmp6_ = NULL;
	PedFileSystemType* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	PedPartition* _tmp26_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (fs != NULL, 0);
	g_return_val_if_fail (type != NULL, 0);
	g_return_val_if_fail (mount != NULL, 0);
	new_partition = NULL;
	_tmp0_ = fs;
	_tmp1_ = ped_file_system_type_get (_tmp0_);
	fs_type = _tmp1_;
	_tmp2_ = byte_start;
	_tmp3_ = device_get_unit_size (self);
	start = (guint64) (_tmp2_ / _tmp3_);
	_tmp4_ = byte_end;
	_tmp5_ = device_get_unit_size (self);
	end = (guint64) (_tmp4_ / _tmp5_);
	_tmp6_ = fs;
	_tmp7_ = ped_file_system_type_get (_tmp6_);
	new_fs = _tmp7_;
	_tmp8_ = type;
	if (g_strcmp0 (_tmp8_, "normal") == 0) {
		PedDisk* _tmp9_ = NULL;
		PedFileSystemType* _tmp10_ = NULL;
		guint64 _tmp11_ = 0ULL;
		guint64 _tmp12_ = 0ULL;
		PedPartition* _tmp13_ = NULL;
		_tmp9_ = self->priv->disk;
		_tmp10_ = new_fs;
		_tmp11_ = start;
		_tmp12_ = end;
		_tmp13_ = ped_partition_new (_tmp9_, PED_PARTITION_NORMAL, _tmp10_, _tmp11_, _tmp12_);
		new_partition = _tmp13_;
	} else {
		const gchar* _tmp14_ = NULL;
		_tmp14_ = type;
		if (g_strcmp0 (_tmp14_, "extended") == 0) {
			PedDisk* _tmp15_ = NULL;
			PedFileSystemType* _tmp16_ = NULL;
			guint64 _tmp17_ = 0ULL;
			guint64 _tmp18_ = 0ULL;
			PedPartition* _tmp19_ = NULL;
			_tmp15_ = self->priv->disk;
			_tmp16_ = new_fs;
			_tmp17_ = start;
			_tmp18_ = end;
			_tmp19_ = ped_partition_new (_tmp15_, PED_PARTITION_EXTENDED, _tmp16_, _tmp17_, _tmp18_);
			new_partition = _tmp19_;
		} else {
			const gchar* _tmp20_ = NULL;
			_tmp20_ = type;
			if (g_strcmp0 (_tmp20_, "logical") == 0) {
				PedDisk* _tmp21_ = NULL;
				PedFileSystemType* _tmp22_ = NULL;
				guint64 _tmp23_ = 0ULL;
				guint64 _tmp24_ = 0ULL;
				PedPartition* _tmp25_ = NULL;
				_tmp21_ = self->priv->disk;
				_tmp22_ = new_fs;
				_tmp23_ = start;
				_tmp24_ = end;
				_tmp25_ = ped_partition_new (_tmp21_, PED_PARTITION_LOGICAL, _tmp22_, _tmp23_, _tmp24_);
				new_partition = _tmp25_;
			}
		}
	}
	_tmp26_ = new_partition;
	if (_tmp26_ != NULL) {
		gint* p_num_array = NULL;
		gint* _tmp27_ = NULL;
		gint p_num_array_length1 = 0;
		gint _p_num_array_size_ = 0;
		PedPartition* p = NULL;
		PedDisk* _tmp28_ = NULL;
		PedPartition* _tmp29_ = NULL;
		gint part_num = 0;
		PedDisk* _tmp46_ = NULL;
		PedPartition* _tmp47_ = NULL;
		PedDevice* _tmp48_ = NULL;
		PedConstraint* _tmp49_ = NULL;
		PedConstraint* _tmp50_ = NULL;
		gint _tmp51_ = 0;
		gint _tmp52_ = 0;
		gint _tmp53_ = 0;
		gint* p_num_array_new = NULL;
		gint* _tmp55_ = NULL;
		gint p_num_array_new_length1 = 0;
		gint _p_num_array_new_size_ = 0;
		PedPartition* q = NULL;
		PedDisk* _tmp56_ = NULL;
		PedPartition* _tmp57_ = NULL;
		gint* _tmp74_ = NULL;
		gint _tmp74__length1 = 0;
		_tmp27_ = g_new0 (gint, 0);
		p_num_array = _tmp27_;
		p_num_array_length1 = 0;
		_p_num_array_size_ = p_num_array_length1;
		_tmp28_ = self->priv->disk;
		_tmp29_ = _tmp28_->part_list;
		p = _tmp29_;
		while (TRUE) {
			PedDisk* _tmp30_ = NULL;
			PedPartition* _tmp31_ = NULL;
			PedPartition* _tmp32_ = NULL;
			PedPartition* _tmp33_ = NULL;
			gint* _tmp34_ = NULL;
			gint _tmp34__length1 = 0;
			PedPartition* _tmp35_ = NULL;
			gint _tmp36_ = 0;
			FILE* _tmp37_ = NULL;
			PedPartition* _tmp38_ = NULL;
			gint _tmp39_ = 0;
			gchar* _tmp40_ = NULL;
			gchar* _tmp41_ = NULL;
			gchar* _tmp42_ = NULL;
			gchar* _tmp43_ = NULL;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			_tmp30_ = self->priv->disk;
			_tmp31_ = p;
			_tmp32_ = ped_disk_next_partition (_tmp30_, _tmp31_);
			p = _tmp32_;
			_tmp33_ = p;
			if (!(_tmp33_ != NULL)) {
				break;
			}
			_tmp34_ = p_num_array;
			_tmp34__length1 = p_num_array_length1;
			_tmp35_ = p;
			_tmp36_ = _tmp35_->num;
			_vala_array_add1 (&p_num_array, &p_num_array_length1, &_p_num_array_size_, _tmp36_);
			_tmp37_ = stdout;
			_tmp38_ = p;
			_tmp39_ = _tmp38_->num;
			_tmp40_ = g_strdup_printf ("%i", _tmp39_);
			_tmp41_ = _tmp40_;
			_tmp42_ = g_strconcat ("origin : ", _tmp41_, NULL);
			_tmp43_ = _tmp42_;
			_tmp44_ = g_strconcat (_tmp43_, "\n", NULL);
			_tmp45_ = _tmp44_;
			fprintf (_tmp37_, "%s", _tmp45_);
			_g_free0 (_tmp45_);
			_g_free0 (_tmp43_);
			_g_free0 (_tmp41_);
		}
		_tmp46_ = self->priv->disk;
		_tmp47_ = new_partition;
		_tmp48_ = self->priv->device;
		_tmp49_ = ped_constraint_any (_tmp48_);
		_tmp50_ = _tmp49_;
		_tmp51_ = ped_disk_add_partition (_tmp46_, _tmp47_, _tmp50_);
		_tmp52_ = _tmp51_;
		_ped_constraint_destroy0 (_tmp50_);
		part_num = _tmp52_;
		_tmp53_ = part_num;
		if (_tmp53_ == 0) {
			GError* _tmp54_ = NULL;
			_tmp54_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to create partition\n");
			_inner_error_ = _tmp54_;
			if (_inner_error_->domain == DEVICE_ERROR) {
				g_propagate_error (error, _inner_error_);
				p_num_array = (g_free (p_num_array), NULL);
				return 0;
			} else {
				p_num_array = (g_free (p_num_array), NULL);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		}
		device_commit_changes (self);
		_tmp55_ = g_new0 (gint, 0);
		p_num_array_new = _tmp55_;
		p_num_array_new_length1 = 0;
		_p_num_array_new_size_ = p_num_array_new_length1;
		_tmp56_ = self->priv->disk;
		_tmp57_ = _tmp56_->part_list;
		q = _tmp57_;
		while (TRUE) {
			PedDisk* _tmp58_ = NULL;
			PedPartition* _tmp59_ = NULL;
			PedPartition* _tmp60_ = NULL;
			PedPartition* _tmp61_ = NULL;
			gint* _tmp62_ = NULL;
			gint _tmp62__length1 = 0;
			PedPartition* _tmp63_ = NULL;
			gint _tmp64_ = 0;
			FILE* _tmp65_ = NULL;
			PedPartition* _tmp66_ = NULL;
			gint _tmp67_ = 0;
			gchar* _tmp68_ = NULL;
			gchar* _tmp69_ = NULL;
			gchar* _tmp70_ = NULL;
			gchar* _tmp71_ = NULL;
			gchar* _tmp72_ = NULL;
			gchar* _tmp73_ = NULL;
			_tmp58_ = self->priv->disk;
			_tmp59_ = q;
			_tmp60_ = ped_disk_next_partition (_tmp58_, _tmp59_);
			q = _tmp60_;
			_tmp61_ = q;
			if (!(_tmp61_ != NULL)) {
				break;
			}
			_tmp62_ = p_num_array_new;
			_tmp62__length1 = p_num_array_new_length1;
			_tmp63_ = q;
			_tmp64_ = _tmp63_->num;
			_vala_array_add2 (&p_num_array_new, &p_num_array_new_length1, &_p_num_array_new_size_, _tmp64_);
			_tmp65_ = stdout;
			_tmp66_ = q;
			_tmp67_ = _tmp66_->num;
			_tmp68_ = g_strdup_printf ("%i", _tmp67_);
			_tmp69_ = _tmp68_;
			_tmp70_ = g_strconcat ("next : ", _tmp69_, NULL);
			_tmp71_ = _tmp70_;
			_tmp72_ = g_strconcat (_tmp71_, "\n", NULL);
			_tmp73_ = _tmp72_;
			fprintf (_tmp65_, "%s", _tmp73_);
			_g_free0 (_tmp73_);
			_g_free0 (_tmp71_);
			_g_free0 (_tmp69_);
		}
		_tmp74_ = p_num_array_new;
		_tmp74__length1 = p_num_array_new_length1;
		{
			gint* x_collection = NULL;
			gint x_collection_length1 = 0;
			gint _x_collection_size_ = 0;
			gint x_it = 0;
			x_collection = _tmp74_;
			x_collection_length1 = _tmp74__length1;
			for (x_it = 0; x_it < _tmp74__length1; x_it = x_it + 1) {
				gint x = 0;
				x = x_collection[x_it];
				{
					gboolean is_exists = FALSE;
					gboolean _tmp83_ = FALSE;
					is_exists = FALSE;
					{
						gint i = 0;
						i = 0;
						{
							gboolean _tmp75_ = FALSE;
							_tmp75_ = TRUE;
							while (TRUE) {
								gint _tmp77_ = 0;
								gint* _tmp78_ = NULL;
								gint _tmp78__length1 = 0;
								gint _tmp79_ = 0;
								gint* _tmp80_ = NULL;
								gint _tmp80__length1 = 0;
								gint _tmp81_ = 0;
								gint _tmp82_ = 0;
								if (!_tmp75_) {
									gint _tmp76_ = 0;
									_tmp76_ = i;
									i = _tmp76_ + 1;
								}
								_tmp75_ = FALSE;
								_tmp77_ = i;
								_tmp78_ = p_num_array;
								_tmp78__length1 = p_num_array_length1;
								if (!(_tmp77_ < _tmp78__length1)) {
									break;
								}
								_tmp79_ = x;
								_tmp80_ = p_num_array;
								_tmp80__length1 = p_num_array_length1;
								_tmp81_ = i;
								_tmp82_ = _tmp80_[_tmp81_];
								if (_tmp79_ == _tmp82_) {
									is_exists = TRUE;
								}
							}
						}
					}
					_tmp83_ = is_exists;
					if (_tmp83_ == FALSE) {
						gint _tmp84_ = 0;
						_tmp84_ = x;
						part_num = _tmp84_;
					}
				}
			}
		}
		result = part_num;
		p_num_array_new = (g_free (p_num_array_new), NULL);
		p_num_array = (g_free (p_num_array), NULL);
		return result;
	} else {
		GError* _tmp85_ = NULL;
		_tmp85_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to create custom partition\n");
		_inner_error_ = _tmp85_;
		if (_inner_error_->domain == DEVICE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
}


gint device_create_partition_simple (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, guint64 swap_size, GError** error) {
	gint result = 0;
	PedDevice* _tmp0_ = NULL;
	guint64 _tmp2_ = 0ULL;
	guint64 _tmp3_ = 0ULL;
	gboolean create_extended = FALSE;
	gboolean create_logical = FALSE;
	gboolean has_extended = FALSE;
	gboolean _tmp55_ = FALSE;
	gboolean _tmp56_ = FALSE;
	PedDisk* _tmp62_ = NULL;
	PedPartition* new_partition = NULL;
	PedFileSystemType* fs_type = NULL;
	const gchar* _tmp69_ = NULL;
	PedFileSystemType* _tmp70_ = NULL;
	guint64 start = 0ULL;
	guint64 _tmp71_ = 0ULL;
	guint64 _tmp72_ = 0ULL;
	guint64 end = 0ULL;
	guint64 _tmp73_ = 0ULL;
	guint64 _tmp74_ = 0ULL;
	gboolean _tmp75_ = FALSE;
	PedPartition* _tmp145_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (fs != NULL, 0);
	_tmp0_ = self->priv->device;
	if (_tmp0_ == NULL) {
		GError* _tmp1_ = NULL;
		_tmp1_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Invalid device");
		_inner_error_ = _tmp1_;
		if (_inner_error_->domain == DEVICE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	_tmp2_ = byte_end;
	_tmp3_ = byte_start;
	if (_tmp2_ <= _tmp3_) {
		guint64 _tmp4_ = 0ULL;
		guint64 _tmp5_ = 0ULL;
		GError* _tmp6_ = NULL;
		_tmp4_ = byte_end;
		_tmp5_ = byte_start;
		_tmp6_ = g_error_new (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "byte_end <= byte_start: %ld < %ld\n", (glong) _tmp4_, (glong) _tmp5_);
		_inner_error_ = _tmp6_;
		if (_inner_error_->domain == DEVICE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	create_extended = FALSE;
	create_logical = FALSE;
	has_extended = FALSE;
	{
		GeeArrayList* _p_list = NULL;
		GeeArrayList* _tmp7_ = NULL;
		GeeArrayList* _tmp8_ = NULL;
		gint _p_size = 0;
		GeeArrayList* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		gint _p_index = 0;
		_tmp7_ = self->priv->_partitions;
		_tmp8_ = _g_object_ref0 (_tmp7_);
		_p_list = _tmp8_;
		_tmp9_ = _p_list;
		_tmp10_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp9_);
		_tmp11_ = _tmp10_;
		_p_size = _tmp11_;
		_p_index = -1;
		while (TRUE) {
			gint _tmp12_ = 0;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			DevicePartition* p = NULL;
			GeeArrayList* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			gpointer _tmp17_ = NULL;
			DevicePartition* _tmp18_ = NULL;
			DevicePartitionType _tmp19_ = 0;
			DevicePartitionType _tmp20_ = 0;
			guint64 _tmp21_ = 0ULL;
			DevicePartition* _tmp22_ = NULL;
			guint64 _tmp23_ = 0ULL;
			guint64 _tmp24_ = 0ULL;
			gboolean _tmp28_ = FALSE;
			guint64 _tmp29_ = 0ULL;
			DevicePartition* _tmp30_ = NULL;
			guint64 _tmp31_ = 0ULL;
			guint64 _tmp32_ = 0ULL;
			_tmp12_ = _p_index;
			_p_index = _tmp12_ + 1;
			_tmp13_ = _p_index;
			_tmp14_ = _p_size;
			if (!(_tmp13_ < _tmp14_)) {
				break;
			}
			_tmp15_ = _p_list;
			_tmp16_ = _p_index;
			_tmp17_ = gee_abstract_list_get ((GeeAbstractList*) _tmp15_, _tmp16_);
			p = (DevicePartition*) _tmp17_;
			_tmp18_ = p;
			_tmp19_ = device_partition_get_ptype (_tmp18_);
			_tmp20_ = _tmp19_;
			if (_tmp20_ == DEVICE_PARTITION_TYPE_EXTENDED) {
				has_extended = TRUE;
			}
			_tmp21_ = byte_start;
			_tmp22_ = p;
			_tmp23_ = device_partition_get_start (_tmp22_);
			_tmp24_ = _tmp23_;
			if (_tmp21_ < _tmp24_) {
				DevicePartition* _tmp25_ = NULL;
				guint64 _tmp26_ = 0ULL;
				guint64 _tmp27_ = 0ULL;
				_tmp25_ = p;
				_tmp26_ = device_partition_get_start (_tmp25_);
				_tmp27_ = _tmp26_;
				byte_start = _tmp27_;
			}
			_tmp29_ = byte_start;
			_tmp30_ = p;
			_tmp31_ = device_partition_get_start (_tmp30_);
			_tmp32_ = _tmp31_;
			if (_tmp29_ >= _tmp32_) {
				guint64 _tmp33_ = 0ULL;
				DevicePartition* _tmp34_ = NULL;
				guint64 _tmp35_ = 0ULL;
				guint64 _tmp36_ = 0ULL;
				_tmp33_ = byte_end;
				_tmp34_ = p;
				_tmp35_ = device_partition_get_end (_tmp34_);
				_tmp36_ = _tmp35_;
				_tmp28_ = _tmp33_ <= _tmp36_;
			} else {
				_tmp28_ = FALSE;
			}
			if (_tmp28_) {
				gboolean _tmp37_ = FALSE;
				DevicePartition* _tmp38_ = NULL;
				DevicePartitionType _tmp39_ = 0;
				DevicePartitionType _tmp40_ = 0;
				DevicePartition* _tmp48_ = NULL;
				DevicePartitionType _tmp49_ = 0;
				DevicePartitionType _tmp50_ = 0;
				_tmp38_ = p;
				_tmp39_ = device_partition_get_ptype (_tmp38_);
				_tmp40_ = _tmp39_;
				if (_tmp40_ == DEVICE_PARTITION_TYPE_EXTENDED) {
					_tmp37_ = TRUE;
				} else {
					DevicePartition* _tmp41_ = NULL;
					DevicePartitionType _tmp42_ = 0;
					DevicePartitionType _tmp43_ = 0;
					_tmp41_ = p;
					_tmp42_ = device_partition_get_ptype (_tmp41_);
					_tmp43_ = _tmp42_;
					_tmp37_ = _tmp43_ == DEVICE_PARTITION_TYPE_FREESPACE;
				}
				if (!_tmp37_) {
					DevicePartition* _tmp44_ = NULL;
					DevicePartitionType _tmp45_ = 0;
					DevicePartitionType _tmp46_ = 0;
					GError* _tmp47_ = NULL;
					_tmp44_ = p;
					_tmp45_ = device_partition_get_ptype (_tmp44_);
					_tmp46_ = _tmp45_;
					_tmp47_ = g_error_new (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Partition to be created is inside another partition which is not an EX" \
"TENDED nor a FREE partition. %d\n", (gint) _tmp46_);
					_inner_error_ = _tmp47_;
					if (_inner_error_->domain == DEVICE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (p);
						_g_object_unref0 (_p_list);
						return 0;
					} else {
						_g_object_unref0 (p);
						_g_object_unref0 (_p_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
				}
				_tmp48_ = p;
				_tmp49_ = device_partition_get_ptype (_tmp48_);
				_tmp50_ = _tmp49_;
				if (_tmp50_ == DEVICE_PARTITION_TYPE_FREESPACE) {
					gboolean _tmp51_ = FALSE;
					_tmp51_ = has_extended;
					if (_tmp51_ == FALSE) {
						create_extended = TRUE;
					}
					create_logical = TRUE;
				} else {
					DevicePartition* _tmp52_ = NULL;
					DevicePartitionType _tmp53_ = 0;
					DevicePartitionType _tmp54_ = 0;
					_tmp52_ = p;
					_tmp53_ = device_partition_get_ptype (_tmp52_);
					_tmp54_ = _tmp53_;
					if (_tmp54_ == DEVICE_PARTITION_TYPE_EXTENDED) {
						create_logical = TRUE;
					}
				}
				_g_object_unref0 (p);
				break;
			}
			_g_object_unref0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	_tmp56_ = has_extended;
	if (_tmp56_) {
		gboolean _tmp57_ = FALSE;
		_tmp57_ = create_extended;
		_tmp55_ = _tmp57_;
	} else {
		_tmp55_ = FALSE;
	}
	if (_tmp55_) {
		GeeArrayList* _tmp58_ = NULL;
		gint _tmp59_ = 0;
		gint _tmp60_ = 0;
		_tmp58_ = self->priv->_partitions;
		_tmp59_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp58_);
		_tmp60_ = _tmp59_;
		if (_tmp60_ > 3) {
			GError* _tmp61_ = NULL;
			_tmp61_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "No more partitions can be created\n");
			_inner_error_ = _tmp61_;
			if (_inner_error_->domain == DEVICE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return 0;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		}
		create_extended = FALSE;
	}
	_tmp62_ = self->priv->disk;
	if (_tmp62_ == NULL) {
		PedDevice* _tmp63_ = NULL;
		PedDiskType* _tmp64_ = NULL;
		PedDisk* _tmp65_ = NULL;
		FILE* _tmp66_ = NULL;
		PedDisk* _tmp67_ = NULL;
		_tmp63_ = self->priv->device;
		_tmp64_ = ped_disk_type_get ("msdos");
		_tmp65_ = ped_disk_new_fresh (_tmp63_, _tmp64_);
		_ped_disk_destroy0 (self->priv->disk);
		self->priv->disk = _tmp65_;
		_tmp66_ = stdout;
		fprintf (_tmp66_, "Label created\n");
		_tmp67_ = self->priv->disk;
		if (_tmp67_ != NULL) {
			PedDisk* _tmp68_ = NULL;
			_tmp68_ = self->priv->disk;
			ped_disk_commit_to_dev (_tmp68_);
		}
	}
	new_partition = NULL;
	_tmp69_ = fs;
	_tmp70_ = ped_file_system_type_get (_tmp69_);
	fs_type = _tmp70_;
	_tmp71_ = byte_start;
	_tmp72_ = device_get_unit_size (self);
	start = (guint64) (_tmp71_ / _tmp72_);
	_tmp73_ = byte_end;
	_tmp74_ = device_get_unit_size (self);
	end = (guint64) (_tmp73_ / _tmp74_);
	_tmp75_ = create_logical;
	if (_tmp75_) {
		gboolean _tmp76_ = FALSE;
		guint64 _tmp112_ = 0ULL;
		PedDisk* _tmp135_ = NULL;
		PedFileSystemType* _tmp136_ = NULL;
		guint64 _tmp137_ = 0ULL;
		guint64 _tmp138_ = 0ULL;
		PedPartition* _tmp139_ = NULL;
		_tmp76_ = create_extended;
		if (_tmp76_) {
			FILE* _tmp77_ = NULL;
			PedFileSystemType* ext_fs = NULL;
			PedFileSystemType* _tmp78_ = NULL;
			PedPartition* ext = NULL;
			PedDisk* _tmp79_ = NULL;
			PedFileSystemType* _tmp80_ = NULL;
			guint64 _tmp81_ = 0ULL;
			guint64 _tmp82_ = 0ULL;
			PedPartition* _tmp83_ = NULL;
			FILE* _tmp84_ = NULL;
			gchar* _tmp85_ = NULL;
			gchar* _tmp86_ = NULL;
			PedPartition* _tmp87_ = NULL;
			gint _tmp88_ = 0;
			FILE* _tmp89_ = NULL;
			guint64 _tmp90_ = 0ULL;
			gchar* _tmp91_ = NULL;
			gchar* _tmp92_ = NULL;
			gchar* _tmp93_ = NULL;
			gchar* _tmp94_ = NULL;
			gchar* _tmp95_ = NULL;
			gchar* _tmp96_ = NULL;
			guint64 _tmp97_ = 0ULL;
			gchar* _tmp98_ = NULL;
			gchar* _tmp99_ = NULL;
			gchar* _tmp100_ = NULL;
			gchar* _tmp101_ = NULL;
			gchar* _tmp102_ = NULL;
			gchar* _tmp103_ = NULL;
			PedDisk* _tmp104_ = NULL;
			PedPartition* _tmp105_ = NULL;
			PedDevice* _tmp106_ = NULL;
			PedConstraint* _tmp107_ = NULL;
			PedConstraint* _tmp108_ = NULL;
			PedDisk* _tmp109_ = NULL;
			PedPartition* _tmp110_ = NULL;
			_tmp77_ = stdout;
			fprintf (_tmp77_, "Creating extended partition\n");
			_tmp78_ = ped_file_system_type_get ("ext3");
			ext_fs = _tmp78_;
			_tmp79_ = self->priv->disk;
			_tmp80_ = ext_fs;
			_tmp81_ = start;
			_tmp82_ = end;
			_tmp83_ = ped_partition_new (_tmp79_, PED_PARTITION_EXTENDED, _tmp80_, _tmp81_, _tmp82_);
			ext = _tmp83_;
			_tmp84_ = stdout;
			_tmp85_ = device_get_path (self);
			_tmp86_ = _tmp85_;
			_tmp87_ = ext;
			_tmp88_ = _tmp87_->num;
			fprintf (_tmp84_, "Extended partition %s%d\n", _tmp86_, _tmp88_);
			_g_free0 (_tmp86_);
			_tmp89_ = stdout;
			_tmp90_ = start;
			_tmp91_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp90_);
			_tmp92_ = _tmp91_;
			_tmp93_ = g_strconcat ("\nstart : ", _tmp92_, NULL);
			_tmp94_ = _tmp93_;
			_tmp95_ = g_strconcat (_tmp94_, " end : ", NULL);
			_tmp96_ = _tmp95_;
			_tmp97_ = end;
			_tmp98_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp97_);
			_tmp99_ = _tmp98_;
			_tmp100_ = g_strconcat (_tmp96_, _tmp99_, NULL);
			_tmp101_ = _tmp100_;
			_tmp102_ = g_strconcat (_tmp101_, "\n", NULL);
			_tmp103_ = _tmp102_;
			fprintf (_tmp89_, "%s", _tmp103_);
			_g_free0 (_tmp103_);
			_g_free0 (_tmp101_);
			_g_free0 (_tmp99_);
			_g_free0 (_tmp96_);
			_g_free0 (_tmp94_);
			_g_free0 (_tmp92_);
			_tmp104_ = self->priv->disk;
			_tmp105_ = ext;
			_tmp106_ = self->priv->device;
			_tmp107_ = ped_constraint_any (_tmp106_);
			_tmp108_ = _tmp107_;
			ped_disk_add_partition (_tmp104_, _tmp105_, _tmp108_);
			_ped_constraint_destroy0 (_tmp108_);
			_tmp109_ = self->priv->disk;
			ped_disk_commit_to_dev (_tmp109_);
			_tmp110_ = ext;
			if (_tmp110_ == NULL) {
				GError* _tmp111_ = NULL;
				_tmp111_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Can't create extended partition\n");
				_inner_error_ = _tmp111_;
				if (_inner_error_->domain == DEVICE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return 0;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
			}
		}
		_tmp112_ = swap_size;
		if (_tmp112_ > ((guint64) 0)) {
			guint64 swap_size_sector = 0ULL;
			guint64 _tmp113_ = 0ULL;
			guint64 _tmp114_ = 0ULL;
			guint64 _tmp115_ = 0ULL;
			guint64 _tmp116_ = 0ULL;
			PedFileSystemType* swap_type = NULL;
			PedFileSystemType* _tmp117_ = NULL;
			PedDisk* _tmp118_ = NULL;
			PedFileSystemType* _tmp119_ = NULL;
			guint64 _tmp120_ = 0ULL;
			guint64 _tmp121_ = 0ULL;
			PedPartition* _tmp122_ = NULL;
			guint64 _tmp123_ = 0ULL;
			guint64 _tmp124_ = 0ULL;
			guint64 _tmp125_ = 0ULL;
			gint part_num = 0;
			PedDisk* _tmp126_ = NULL;
			PedPartition* _tmp127_ = NULL;
			PedDevice* _tmp128_ = NULL;
			PedConstraint* _tmp129_ = NULL;
			PedConstraint* _tmp130_ = NULL;
			gint _tmp131_ = 0;
			gint _tmp132_ = 0;
			gint _tmp133_ = 0;
			_tmp113_ = swap_size;
			_tmp114_ = device_get_unit_size (self);
			swap_size_sector = (guint64) (_tmp113_ / _tmp114_);
			_tmp115_ = start;
			_tmp116_ = swap_size_sector;
			end = _tmp115_ + _tmp116_;
			_tmp117_ = ped_file_system_type_get ("linux-swap(v1)");
			swap_type = _tmp117_;
			_tmp118_ = self->priv->disk;
			_tmp119_ = swap_type;
			_tmp120_ = start;
			_tmp121_ = end;
			_tmp122_ = ped_partition_new (_tmp118_, PED_PARTITION_LOGICAL, _tmp119_, _tmp120_, _tmp121_);
			new_partition = _tmp122_;
			_tmp123_ = end;
			start = _tmp123_ + 1;
			_tmp124_ = byte_end;
			_tmp125_ = device_get_unit_size (self);
			end = (guint64) (_tmp124_ / _tmp125_);
			_tmp126_ = self->priv->disk;
			_tmp127_ = new_partition;
			_tmp128_ = self->priv->device;
			_tmp129_ = ped_constraint_any (_tmp128_);
			_tmp130_ = _tmp129_;
			_tmp131_ = ped_disk_add_partition (_tmp126_, _tmp127_, _tmp130_);
			_tmp132_ = _tmp131_;
			_ped_constraint_destroy0 (_tmp130_);
			part_num = _tmp132_;
			_tmp133_ = part_num;
			if (_tmp133_ == 0) {
				GError* _tmp134_ = NULL;
				_tmp134_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to create swap\n");
				_inner_error_ = _tmp134_;
				if (_inner_error_->domain == DEVICE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return 0;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
			}
		}
		_tmp135_ = self->priv->disk;
		_tmp136_ = fs_type;
		_tmp137_ = start;
		_tmp138_ = end;
		_tmp139_ = ped_partition_new (_tmp135_, PED_PARTITION_LOGICAL, _tmp136_, _tmp137_, _tmp138_);
		new_partition = _tmp139_;
	} else {
		PedDisk* _tmp140_ = NULL;
		PedFileSystemType* _tmp141_ = NULL;
		guint64 _tmp142_ = 0ULL;
		guint64 _tmp143_ = 0ULL;
		PedPartition* _tmp144_ = NULL;
		_tmp140_ = self->priv->disk;
		_tmp141_ = fs_type;
		_tmp142_ = start;
		_tmp143_ = end;
		_tmp144_ = ped_partition_new (_tmp140_, PED_PARTITION_NORMAL, _tmp141_, _tmp142_, _tmp143_);
		new_partition = _tmp144_;
	}
	_tmp145_ = new_partition;
	if (_tmp145_ != NULL) {
		gint part_num = 0;
		PedDisk* _tmp146_ = NULL;
		PedPartition* _tmp147_ = NULL;
		PedDevice* _tmp148_ = NULL;
		PedConstraint* _tmp149_ = NULL;
		PedConstraint* _tmp150_ = NULL;
		gint _tmp151_ = 0;
		gint _tmp152_ = 0;
		gint _tmp153_ = 0;
		PedDisk* _tmp155_ = NULL;
		PedDisk* _tmp156_ = NULL;
		PedPartition* _tmp157_ = NULL;
		gint _tmp158_ = 0;
		_tmp146_ = self->priv->disk;
		_tmp147_ = new_partition;
		_tmp148_ = self->priv->device;
		_tmp149_ = ped_constraint_any (_tmp148_);
		_tmp150_ = _tmp149_;
		_tmp151_ = ped_disk_add_partition (_tmp146_, _tmp147_, _tmp150_);
		_tmp152_ = _tmp151_;
		_ped_constraint_destroy0 (_tmp150_);
		part_num = _tmp152_;
		_tmp153_ = part_num;
		if (_tmp153_ == 0) {
			GError* _tmp154_ = NULL;
			_tmp154_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to create partition\n");
			_inner_error_ = _tmp154_;
			if (_inner_error_->domain == DEVICE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return 0;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		}
		_tmp155_ = self->priv->disk;
		ped_disk_commit_to_dev (_tmp155_);
		_tmp156_ = self->priv->disk;
		ped_disk_commit_to_os (_tmp156_);
		_tmp157_ = new_partition;
		_tmp158_ = _tmp157_->num;
		result = _tmp158_;
		return result;
	} else {
		GError* _tmp159_ = NULL;
		_tmp159_ = g_error_new_literal (DEVICE_ERROR, DEVICE_ERROR_CANT_CREATE_PARTITION, "Unable to create partition\n");
		_inner_error_ = _tmp159_;
		if (_inner_error_->domain == DEVICE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
}


GeeArrayList* device_get_partitions (Device* self) {
	GeeArrayList* result;
	GeeArrayList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_partitions;
	result = _tmp0_;
	return result;
}


void device_set_partitions (Device* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_partitions);
	self->priv->_partitions = _tmp1_;
	g_object_notify ((GObject *) self, "partitions");
}


DevicePartition* device_partition_construct (GType object_type) {
	DevicePartition * self = NULL;
	self = (DevicePartition*) g_object_new (object_type, NULL);
	device_partition_set_number (self, -1);
	device_partition_set_start (self, (guint64) (-1));
	device_partition_set_end (self, (guint64) (-1));
	device_partition_set_size (self, (guint64) (-1));
	device_partition_set_filesystem (self, "");
	device_partition_set_flag (self, "");
	device_partition_set_description (self, "");
	device_partition_set_parent (self, -1);
	device_partition_set_ptype (self, DEVICE_PARTITION_TYPE_INVALID);
	self->internal = NULL;
	return self;
}


DevicePartition* device_partition_new (void) {
	return device_partition_construct (DEVICE_TYPE_PARTITION);
}


DevicePartition* device_partition_construct_blank_with_size (GType object_type, guint64 size) {
	DevicePartition * self = NULL;
	guint64 _tmp0_ = 0ULL;
	guint64 _tmp1_ = 0ULL;
	self = (DevicePartition*) g_object_new (object_type, NULL);
	device_partition_set_number (self, -1);
	device_partition_set_start (self, (guint64) 0);
	_tmp0_ = size;
	device_partition_set_end (self, _tmp0_);
	_tmp1_ = size;
	device_partition_set_size (self, _tmp1_);
	device_partition_set_filesystem (self, "");
	device_partition_set_flag (self, "");
	device_partition_set_description (self, "");
	device_partition_set_parent (self, 0);
	device_partition_set_ptype (self, DEVICE_PARTITION_TYPE_FREESPACE);
	self->internal = NULL;
	return self;
}


DevicePartition* device_partition_new_blank_with_size (guint64 size) {
	return device_partition_construct_blank_with_size (DEVICE_TYPE_PARTITION, size);
}


gint device_partition_get_number (DevicePartition* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_number;
	result = _tmp0_;
	return result;
}


void device_partition_set_number (DevicePartition* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_number = _tmp0_;
	g_object_notify ((GObject *) self, "number");
}


guint64 device_partition_get_start (DevicePartition* self) {
	guint64 result;
	guint64 _tmp0_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->_start;
	result = _tmp0_;
	return result;
}


void device_partition_set_start (DevicePartition* self, guint64 value) {
	guint64 _tmp0_ = 0ULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_start = _tmp0_;
	g_object_notify ((GObject *) self, "start");
}


guint64 device_partition_get_end (DevicePartition* self) {
	guint64 result;
	guint64 _tmp0_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->_end;
	result = _tmp0_;
	return result;
}


void device_partition_set_end (DevicePartition* self, guint64 value) {
	guint64 _tmp0_ = 0ULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_end = _tmp0_;
	g_object_notify ((GObject *) self, "end");
}


guint64 device_partition_get_size (DevicePartition* self) {
	guint64 result;
	guint64 _tmp0_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->_size;
	result = _tmp0_;
	return result;
}


void device_partition_set_size (DevicePartition* self, guint64 value) {
	guint64 _tmp0_ = 0ULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_size = _tmp0_;
	g_object_notify ((GObject *) self, "size");
}


const gchar* device_partition_get_filesystem (DevicePartition* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filesystem;
	result = _tmp0_;
	return result;
}


void device_partition_set_filesystem (DevicePartition* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filesystem);
	self->priv->_filesystem = _tmp1_;
	g_object_notify ((GObject *) self, "filesystem");
}


const gchar* device_partition_get_flag (DevicePartition* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_flag;
	result = _tmp0_;
	return result;
}


void device_partition_set_flag (DevicePartition* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_flag);
	self->priv->_flag = _tmp1_;
	g_object_notify ((GObject *) self, "flag");
}


gint device_partition_get_parent (DevicePartition* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_parent;
	result = _tmp0_;
	return result;
}


void device_partition_set_parent (DevicePartition* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_parent = _tmp0_;
	g_object_notify ((GObject *) self, "parent");
}


const gchar* device_partition_get_description (DevicePartition* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


void device_partition_set_description (DevicePartition* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


DevicePartitionType device_partition_get_ptype (DevicePartition* self) {
	DevicePartitionType result;
	DevicePartitionType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_ptype;
	result = _tmp0_;
	return result;
}


void device_partition_set_ptype (DevicePartition* self, DevicePartitionType value) {
	DevicePartitionType _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_ptype = _tmp0_;
	g_object_notify ((GObject *) self, "ptype");
}


static void device_partition_class_init (DevicePartitionClass * klass) {
	device_partition_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DevicePartitionPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_device_partition_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_device_partition_set_property;
	G_OBJECT_CLASS (klass)->finalize = device_partition_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_NUMBER, g_param_spec_int ("number", "number", "number", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_START, g_param_spec_uint64 ("start", "start", "start", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_END, g_param_spec_uint64 ("end", "end", "end", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_SIZE, g_param_spec_uint64 ("size", "size", "size", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_FILESYSTEM, g_param_spec_string ("filesystem", "filesystem", "filesystem", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_FLAG, g_param_spec_string ("flag", "flag", "flag", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_PARENT, g_param_spec_int ("parent", "parent", "parent", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITION_PTYPE, g_param_spec_enum ("ptype", "ptype", "ptype", DEVICE_TYPE_PARTITION_TYPE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void device_partition_instance_init (DevicePartition * self) {
	self->priv = DEVICE_PARTITION_GET_PRIVATE (self);
}


static void device_partition_finalize (GObject* obj) {
	DevicePartition * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, DEVICE_TYPE_PARTITION, DevicePartition);
	_g_free0 (self->priv->_filesystem);
	_g_free0 (self->priv->_flag);
	_g_free0 (self->priv->_description);
	G_OBJECT_CLASS (device_partition_parent_class)->finalize (obj);
}


GType device_partition_get_type (void) {
	static volatile gsize device_partition_type_id__volatile = 0;
	if (g_once_init_enter (&device_partition_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DevicePartitionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) device_partition_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DevicePartition), 0, (GInstanceInitFunc) device_partition_instance_init, NULL };
		GType device_partition_type_id;
		device_partition_type_id = g_type_register_static (G_TYPE_OBJECT, "DevicePartition", &g_define_type_info, 0);
		g_once_init_leave (&device_partition_type_id__volatile, device_partition_type_id);
	}
	return device_partition_type_id__volatile;
}


static void _vala_device_partition_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DevicePartition * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, DEVICE_TYPE_PARTITION, DevicePartition);
	switch (property_id) {
		case DEVICE_PARTITION_NUMBER:
		g_value_set_int (value, device_partition_get_number (self));
		break;
		case DEVICE_PARTITION_START:
		g_value_set_uint64 (value, device_partition_get_start (self));
		break;
		case DEVICE_PARTITION_END:
		g_value_set_uint64 (value, device_partition_get_end (self));
		break;
		case DEVICE_PARTITION_SIZE:
		g_value_set_uint64 (value, device_partition_get_size (self));
		break;
		case DEVICE_PARTITION_FILESYSTEM:
		g_value_set_string (value, device_partition_get_filesystem (self));
		break;
		case DEVICE_PARTITION_FLAG:
		g_value_set_string (value, device_partition_get_flag (self));
		break;
		case DEVICE_PARTITION_PARENT:
		g_value_set_int (value, device_partition_get_parent (self));
		break;
		case DEVICE_PARTITION_DESCRIPTION:
		g_value_set_string (value, device_partition_get_description (self));
		break;
		case DEVICE_PARTITION_PTYPE:
		g_value_set_enum (value, device_partition_get_ptype (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_device_partition_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DevicePartition * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, DEVICE_TYPE_PARTITION, DevicePartition);
	switch (property_id) {
		case DEVICE_PARTITION_NUMBER:
		device_partition_set_number (self, g_value_get_int (value));
		break;
		case DEVICE_PARTITION_START:
		device_partition_set_start (self, g_value_get_uint64 (value));
		break;
		case DEVICE_PARTITION_END:
		device_partition_set_end (self, g_value_get_uint64 (value));
		break;
		case DEVICE_PARTITION_SIZE:
		device_partition_set_size (self, g_value_get_uint64 (value));
		break;
		case DEVICE_PARTITION_FILESYSTEM:
		device_partition_set_filesystem (self, g_value_get_string (value));
		break;
		case DEVICE_PARTITION_FLAG:
		device_partition_set_flag (self, g_value_get_string (value));
		break;
		case DEVICE_PARTITION_PARENT:
		device_partition_set_parent (self, g_value_get_int (value));
		break;
		case DEVICE_PARTITION_DESCRIPTION:
		device_partition_set_description (self, g_value_get_string (value));
		break;
		case DEVICE_PARTITION_PTYPE:
		device_partition_set_ptype (self, g_value_get_enum (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void device_class_init (DeviceClass * klass) {
	device_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DevicePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_device_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_device_set_property;
	G_OBJECT_CLASS (klass)->finalize = device_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DEVICE_PARTITIONS, g_param_spec_object ("partitions", "partitions", "partitions", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
}


static void device_instance_init (Device * self) {
	self->priv = DEVICE_GET_PRIVATE (self);
	self->priv->unit_size = (guint64) 1;
}


static void device_finalize (GObject* obj) {
	Device * self;
	gboolean _tmp0_ = FALSE;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DEVICE, Device);
	_tmp0_ = device_need_free;
	if (_tmp0_) {
	}
	_ped_disk_destroy0 (self->priv->disk);
	_g_object_unref0 (self->priv->_partitions);
	G_OBJECT_CLASS (device_parent_class)->finalize (obj);
}


GType device_get_type (void) {
	static volatile gsize device_type_id__volatile = 0;
	if (g_once_init_enter (&device_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DeviceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) device_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Device), 0, (GInstanceInitFunc) device_instance_init, NULL };
		GType device_type_id;
		device_type_id = g_type_register_static (G_TYPE_OBJECT, "Device", &g_define_type_info, 0);
		g_once_init_leave (&device_type_id__volatile, device_type_id);
	}
	return device_type_id__volatile;
}


static void _vala_device_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Device * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DEVICE, Device);
	switch (property_id) {
		case DEVICE_PARTITIONS:
		g_value_set_object (value, device_get_partitions (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_device_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Device * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DEVICE, Device);
	switch (property_id) {
		case DEVICE_PARTITIONS:
		device_set_partitions (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void* _parted_js_get_devices_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = parted_js_get_devices (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


GeeArrayList* parted_get_devices (gboolean from_cache) {
	GeeArrayList* result = NULL;
	gboolean _tmp0_ = FALSE;
	GeeArrayList* _tmp3_ = NULL;
	GeeHashMap* devices = NULL;
	GeeHashMap* _tmp4_ = NULL;
	Device* d = NULL;
	GeeArrayList* _tmp32_ = NULL;
	GeeArrayList* _tmp33_ = NULL;
	_tmp0_ = from_cache;
	if (_tmp0_ == TRUE) {
		GeeArrayList* _tmp1_ = NULL;
		GeeArrayList* _tmp2_ = NULL;
		_tmp1_ = parted_device_list;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = gee_array_list_new (TYPE_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (parted_device_list);
	parted_device_list = _tmp3_;
	_tmp4_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_LONG, NULL, NULL, NULL, NULL, NULL);
	devices = _tmp4_;
	d = NULL;
	while (TRUE) {
		Device* _tmp5_ = NULL;
		Device* _tmp6_ = NULL;
		Device* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		Device* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		_tmp5_ = d;
		_tmp6_ = device_new_from_list (_tmp5_);
		_g_object_unref0 (d);
		d = _tmp6_;
		_tmp7_ = d;
		_tmp8_ = device_is_valid (_tmp7_);
		if (_tmp8_ == FALSE) {
			break;
		}
		_tmp9_ = d;
		_tmp10_ = device_get_path (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_str_has_prefix (_tmp11_, "/dev/sr");
		_tmp13_ = !_tmp12_;
		_g_free0 (_tmp11_);
		if (_tmp13_) {
			GeeArrayList* _tmp14_ = NULL;
			Device* _tmp15_ = NULL;
			_tmp14_ = parted_device_list;
			_tmp15_ = d;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, _tmp15_);
		}
	}
	{
		GeeIterator* _device_it = NULL;
		GeeHashMap* _tmp16_ = NULL;
		GeeSet* _tmp17_ = NULL;
		GeeSet* _tmp18_ = NULL;
		GeeSet* _tmp19_ = NULL;
		GeeIterator* _tmp20_ = NULL;
		GeeIterator* _tmp21_ = NULL;
		_tmp16_ = devices;
		_tmp17_ = gee_abstract_map_get_keys ((GeeMap*) _tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = _tmp18_;
		_tmp20_ = gee_iterable_iterator ((GeeIterable*) _tmp19_);
		_tmp21_ = _tmp20_;
		_g_object_unref0 (_tmp19_);
		_device_it = _tmp21_;
		while (TRUE) {
			GeeIterator* _tmp22_ = NULL;
			gboolean _tmp23_ = FALSE;
			gchar* device = NULL;
			GeeIterator* _tmp24_ = NULL;
			gpointer _tmp25_ = NULL;
			const gchar* _tmp26_ = NULL;
			Device* _tmp27_ = NULL;
			Device* _tmp28_ = NULL;
			gboolean _tmp29_ = FALSE;
			_tmp22_ = _device_it;
			_tmp23_ = gee_iterator_next (_tmp22_);
			if (!_tmp23_) {
				break;
			}
			_tmp24_ = _device_it;
			_tmp25_ = gee_iterator_get (_tmp24_);
			device = (gchar*) _tmp25_;
			_tmp26_ = device;
			_tmp27_ = device_new_from_name (_tmp26_);
			_g_object_unref0 (d);
			d = _tmp27_;
			_tmp28_ = d;
			_tmp29_ = device_is_valid (_tmp28_);
			if (_tmp29_) {
				GeeArrayList* _tmp30_ = NULL;
				Device* _tmp31_ = NULL;
				_tmp30_ = parted_device_list;
				_tmp31_ = d;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp30_, _tmp31_);
			}
			_g_free0 (device);
		}
		_g_object_unref0 (_device_it);
	}
	_tmp32_ = parted_device_list;
	_tmp33_ = _g_object_ref0 (_tmp32_);
	result = _tmp33_;
	_g_object_unref0 (d);
	_g_object_unref0 (devices);
	return result;
}


gchar* parted_get_devices_json (void) {
	gchar* result = NULL;
	gchar* retval = NULL;
	gchar* _tmp0_ = NULL;
	GeeArrayList* list = NULL;
	GeeArrayList* _tmp1_ = NULL;
	gboolean need_comma = FALSE;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp167_ = NULL;
	gchar* _tmp168_ = NULL;
	_tmp0_ = g_strdup ("");
	retval = _tmp0_;
	_tmp1_ = parted_get_devices (FALSE);
	list = _tmp1_;
	need_comma = FALSE;
	_tmp2_ = retval;
	_tmp3_ = g_strconcat (_tmp2_, "[\n", NULL);
	_g_free0 (retval);
	retval = _tmp3_;
	{
		GeeArrayList* _device_list = NULL;
		GeeArrayList* _tmp4_ = NULL;
		GeeArrayList* _tmp5_ = NULL;
		gint _device_size = 0;
		GeeArrayList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _device_index = 0;
		_tmp4_ = list;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		_device_list = _tmp5_;
		_tmp6_ = _device_list;
		_tmp7_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_device_size = _tmp8_;
		_device_index = -1;
		while (TRUE) {
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			Device* device = NULL;
			GeeArrayList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gpointer _tmp14_ = NULL;
			gboolean _tmp15_ = FALSE;
			const gchar* _tmp18_ = NULL;
			Device* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			gchar* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			Device* _tmp28_ = NULL;
			guint64 _tmp29_ = 0ULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			gchar* _tmp32_ = NULL;
			gchar* _tmp33_ = NULL;
			gchar* _tmp34_ = NULL;
			gchar* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			Device* _tmp38_ = NULL;
			gchar* _tmp39_ = NULL;
			gchar* _tmp40_ = NULL;
			gchar* _tmp41_ = NULL;
			gchar* _tmp42_ = NULL;
			gchar* _tmp43_ = NULL;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			const gchar* _tmp46_ = NULL;
			Device* _tmp47_ = NULL;
			gchar* _tmp48_ = NULL;
			gchar* _tmp49_ = NULL;
			gchar* _tmp50_ = NULL;
			gchar* _tmp51_ = NULL;
			gchar* _tmp52_ = NULL;
			gchar* _tmp53_ = NULL;
			gchar* _tmp54_ = NULL;
			const gchar* _tmp55_ = NULL;
			gchar* _tmp56_ = NULL;
			Device* _tmp57_ = NULL;
			GeeArrayList* _tmp58_ = NULL;
			GeeArrayList* _tmp59_ = NULL;
			const gchar* _tmp163_ = NULL;
			gchar* _tmp164_ = NULL;
			const gchar* _tmp165_ = NULL;
			gchar* _tmp166_ = NULL;
			_tmp9_ = _device_index;
			_device_index = _tmp9_ + 1;
			_tmp10_ = _device_index;
			_tmp11_ = _device_size;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = _device_list;
			_tmp13_ = _device_index;
			_tmp14_ = gee_abstract_list_get ((GeeAbstractList*) _tmp12_, _tmp13_);
			device = (Device*) _tmp14_;
			_tmp15_ = need_comma;
			if (_tmp15_) {
				const gchar* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				_tmp16_ = retval;
				_tmp17_ = g_strconcat (_tmp16_, ",\n", NULL);
				_g_free0 (retval);
				retval = _tmp17_;
			}
			_tmp18_ = retval;
			_tmp19_ = device;
			_tmp20_ = device_get_path (_tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat (" { 'path' : '", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strconcat (_tmp23_, "',\n", NULL);
			_tmp25_ = _tmp24_;
			_tmp26_ = g_strconcat (_tmp18_, _tmp25_, NULL);
			_g_free0 (retval);
			retval = _tmp26_;
			_g_free0 (_tmp25_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
			_tmp27_ = retval;
			_tmp28_ = device;
			_tmp29_ = device_get_size (_tmp28_);
			_tmp30_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp29_);
			_tmp31_ = _tmp30_;
			_tmp32_ = g_strconcat (" 'size' : ", _tmp31_, NULL);
			_tmp33_ = _tmp32_;
			_tmp34_ = g_strconcat (_tmp33_, ",\n", NULL);
			_tmp35_ = _tmp34_;
			_tmp36_ = g_strconcat (_tmp27_, _tmp35_, NULL);
			_g_free0 (retval);
			retval = _tmp36_;
			_g_free0 (_tmp35_);
			_g_free0 (_tmp33_);
			_g_free0 (_tmp31_);
			_tmp37_ = retval;
			_tmp38_ = device;
			_tmp39_ = device_get_model (_tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = g_strconcat (" 'model' : '", _tmp40_, NULL);
			_tmp42_ = _tmp41_;
			_tmp43_ = g_strconcat (_tmp42_, "',\n", NULL);
			_tmp44_ = _tmp43_;
			_tmp45_ = g_strconcat (_tmp37_, _tmp44_, NULL);
			_g_free0 (retval);
			retval = _tmp45_;
			_g_free0 (_tmp44_);
			_g_free0 (_tmp42_);
			_g_free0 (_tmp40_);
			_tmp46_ = retval;
			_tmp47_ = device;
			_tmp48_ = device_get_label (_tmp47_);
			_tmp49_ = _tmp48_;
			_tmp50_ = g_strconcat (" 'label' : '", _tmp49_, NULL);
			_tmp51_ = _tmp50_;
			_tmp52_ = g_strconcat (_tmp51_, "',\n", NULL);
			_tmp53_ = _tmp52_;
			_tmp54_ = g_strconcat (_tmp46_, _tmp53_, NULL);
			_g_free0 (retval);
			retval = _tmp54_;
			_g_free0 (_tmp53_);
			_g_free0 (_tmp51_);
			_g_free0 (_tmp49_);
			_tmp55_ = retval;
			_tmp56_ = g_strconcat (_tmp55_, " 'partitions' : [\n", NULL);
			_g_free0 (retval);
			retval = _tmp56_;
			need_comma = FALSE;
			_tmp57_ = device;
			_tmp58_ = device_get_partitions (_tmp57_);
			_tmp59_ = _tmp58_;
			if (_tmp59_ != NULL) {
				{
					GeeArrayList* _partition_list = NULL;
					Device* _tmp60_ = NULL;
					GeeArrayList* _tmp61_ = NULL;
					GeeArrayList* _tmp62_ = NULL;
					GeeArrayList* _tmp63_ = NULL;
					gint _partition_size = 0;
					GeeArrayList* _tmp64_ = NULL;
					gint _tmp65_ = 0;
					gint _tmp66_ = 0;
					gint _partition_index = 0;
					_tmp60_ = device;
					_tmp61_ = device_get_partitions (_tmp60_);
					_tmp62_ = _tmp61_;
					_tmp63_ = _g_object_ref0 (_tmp62_);
					_partition_list = _tmp63_;
					_tmp64_ = _partition_list;
					_tmp65_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp64_);
					_tmp66_ = _tmp65_;
					_partition_size = _tmp66_;
					_partition_index = -1;
					while (TRUE) {
						gint _tmp67_ = 0;
						gint _tmp68_ = 0;
						gint _tmp69_ = 0;
						DevicePartition* partition = NULL;
						GeeArrayList* _tmp70_ = NULL;
						gint _tmp71_ = 0;
						gpointer _tmp72_ = NULL;
						gboolean _tmp73_ = FALSE;
						const gchar* _tmp76_ = NULL;
						gchar* _tmp77_ = NULL;
						const gchar* _tmp78_ = NULL;
						DevicePartition* _tmp79_ = NULL;
						gint _tmp80_ = 0;
						gint _tmp81_ = 0;
						gchar* _tmp82_ = NULL;
						gchar* _tmp83_ = NULL;
						gchar* _tmp84_ = NULL;
						gchar* _tmp85_ = NULL;
						gchar* _tmp86_ = NULL;
						gchar* _tmp87_ = NULL;
						gchar* _tmp88_ = NULL;
						const gchar* _tmp89_ = NULL;
						DevicePartition* _tmp90_ = NULL;
						gint _tmp91_ = 0;
						gint _tmp92_ = 0;
						gchar* _tmp93_ = NULL;
						gchar* _tmp94_ = NULL;
						gchar* _tmp95_ = NULL;
						gchar* _tmp96_ = NULL;
						gchar* _tmp97_ = NULL;
						gchar* _tmp98_ = NULL;
						gchar* _tmp99_ = NULL;
						const gchar* _tmp100_ = NULL;
						DevicePartition* _tmp101_ = NULL;
						guint64 _tmp102_ = 0ULL;
						guint64 _tmp103_ = 0ULL;
						gchar* _tmp104_ = NULL;
						gchar* _tmp105_ = NULL;
						gchar* _tmp106_ = NULL;
						gchar* _tmp107_ = NULL;
						gchar* _tmp108_ = NULL;
						gchar* _tmp109_ = NULL;
						gchar* _tmp110_ = NULL;
						const gchar* _tmp111_ = NULL;
						DevicePartition* _tmp112_ = NULL;
						guint64 _tmp113_ = 0ULL;
						guint64 _tmp114_ = 0ULL;
						gchar* _tmp115_ = NULL;
						gchar* _tmp116_ = NULL;
						gchar* _tmp117_ = NULL;
						gchar* _tmp118_ = NULL;
						gchar* _tmp119_ = NULL;
						gchar* _tmp120_ = NULL;
						gchar* _tmp121_ = NULL;
						const gchar* _tmp122_ = NULL;
						DevicePartition* _tmp123_ = NULL;
						guint64 _tmp124_ = 0ULL;
						guint64 _tmp125_ = 0ULL;
						gchar* _tmp126_ = NULL;
						gchar* _tmp127_ = NULL;
						gchar* _tmp128_ = NULL;
						gchar* _tmp129_ = NULL;
						gchar* _tmp130_ = NULL;
						gchar* _tmp131_ = NULL;
						gchar* _tmp132_ = NULL;
						const gchar* _tmp133_ = NULL;
						DevicePartition* _tmp134_ = NULL;
						DevicePartitionType _tmp135_ = 0;
						DevicePartitionType _tmp136_ = 0;
						GEnumValue* _tmp137_;
						gchar* _tmp138_ = NULL;
						gchar* _tmp139_ = NULL;
						gchar* _tmp140_ = NULL;
						gchar* _tmp141_ = NULL;
						gchar* _tmp142_ = NULL;
						const gchar* _tmp143_ = NULL;
						DevicePartition* _tmp144_ = NULL;
						const gchar* _tmp145_ = NULL;
						const gchar* _tmp146_ = NULL;
						gchar* _tmp147_ = NULL;
						gchar* _tmp148_ = NULL;
						gchar* _tmp149_ = NULL;
						gchar* _tmp150_ = NULL;
						gchar* _tmp151_ = NULL;
						const gchar* _tmp152_ = NULL;
						DevicePartition* _tmp153_ = NULL;
						const gchar* _tmp154_ = NULL;
						const gchar* _tmp155_ = NULL;
						gchar* _tmp156_ = NULL;
						gchar* _tmp157_ = NULL;
						gchar* _tmp158_ = NULL;
						gchar* _tmp159_ = NULL;
						gchar* _tmp160_ = NULL;
						const gchar* _tmp161_ = NULL;
						gchar* _tmp162_ = NULL;
						_tmp67_ = _partition_index;
						_partition_index = _tmp67_ + 1;
						_tmp68_ = _partition_index;
						_tmp69_ = _partition_size;
						if (!(_tmp68_ < _tmp69_)) {
							break;
						}
						_tmp70_ = _partition_list;
						_tmp71_ = _partition_index;
						_tmp72_ = gee_abstract_list_get ((GeeAbstractList*) _tmp70_, _tmp71_);
						partition = (DevicePartition*) _tmp72_;
						_tmp73_ = need_comma;
						if (_tmp73_) {
							const gchar* _tmp74_ = NULL;
							gchar* _tmp75_ = NULL;
							_tmp74_ = retval;
							_tmp75_ = g_strconcat (_tmp74_, ",\n", NULL);
							_g_free0 (retval);
							retval = _tmp75_;
						}
						_tmp76_ = retval;
						_tmp77_ = g_strconcat (_tmp76_, "     {\n", NULL);
						_g_free0 (retval);
						retval = _tmp77_;
						_tmp78_ = retval;
						_tmp79_ = partition;
						_tmp80_ = device_partition_get_number (_tmp79_);
						_tmp81_ = _tmp80_;
						_tmp82_ = g_strdup_printf ("%i", _tmp81_);
						_tmp83_ = _tmp82_;
						_tmp84_ = g_strconcat ("     'id': ", _tmp83_, NULL);
						_tmp85_ = _tmp84_;
						_tmp86_ = g_strconcat (_tmp85_, ",\n", NULL);
						_tmp87_ = _tmp86_;
						_tmp88_ = g_strconcat (_tmp78_, _tmp87_, NULL);
						_g_free0 (retval);
						retval = _tmp88_;
						_g_free0 (_tmp87_);
						_g_free0 (_tmp85_);
						_g_free0 (_tmp83_);
						_tmp89_ = retval;
						_tmp90_ = partition;
						_tmp91_ = device_partition_get_parent (_tmp90_);
						_tmp92_ = _tmp91_;
						_tmp93_ = g_strdup_printf ("%i", _tmp92_);
						_tmp94_ = _tmp93_;
						_tmp95_ = g_strconcat ("     'parent': ", _tmp94_, NULL);
						_tmp96_ = _tmp95_;
						_tmp97_ = g_strconcat (_tmp96_, ",\n", NULL);
						_tmp98_ = _tmp97_;
						_tmp99_ = g_strconcat (_tmp89_, _tmp98_, NULL);
						_g_free0 (retval);
						retval = _tmp99_;
						_g_free0 (_tmp98_);
						_g_free0 (_tmp96_);
						_g_free0 (_tmp94_);
						_tmp100_ = retval;
						_tmp101_ = partition;
						_tmp102_ = device_partition_get_start (_tmp101_);
						_tmp103_ = _tmp102_;
						_tmp104_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp103_);
						_tmp105_ = _tmp104_;
						_tmp106_ = g_strconcat ("     'start': ", _tmp105_, NULL);
						_tmp107_ = _tmp106_;
						_tmp108_ = g_strconcat (_tmp107_, ",\n", NULL);
						_tmp109_ = _tmp108_;
						_tmp110_ = g_strconcat (_tmp100_, _tmp109_, NULL);
						_g_free0 (retval);
						retval = _tmp110_;
						_g_free0 (_tmp109_);
						_g_free0 (_tmp107_);
						_g_free0 (_tmp105_);
						_tmp111_ = retval;
						_tmp112_ = partition;
						_tmp113_ = device_partition_get_end (_tmp112_);
						_tmp114_ = _tmp113_;
						_tmp115_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp114_);
						_tmp116_ = _tmp115_;
						_tmp117_ = g_strconcat ("     'end': ", _tmp116_, NULL);
						_tmp118_ = _tmp117_;
						_tmp119_ = g_strconcat (_tmp118_, ",\n", NULL);
						_tmp120_ = _tmp119_;
						_tmp121_ = g_strconcat (_tmp111_, _tmp120_, NULL);
						_g_free0 (retval);
						retval = _tmp121_;
						_g_free0 (_tmp120_);
						_g_free0 (_tmp118_);
						_g_free0 (_tmp116_);
						_tmp122_ = retval;
						_tmp123_ = partition;
						_tmp124_ = device_partition_get_size (_tmp123_);
						_tmp125_ = _tmp124_;
						_tmp126_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp125_);
						_tmp127_ = _tmp126_;
						_tmp128_ = g_strconcat ("     'size': ", _tmp127_, NULL);
						_tmp129_ = _tmp128_;
						_tmp130_ = g_strconcat (_tmp129_, ",\n", NULL);
						_tmp131_ = _tmp130_;
						_tmp132_ = g_strconcat (_tmp122_, _tmp131_, NULL);
						_g_free0 (retval);
						retval = _tmp132_;
						_g_free0 (_tmp131_);
						_g_free0 (_tmp129_);
						_g_free0 (_tmp127_);
						_tmp133_ = retval;
						_tmp134_ = partition;
						_tmp135_ = device_partition_get_ptype (_tmp134_);
						_tmp136_ = _tmp135_;
						_tmp137_ = g_enum_get_value (g_type_class_ref (DEVICE_TYPE_PARTITION_TYPE), _tmp136_);
						_tmp138_ = g_strconcat ("     'type': '", (_tmp137_ != NULL) ? _tmp137_->value_name : NULL, NULL);
						_tmp139_ = _tmp138_;
						_tmp140_ = g_strconcat (_tmp139_, "',\n", NULL);
						_tmp141_ = _tmp140_;
						_tmp142_ = g_strconcat (_tmp133_, _tmp141_, NULL);
						_g_free0 (retval);
						retval = _tmp142_;
						_g_free0 (_tmp141_);
						_g_free0 (_tmp139_);
						_tmp143_ = retval;
						_tmp144_ = partition;
						_tmp145_ = device_partition_get_filesystem (_tmp144_);
						_tmp146_ = _tmp145_;
						_tmp147_ = g_strconcat ("     'filesystem': '", _tmp146_, NULL);
						_tmp148_ = _tmp147_;
						_tmp149_ = g_strconcat (_tmp148_, "',\n", NULL);
						_tmp150_ = _tmp149_;
						_tmp151_ = g_strconcat (_tmp143_, _tmp150_, NULL);
						_g_free0 (retval);
						retval = _tmp151_;
						_g_free0 (_tmp150_);
						_g_free0 (_tmp148_);
						_tmp152_ = retval;
						_tmp153_ = partition;
						_tmp154_ = device_partition_get_description (_tmp153_);
						_tmp155_ = _tmp154_;
						_tmp156_ = g_strconcat ("     'description': '", _tmp155_, NULL);
						_tmp157_ = _tmp156_;
						_tmp158_ = g_strconcat (_tmp157_, "',\n", NULL);
						_tmp159_ = _tmp158_;
						_tmp160_ = g_strconcat (_tmp152_, _tmp159_, NULL);
						_g_free0 (retval);
						retval = _tmp160_;
						_g_free0 (_tmp159_);
						_g_free0 (_tmp157_);
						_tmp161_ = retval;
						_tmp162_ = g_strconcat (_tmp161_, "     }\n", NULL);
						_g_free0 (retval);
						retval = _tmp162_;
						need_comma = TRUE;
						_g_object_unref0 (partition);
					}
					_g_object_unref0 (_partition_list);
				}
			}
			_tmp163_ = retval;
			_tmp164_ = g_strconcat (_tmp163_, " ]\n", NULL);
			_g_free0 (retval);
			retval = _tmp164_;
			_tmp165_ = retval;
			_tmp166_ = g_strconcat (_tmp165_, "}\n", NULL);
			_g_free0 (retval);
			retval = _tmp166_;
			need_comma = TRUE;
			_g_object_unref0 (device);
		}
		_g_object_unref0 (_device_list);
	}
	_tmp167_ = retval;
	_tmp168_ = g_strconcat (_tmp167_, "]", NULL);
	_g_free0 (retval);
	retval = _tmp168_;
	result = retval;
	_g_object_unref0 (list);
	return result;
}


gchar* parted_process_request (const gchar* uri) {
	gchar* result = NULL;
	gchar** reqs = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint reqs_length1 = 0;
	gint _reqs_size_ = 0;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "parted/", 0);
	reqs = _tmp2_;
	reqs_length1 = _vala_array_length (_tmp1_);
	_reqs_size_ = reqs_length1;
	_tmp3_ = reqs;
	_tmp3__length1 = reqs_length1;
	_tmp4_ = _tmp3_[1];
	if (g_strcmp0 (_tmp4_, "get_devices") == 0) {
		gchar* _tmp5_ = NULL;
		_tmp5_ = parted_get_devices_json ();
		result = _tmp5_;
		reqs = (_vala_array_free (reqs, reqs_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp6_ = g_strdup ("{}");
	result = _tmp6_;
	reqs = (_vala_array_free (reqs, reqs_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


Parted* parted_construct (GType object_type) {
	Parted* self = NULL;
	self = (Parted*) g_type_create_instance (object_type);
	return self;
}


Parted* parted_new (void) {
	return parted_construct (TYPE_PARTED);
}


void* parted_js_get_devices (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* s = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = parted_get_devices_json ();
	_tmp1_ = _tmp0_;
	_tmp2_ = JSStringCreateWithUTF8CString (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	s = _tmp3_;
	_tmp4_ = ctx;
	_tmp5_ = JSEvaluateScript (_tmp4_, s, NULL, NULL, 0, NULL);
	result = _tmp5_;
	_JSStringRelease0 (s);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void parted_setup_js_class (void* context) {
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* g = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* s = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	g_return_if_fail (context != NULL);
	_tmp0_ = JSClassCreate (&PARTED_js_class);
	c = _tmp0_;
	_tmp1_ = context;
	_tmp2_ = context;
	_tmp3_ = JSObjectMake (_tmp1_, c, _tmp2_);
	o = _tmp3_;
	_tmp4_ = context;
	_tmp5_ = JSContextGetGlobalObject (_tmp4_);
	g = _tmp5_;
	_tmp6_ = JSStringCreateWithUTF8CString ("Parted");
	s = _tmp6_;
	_tmp7_ = context;
	JSObjectSetProperty (_tmp7_, g, s, o, kJSPropertyAttributeNone, NULL);
	_JSStringRelease0 (s);
	_0 (g);
	_0 (o);
	_JSClassRelease0 (c);
}


static void value_parted_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_parted_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		parted_unref (value->data[0].v_pointer);
	}
}


static void value_parted_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = parted_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_parted_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_parted_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Parted* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = parted_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_parted_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Parted** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = parted_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_parted (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecParted* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PARTED), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_parted (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARTED), NULL);
	return value->data[0].v_pointer;
}


void value_set_parted (GValue* value, gpointer v_object) {
	Parted* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARTED));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARTED));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		parted_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parted_unref (old);
	}
}


void value_take_parted (GValue* value, gpointer v_object) {
	Parted* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARTED));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARTED));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parted_unref (old);
	}
}


static void parted_class_init (PartedClass * klass) {
	parted_parent_class = g_type_class_peek_parent (klass);
	((PartedClass *) klass)->finalize = parted_finalize;
}


static void parted_instance_init (Parted * self) {
	self->ref_count = 1;
}


static void parted_finalize (Parted* obj) {
	Parted * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARTED, Parted);
	g_signal_handlers_destroy (self);
}


GType parted_get_type (void) {
	static volatile gsize parted_type_id__volatile = 0;
	if (g_once_init_enter (&parted_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_parted_init, value_parted_free_value, value_parted_copy_value, value_parted_peek_pointer, "p", value_parted_collect_value, "p", value_parted_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PartedClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parted_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Parted), 0, (GInstanceInitFunc) parted_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType parted_type_id;
		parted_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Parted", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&parted_type_id__volatile, parted_type_id);
	}
	return parted_type_id__volatile;
}


gpointer parted_ref (gpointer instance) {
	Parted* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void parted_unref (gpointer instance) {
	Parted* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PARTED_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



